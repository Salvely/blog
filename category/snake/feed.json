{
    "version": "https://jsonfeed.org/version/1",
    "title": "望春风 • All posts by \"snake\" category",
    "description": "计算机&数理&文学爱好者，喜欢健身、下厨、听音乐和看电影",
    "home_page_url": "https://salvely.github.io/blog",
    "items": [
        {
            "id": "https://salvely.github.io/blog/2023/10/31/Projects/Snake/analysis/",
            "url": "https://salvely.github.io/blog/2023/10/31/Projects/Snake/analysis/",
            "title": "动手写贪吃蛇游戏",
            "date_published": "2023-10-31T02:04:46.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近学习了 C++ STL,想着自己使用 C++ 实现一个贪吃蛇的小游戏，锻炼一下 C++ 代码能力和软件工程能力。完整代码参见：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NhbHZlbHkvV2Vla2x5LXJlcG9ydC90cmVlL21haW4vd2VlazEvY29kZS9zbmFrZQ==\">贪吃蛇小游戏——C++实现</span></p>\n<h1 id=\"贪吃蛇的基本规则\"><a href=\"#贪吃蛇的基本规则\" class=\"headerlink\" title=\"贪吃蛇的基本规则\"></a>贪吃蛇的基本规则</h1><p>首先，有一块场地，场地周围是墙，场地内的部分是墙，部分是食物，部分是蛇。贪吃蛇没吃到任何东西，就正常移动；吃到食物，尾巴会增长；如果吃到了自己的尾巴或者撞了墙，游戏结束。</p>\n<h2 id=\"游戏基本设定\"><a href=\"#游戏基本设定\" class=\"headerlink\" title=\"游戏基本设定\"></a>游戏基本设定</h2><ol>\n<li>场地内部墙的个数在[1,min(height-2,width-2)]之间</li>\n<li>1 次只出现一个食物</li>\n<li>用户输入场地规格必须大于 3</li>\n<li>默认蛇的移动方向向右,初始位置随机生成</li>\n<li>如果贪吃蛇吃到了食物，会在新的地方生成食物</li>\n<li>因为本人使用<code>vscode</code>编程,无法弹出控制台,因此无法追踪光标位置,也就难以实现原地打印.因此,本程序中使用每 1s 打印一次棋盘的方式.</li>\n</ol>\n<h1 id=\"贪吃蛇对象划分\"><a href=\"#贪吃蛇对象划分\" class=\"headerlink\" title=\"贪吃蛇对象划分\"></a>贪吃蛇对象划分</h1><ul>\n<li>场地：周围用<strong>墙</strong>环绕，里面有部分墙，<strong>食物</strong>和<strong>蛇</strong></li>\n<li>游戏本身<ul>\n<li>游戏分数：贪吃蛇吃到的食物数量</li>\n<li>游戏状态：用<code>true</code>&#x2F;<code>false</code>表示是否结束</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"贪吃蛇对象设计\"><a href=\"#贪吃蛇对象设计\" class=\"headerlink\" title=\"贪吃蛇对象设计\"></a>贪吃蛇对象设计</h1><ul>\n<li>场地：<ul>\n<li>场地本身：使用一个二维数组表示，场地内的墙用<code>#</code>表示，蛇用<code>S</code>表示，食物用<code>$</code>表示，普通平地用&#96;&#96;表示。某个单位只能出现一个物种，不可能同时出现两种。</li>\n<li>场地的长、宽：用<code>int</code>类型表示</li>\n<li>蛇：使用一个结构体进行存储，其中几个字段分别为：<ul>\n<li>整条蛇的位置信息：使用一个<code>std::deque</code>存储，其中单个位置信息使用<code>std::pair&lt;int,int&gt;</code>来存储</li>\n<li>蛇的运动方向：使用<code>int</code>存储(使用一个枚举类型<code>INPUT_KEY</code>，来表示对应的<code>int</code>值)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>游戏：使用一个结构体进行存储，其中几个字段分别为：<ul>\n<li>游戏分数：使用<code>int</code>类型存储</li>\n<li>游戏状态：使用<code>true/false</code>表示是否结束</li>\n<li>用户的名字</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"游戏主逻辑设计\"><a href=\"#游戏主逻辑设计\" class=\"headerlink\" title=\"游戏主逻辑设计\"></a>游戏主逻辑设计</h1><ol>\n<li>提示用户输入游戏场地规格：长，宽 &#x2F; 默认（不输入）</li>\n<li>提示用户输入姓名</li>\n<li>初始化游戏场地</li>\n<li>初始化游戏分数和状态</li>\n<li>初始化默认开始方向</li>\n<li><code>while</code>游戏没有结束<ol>\n<li>获取用户方向输入</li>\n<li>如果没有输入方向，则按照上次的方向继续</li>\n<li>根据用户输入方向更新游戏状态</li>\n<li>打印棋盘</li>\n</ol>\n</li>\n<li>通知用户游戏结束，打印其姓名和分数，清理程序中所有的值</li>\n</ol>\n<h1 id=\"游戏状态更新逻辑\"><a href=\"#游戏状态更新逻辑\" class=\"headerlink\" title=\"游戏状态更新逻辑\"></a>游戏状态更新逻辑</h1><pre><code>1. 根据蛇头，计算下一个位置的坐标\n2. 如果场地中下个位置的值是`S`，判断其是否为蛇尾，如果不是蛇尾或者是墙，游戏结束\n3. 如果下个位置是`$`，则(不去掉蛇尾):\n   1. 游戏分数+1\n4. 否则：\n   1. 将场地蛇尾处`S`修改为&#39; &#39;\n5. 将下一个位置加载蛇头\n6. 将蛇头处&#39; &#39;修改为`S`\n</code></pre>\n<h1 id=\"游戏对象定义-game-init-h\"><a href=\"#游戏对象定义-game-init-h\" class=\"headerlink\" title=\"游戏对象定义(game_init.h)\"></a>游戏对象定义(<code>game_init.h</code>)</h1><h2 id=\"蛇\"><a href=\"#蛇\" class=\"headerlink\" title=\"蛇\"></a>蛇</h2><pre><code class=\"cpp\">#include &lt;deque&gt;\n\n// define the user input\nenum INPUT_KEY\n&#123;\n    RIGHT = 77,\n    LEFT = 75,\n    UP = 72,\n    DOWN = 80,\n&#125;;\n\n// define the snake\ntypedef struct\n&#123;\n    INPUT_KEY direction;\n    std::deque&lt;std::pair&lt;int, int&gt;&gt; position;\n&#125; snake;\n</code></pre>\n<h2 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h2><pre><code class=\"cpp\">// define the game\ntypedef struct\n&#123;\n    int score;\n    bool end;\n    char *name;\n&#125; game;\n</code></pre>\n<h2 id=\"场地\"><a href=\"#场地\" class=\"headerlink\" title=\"场地\"></a>场地</h2><pre><code class=\"cpp\">// define the board\ntypedef struct\n&#123;\n    char **arr;\n    int width;\n    int height;\n    snake s;\n&#125; board;\n</code></pre>\n<h1 id=\"游戏对象初始化（game-init-c）\"><a href=\"#游戏对象初始化（game-init-c）\" class=\"headerlink\" title=\"游戏对象初始化（game_init.c）\"></a>游戏对象初始化（<code>game_init.c</code>）</h1><h2 id=\"游戏初始化\"><a href=\"#游戏初始化\" class=\"headerlink\" title=\"游戏初始化\"></a>游戏初始化</h2><pre><code class=\"cpp\">/**\n * @brief Initialize the game\n *\n * @param g the game struct\n * @param name the name of the user\n */\nvoid init_game(game &amp;g, char *name)\n&#123;\n    g.end = false;\n    g.name = name;\n    g.score = 0;\n&#125;\n</code></pre>\n<h2 id=\"场地初始化\"><a href=\"#场地初始化\" class=\"headerlink\" title=\"场地初始化\"></a>场地初始化</h2><h3 id=\"初始化内容\"><a href=\"#初始化内容\" class=\"headerlink\" title=\"初始化内容\"></a>初始化内容</h3><p>场地的初始化包括初始化如下几个部分：</p>\n<blockquote>\n<ul>\n<li>场地：</li>\n<li>场地本身：使用一个二维数组表示，场地内的墙用<code>#</code>表示，蛇用<code>S</code>表示，食物用<code>$</code>表示，普通平地用&#96;&#96;表示。某个单位只能出现一个物种，不可能同时出现两种。</li>\n<li>场地的长、宽：用<code>int</code>类型表示</li>\n<li>蛇：使用一个结构体进行存储，其中几个字段分别为：<ul>\n<li>整条蛇的位置信息：使用一个<code>std::deque</code>存储，其中单个位置信息使用<code>std::pair&lt;int,int&gt;</code>来存储</li>\n<li>蛇的运动方向：使用<code>int</code>存储(使用一个枚举类型<code>INPUT_KEY</code>，来表示对应的<code>int</code>值)</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"初始化步骤\"><a href=\"#初始化步骤\" class=\"headerlink\" title=\"初始化步骤\"></a>初始化步骤</h3><p>初始化的过程分为如下步骤：</p>\n<ol>\n<li>初始化场地的长和宽</li>\n<li>初始化一个对应长和宽的二维数组，且其值为&#96;&#96;</li>\n<li>让二维数组的四周为<code>#</code></li>\n<li>使用随机数生成器生成一个[1,min(height-2,width-2)]内随机的内部墙数量</li>\n<li>随机生成内部墙的坐标</li>\n<li>在对应位置处放置<code>#</code></li>\n<li>随机生成食物的坐标</li>\n<li>在对应位置处放置<code>$</code></li>\n<li>随机生成蛇的坐标</li>\n<li>初始化蛇，方向向右</li>\n<li>在对应位置处放置<code>S</code></li>\n</ol>\n<h3 id=\"辅助函数-1：随机数生成器\"><a href=\"#辅助函数-1：随机数生成器\" class=\"headerlink\" title=\"辅助函数 1：随机数生成器\"></a>辅助函数 1：随机数生成器</h3><p>C++ <code>std::rand()</code> 函数生成一个 [0,<code>RAND_MAX</code>) 之间的数字。如果我们想生成一个 [0,num] 范围内的数字，需要 <code>(1 + std::rand()) % num</code>。如果<code>num&lt;=0</code>，我们不生成，直接返回 0。</p>\n<pre><code class=\"cpp\">/**\n * @brief generate a random number between [1,num]\n *\n * @param num the maximum of the random number\n * @return int the random number generated\n */\nint random(int num)\n&#123;\n    if (num &lt;= 0)\n    &#123;\n        return 0;\n    &#125;\n    return (1 + std::rand()) % num + 1;\n&#125;\n</code></pre>\n<h3 id=\"辅助函数-2：place函数\"><a href=\"#辅助函数-2：place函数\" class=\"headerlink\" title=\"辅助函数 2：place函数\"></a>辅助函数 2：<code>place</code>函数</h3><p><code>food</code>和<code>snake</code>一次只放置 1 个。<code>food</code>在初始化和每次被蛇吃掉后都需要重新放置（后期<code>update</code>）中还需要调用，而<code>snake</code>只有在初始化时候需要放置。因为其每次都是持续搜索，直到找到标记为&#96;&#96;的位置，因此我们写了一个<code>place</code>函数用于放置内容。该函数返回一个<code>pair</code>，用于<code>snake</code>初始化时将坐标压到<code>deque</code>中。</p>\n<pre><code class=\"cpp\">/**\n * @brief the generic method to place some char in the board\n *\n * @param b board\n * @param p the character to be placed\n */\nstd::pair&lt;int, int&gt; place(board &amp;b, char p)\n&#123;\n    int xPos_max = b.height - 2;\n    int yPos_max = b.width - 2;\n    int x = random(xPos_max);\n    int y = random(yPos_max);\n    if (b.arr[x][y] != &#39; &#39;)\n    &#123;\n        return place(b, p);\n    &#125;\n    else\n    &#123;\n        b.arr[x][y] = p;\n        return std::make_pair(x, y);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"辅助函数-3：place-food-place-snake\"><a href=\"#辅助函数-3：place-food-place-snake\" class=\"headerlink\" title=\"辅助函数 3：place_food &amp; place_snake\"></a>辅助函数 3：<code>place_food</code> &amp; <code>place_snake</code></h3><p>在<code>place_food</code>中，我们直接调用<code>place</code>函数，将传入的<code>char</code>设定为<code>$</code>；而在<code>place_snake</code>中，除了需要放置食物外，还需要将<code>place</code>函数返回的坐标压到<code>deque</code>中，并且初始化方向。</p>\n<pre><code class=\"cpp\">/**\n * @brief initialize the snake in the board\n *\n * @param b the game board\n */\nvoid place_snake(board &amp;b)\n&#123;\n    std::pair&lt;int, int&gt; snake_pos = place(b, &#39;S&#39;);\n    b.s.position.push_back(snake_pos);\n    b.s.direction = RIGHT;\n&#125;\n</code></pre>\n<h3 id=\"辅助函数-4：print-board\"><a href=\"#辅助函数-4：print-board\" class=\"headerlink\" title=\"辅助函数 4：print_board\"></a>辅助函数 4：<code>print_board</code></h3><pre><code class=\"cpp\">/**\n * @brief print the board of the game\n *\n * @param b the game board\n */\nvoid print_board(board &amp;b)\n&#123;\n    int head_x = b.s.position[0].first;\n    int head_y = b.s.position[0].second;\n    for (int i = 0; i &lt; b.height; i++)\n    &#123;\n        for (int j = 0; j &lt; b.width; j++)\n        &#123;\n            if(i == head_x &amp;&amp; j == head_y) &#123;\n                std::cout &lt;&lt; &quot;\\033[0;31m&quot; &lt;&lt; b.arr[i][j] &lt;&lt; &quot;\\033[0m&quot; &lt;&lt; &quot; &quot;;\n            &#125;\n            else&#123;\n                std::cout &lt;&lt; b.arr[i][j] &lt;&lt; &quot; &quot;;\n            &#125;\n        &#125;\n        std::cout &lt;&lt; std::endl;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"初始化board\"><a href=\"#初始化board\" class=\"headerlink\" title=\"初始化board\"></a>初始化<code>board</code></h3><p>该步骤遵循前文初始化步骤。</p>\n<pre><code class=\"cpp\">/**\n * @brief Initialize the board\n *\n * @param b the board struct\n * @param width the width of the board\n * @param height the height of the board\n */\nvoid init_board(board &amp;b, int width, int height)\n&#123;\n    // init the width and height\n    b.width = width;\n    b.height = height;\n\n    // init the board string and fill it with ` `\n    b.arr = new char *[height];\n    for (int i = 0; i &lt; height; i++)\n    &#123;\n        b.arr[i] = new char[width];\n        std::fill(b.arr[i][0], b.arr[i][width - 1], &#39; &#39;);\n    &#125;\n\n    // init the wall around the board\n    std::fill(b.arr[0][0], b.arr[0][width - 1], &#39;#&#39;);\n    for (int i = 1; i &lt; height - 1; i++)\n    &#123;\n        b.arr[i][0] = &#39;#&#39;;\n        b.arr[i][width - 1] = &#39;#&#39;;\n    &#125;\n    std::fill(b.arr[height - 1][0], b.arr[height - 1][width - 1], &#39;#&#39;);\n\n    // calculate the scope of xPos and yPos\n    int xPos_max = height - 2;\n    int yPos_max = width - 2;\n\n    // init the wall in inside the board\n    int wall_num = random(std::min(height - 2, width - 2));\n    for (int i = 0; i &lt; wall_num; i++)\n    &#123;\n        int x = random(xPos_max);\n        int y = random(yPos_max);\n        b.arr[x][y] = &#39;#&#39;;\n    &#125;\n\n    // init the food\n    place_food(b);\n\n    // init the snake\n    place_snake(b);\n&#125;\n</code></pre>\n<h1 id=\"游戏逻辑实现\"><a href=\"#游戏逻辑实现\" class=\"headerlink\" title=\"游戏逻辑实现\"></a>游戏逻辑实现</h1><blockquote>\n<ol>\n<li>提示用户输入游戏场地规格：长，宽 &#x2F; 默认（不输入）,如果长或宽小于 3,则提示用户重新输入</li>\n<li>提示用户输入姓名</li>\n<li>初始化游戏场地</li>\n<li>初始化游戏分数和状态</li>\n<li>初始化默认开始方向</li>\n<li><code>while</code>游戏没有结束:</li>\n<li>获取用户方向输入</li>\n<li>如果没有输入方向，则按照上次的方向继续</li>\n<li>根据用户输入方向更新游戏状态</li>\n<li>通知用户游戏结束，打印其姓名和分数，清理程序中所有的值</li>\n</ol>\n</blockquote>\n<pre><code class=\"cpp\">    // the game loop\n    while (!g.end)\n    &#123;\n        if (_kbhit())\n        &#123;\n            _getch();\n            int key = _getch();\n            b.s.direction = static_cast&lt;INPUT_KEY&gt;(key);\n        &#125;\n        update(g, b);\n        print_board(b);\n        sleep(1);\n    &#125;\n</code></pre>\n<h1 id=\"游戏结束\"><a href=\"#游戏结束\" class=\"headerlink\" title=\"游戏结束\"></a>游戏结束</h1><pre><code class=\"cpp\">  // end the game\n  std::cout &lt;&lt; &quot;Game Over!&quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Your Score is: &quot; &lt;&lt; g.score &lt;&lt; std::endl;\n\n  // clear the game state\n  delete[] name;\n  for (int i = 0; i &lt; b.height; i++)\n  &#123;\n      delete[] b.arr[i];\n  &#125;\n  delete[] b.arr;\n</code></pre>\n<h1 id=\"update函数更新游戏状态\"><a href=\"#update函数更新游戏状态\" class=\"headerlink\" title=\"update函数更新游戏状态\"></a><code>update</code>函数更新游戏状态</h1><h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><pre><code>1. 根据蛇头，计算下一个位置的坐标\n2. 如果场地中下个位置的值是`S`，判断其是否为蛇尾，如果不是蛇尾或者是墙，游戏结束\n3. 如果下个位置是`$`，则(不去掉蛇尾):\n   1. 游戏分数+1\n4. 否则：\n   1. 将场地蛇尾处`S`修改为&#39; &#39;\n5. 将下一个位置加载蛇头\n6. 将蛇头处&#39; &#39;修改为`S`\n</code></pre>\n<h2 id=\"update函数\"><a href=\"#update函数\" class=\"headerlink\" title=\"update函数\"></a><code>update</code>函数</h2><pre><code class=\"cpp\">void update(game &amp;g, board &amp;b)\n&#123;\n    // get the current snake head\n    std::pair&lt;int, int&gt; head = b.s.position[0];\n    int x = head.first;\n    int y = head.second;\n\n    // get the snake tail\n    std::pair&lt;int, int&gt; tail = b.s.position.back();\n    int tail_x = tail.first;\n    int tail_y = tail.second;\n\n    // obtain the next position\n    switch (b.s.direction)\n    &#123;\n    case UP:\n        x -= 1;\n        break;\n    case DOWN:\n        x += 1;\n        break;\n    case RIGHT:\n        y += 1;\n        break;\n    case LEFT:\n        y -= 1;\n        break;\n    default:\n        break;\n    &#125;\n\n    // if the next position is &#39;#&#39; or snake body, exit the game\n    if (b.arr[x][y] == &#39;#&#39; || (b.arr[x][y] == &#39;S&#39; &amp;&amp; x != tail_x &amp;&amp; y != tail_y))\n    &#123;\n        g.end = true;\n        return;\n    &#125;\n\n    // if the next poistion is food\n    if (b.arr[x][y] == &#39;$&#39;)\n    &#123;\n        g.score += 1;\n    &#125;\n    else\n    &#123;\n        b.arr[tail_x][tail_y] = &#39; &#39;;\n        b.s.position.pop_back();\n    &#125;\n    b.s.position.push_front(std::pair&lt;int, int&gt;(x, y));\n    b.arr[x][y] = &#39;S&#39;;\n&#125;\n</code></pre>\n<h1 id=\"bug-修复\"><a href=\"#bug-修复\" class=\"headerlink\" title=\"bug 修复\"></a>bug 修复</h1><ol>\n<li><code>random()</code>随机数产生需要在后面 +1</li>\n<li>为<code>board</code>新增<code>plain</code>字段, 让蛇占据所有空间后,通知用户通关!</li>\n<li>长度为 1 时,可以反方向运动</li>\n</ol>\n",
            "tags": [
                "C++"
            ]
        }
    ]
}