<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>望春风 • Posts by &#34;snake&#34; category</title>
        <link>https://salvely.github.io/blog</link>
        <description>计算机&amp;数理&amp;文学爱好者，喜欢健身、下厨、听音乐和看电影</description>
        <language>zh-CN</language>
        <pubDate>Tue, 31 Oct 2023 10:04:46 +0800</pubDate>
        <lastBuildDate>Tue, 31 Oct 2023 10:04:46 +0800</lastBuildDate>
        <category>C++</category>
        <category>Arch</category>
        <category>Linux</category>
        <category>安装教程</category>
        <category>操作系统</category>
        <category>notes</category>
        <category>配置教程</category>
        <category>Debian</category>
        <category>包管理</category>
        <category>参考资料</category>
        <category>CMake</category>
        <category>Makefile</category>
        <item>
            <guid isPermalink="true">https://salvely.github.io/blog/2023/10/31/Projects/Snake/analysis/</guid>
            <title>动手写贪吃蛇游戏</title>
            <link>https://salvely.github.io/blog/2023/10/31/Projects/Snake/analysis/</link>
            <category>C++</category>
            <pubDate>Tue, 31 Oct 2023 10:04:46 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近学习了 C++ STL,想着自己使用 C++ 实现一个贪吃蛇的小游戏，锻炼一下 C++ 代码能力和软件工程能力。完整代码参见：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL1NhbHZlbHkvV2Vla2x5LXJlcG9ydC90cmVlL21haW4vd2VlazEvY29kZS9zbmFrZQ==&#34;&gt;贪吃蛇小游戏——C++实现&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&#34;贪吃蛇的基本规则&#34;&gt;&lt;a href=&#34;#贪吃蛇的基本规则&#34; class=&#34;headerlink&#34; title=&#34;贪吃蛇的基本规则&#34;&gt;&lt;/a&gt;贪吃蛇的基本规则&lt;/h1&gt;&lt;p&gt;首先，有一块场地，场地周围是墙，场地内的部分是墙，部分是食物，部分是蛇。贪吃蛇没吃到任何东西，就正常移动；吃到食物，尾巴会增长；如果吃到了自己的尾巴或者撞了墙，游戏结束。&lt;/p&gt;
&lt;h2 id=&#34;游戏基本设定&#34;&gt;&lt;a href=&#34;#游戏基本设定&#34; class=&#34;headerlink&#34; title=&#34;游戏基本设定&#34;&gt;&lt;/a&gt;游戏基本设定&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;场地内部墙的个数在[1,min(height-2,width-2)]之间&lt;/li&gt;
&lt;li&gt;1 次只出现一个食物&lt;/li&gt;
&lt;li&gt;用户输入场地规格必须大于 3&lt;/li&gt;
&lt;li&gt;默认蛇的移动方向向右,初始位置随机生成&lt;/li&gt;
&lt;li&gt;如果贪吃蛇吃到了食物，会在新的地方生成食物&lt;/li&gt;
&lt;li&gt;因为本人使用&lt;code&gt;vscode&lt;/code&gt;编程,无法弹出控制台,因此无法追踪光标位置,也就难以实现原地打印.因此,本程序中使用每 1s 打印一次棋盘的方式.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;贪吃蛇对象划分&#34;&gt;&lt;a href=&#34;#贪吃蛇对象划分&#34; class=&#34;headerlink&#34; title=&#34;贪吃蛇对象划分&#34;&gt;&lt;/a&gt;贪吃蛇对象划分&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;场地：周围用&lt;strong&gt;墙&lt;/strong&gt;环绕，里面有部分墙，&lt;strong&gt;食物&lt;/strong&gt;和&lt;strong&gt;蛇&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;游戏本身&lt;ul&gt;
&lt;li&gt;游戏分数：贪吃蛇吃到的食物数量&lt;/li&gt;
&lt;li&gt;游戏状态：用&lt;code&gt;true&lt;/code&gt;&amp;#x2F;&lt;code&gt;false&lt;/code&gt;表示是否结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;贪吃蛇对象设计&#34;&gt;&lt;a href=&#34;#贪吃蛇对象设计&#34; class=&#34;headerlink&#34; title=&#34;贪吃蛇对象设计&#34;&gt;&lt;/a&gt;贪吃蛇对象设计&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;场地：&lt;ul&gt;
&lt;li&gt;场地本身：使用一个二维数组表示，场地内的墙用&lt;code&gt;#&lt;/code&gt;表示，蛇用&lt;code&gt;S&lt;/code&gt;表示，食物用&lt;code&gt;$&lt;/code&gt;表示，普通平地用&amp;#96;&amp;#96;表示。某个单位只能出现一个物种，不可能同时出现两种。&lt;/li&gt;
&lt;li&gt;场地的长、宽：用&lt;code&gt;int&lt;/code&gt;类型表示&lt;/li&gt;
&lt;li&gt;蛇：使用一个结构体进行存储，其中几个字段分别为：&lt;ul&gt;
&lt;li&gt;整条蛇的位置信息：使用一个&lt;code&gt;std::deque&lt;/code&gt;存储，其中单个位置信息使用&lt;code&gt;std::pair&amp;lt;int,int&amp;gt;&lt;/code&gt;来存储&lt;/li&gt;
&lt;li&gt;蛇的运动方向：使用&lt;code&gt;int&lt;/code&gt;存储(使用一个枚举类型&lt;code&gt;INPUT_KEY&lt;/code&gt;，来表示对应的&lt;code&gt;int&lt;/code&gt;值)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;游戏：使用一个结构体进行存储，其中几个字段分别为：&lt;ul&gt;
&lt;li&gt;游戏分数：使用&lt;code&gt;int&lt;/code&gt;类型存储&lt;/li&gt;
&lt;li&gt;游戏状态：使用&lt;code&gt;true/false&lt;/code&gt;表示是否结束&lt;/li&gt;
&lt;li&gt;用户的名字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;游戏主逻辑设计&#34;&gt;&lt;a href=&#34;#游戏主逻辑设计&#34; class=&#34;headerlink&#34; title=&#34;游戏主逻辑设计&#34;&gt;&lt;/a&gt;游戏主逻辑设计&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;提示用户输入游戏场地规格：长，宽 &amp;#x2F; 默认（不输入）&lt;/li&gt;
&lt;li&gt;提示用户输入姓名&lt;/li&gt;
&lt;li&gt;初始化游戏场地&lt;/li&gt;
&lt;li&gt;初始化游戏分数和状态&lt;/li&gt;
&lt;li&gt;初始化默认开始方向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt;游戏没有结束&lt;ol&gt;
&lt;li&gt;获取用户方向输入&lt;/li&gt;
&lt;li&gt;如果没有输入方向，则按照上次的方向继续&lt;/li&gt;
&lt;li&gt;根据用户输入方向更新游戏状态&lt;/li&gt;
&lt;li&gt;打印棋盘&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;通知用户游戏结束，打印其姓名和分数，清理程序中所有的值&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;游戏状态更新逻辑&#34;&gt;&lt;a href=&#34;#游戏状态更新逻辑&#34; class=&#34;headerlink&#34; title=&#34;游戏状态更新逻辑&#34;&gt;&lt;/a&gt;游戏状态更新逻辑&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 根据蛇头，计算下一个位置的坐标
2. 如果场地中下个位置的值是`S`，判断其是否为蛇尾，如果不是蛇尾或者是墙，游戏结束
3. 如果下个位置是`$`，则(不去掉蛇尾):
   1. 游戏分数+1
4. 否则：
   1. 将场地蛇尾处`S`修改为&amp;#39; &amp;#39;
5. 将下一个位置加载蛇头
6. 将蛇头处&amp;#39; &amp;#39;修改为`S`
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;游戏对象定义-game-init-h&#34;&gt;&lt;a href=&#34;#游戏对象定义-game-init-h&#34; class=&#34;headerlink&#34; title=&#34;游戏对象定义(game_init.h)&#34;&gt;&lt;/a&gt;游戏对象定义(&lt;code&gt;game_init.h&lt;/code&gt;)&lt;/h1&gt;&lt;h2 id=&#34;蛇&#34;&gt;&lt;a href=&#34;#蛇&#34; class=&#34;headerlink&#34; title=&#34;蛇&#34;&gt;&lt;/a&gt;蛇&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;lt;deque&amp;gt;

// define the user input
enum INPUT_KEY
&amp;#123;
    RIGHT = 77,
    LEFT = 75,
    UP = 72,
    DOWN = 80,
&amp;#125;;

// define the snake
typedef struct
&amp;#123;
    INPUT_KEY direction;
    std::deque&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; position;
&amp;#125; snake;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;游戏&#34;&gt;&lt;a href=&#34;#游戏&#34; class=&#34;headerlink&#34; title=&#34;游戏&#34;&gt;&lt;/a&gt;游戏&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;// define the game
typedef struct
&amp;#123;
    int score;
    bool end;
    char *name;
&amp;#125; game;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;场地&#34;&gt;&lt;a href=&#34;#场地&#34; class=&#34;headerlink&#34; title=&#34;场地&#34;&gt;&lt;/a&gt;场地&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;// define the board
typedef struct
&amp;#123;
    char **arr;
    int width;
    int height;
    snake s;
&amp;#125; board;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;游戏对象初始化（game-init-c）&#34;&gt;&lt;a href=&#34;#游戏对象初始化（game-init-c）&#34; class=&#34;headerlink&#34; title=&#34;游戏对象初始化（game_init.c）&#34;&gt;&lt;/a&gt;游戏对象初始化（&lt;code&gt;game_init.c&lt;/code&gt;）&lt;/h1&gt;&lt;h2 id=&#34;游戏初始化&#34;&gt;&lt;a href=&#34;#游戏初始化&#34; class=&#34;headerlink&#34; title=&#34;游戏初始化&#34;&gt;&lt;/a&gt;游戏初始化&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/**
 * @brief Initialize the game
 *
 * @param g the game struct
 * @param name the name of the user
 */
void init_game(game &amp;amp;g, char *name)
&amp;#123;
    g.end = false;
    g.name = name;
    g.score = 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;场地初始化&#34;&gt;&lt;a href=&#34;#场地初始化&#34; class=&#34;headerlink&#34; title=&#34;场地初始化&#34;&gt;&lt;/a&gt;场地初始化&lt;/h2&gt;&lt;h3 id=&#34;初始化内容&#34;&gt;&lt;a href=&#34;#初始化内容&#34; class=&#34;headerlink&#34; title=&#34;初始化内容&#34;&gt;&lt;/a&gt;初始化内容&lt;/h3&gt;&lt;p&gt;场地的初始化包括初始化如下几个部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;场地：&lt;/li&gt;
&lt;li&gt;场地本身：使用一个二维数组表示，场地内的墙用&lt;code&gt;#&lt;/code&gt;表示，蛇用&lt;code&gt;S&lt;/code&gt;表示，食物用&lt;code&gt;$&lt;/code&gt;表示，普通平地用&amp;#96;&amp;#96;表示。某个单位只能出现一个物种，不可能同时出现两种。&lt;/li&gt;
&lt;li&gt;场地的长、宽：用&lt;code&gt;int&lt;/code&gt;类型表示&lt;/li&gt;
&lt;li&gt;蛇：使用一个结构体进行存储，其中几个字段分别为：&lt;ul&gt;
&lt;li&gt;整条蛇的位置信息：使用一个&lt;code&gt;std::deque&lt;/code&gt;存储，其中单个位置信息使用&lt;code&gt;std::pair&amp;lt;int,int&amp;gt;&lt;/code&gt;来存储&lt;/li&gt;
&lt;li&gt;蛇的运动方向：使用&lt;code&gt;int&lt;/code&gt;存储(使用一个枚举类型&lt;code&gt;INPUT_KEY&lt;/code&gt;，来表示对应的&lt;code&gt;int&lt;/code&gt;值)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;初始化步骤&#34;&gt;&lt;a href=&#34;#初始化步骤&#34; class=&#34;headerlink&#34; title=&#34;初始化步骤&#34;&gt;&lt;/a&gt;初始化步骤&lt;/h3&gt;&lt;p&gt;初始化的过程分为如下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化场地的长和宽&lt;/li&gt;
&lt;li&gt;初始化一个对应长和宽的二维数组，且其值为&amp;#96;&amp;#96;&lt;/li&gt;
&lt;li&gt;让二维数组的四周为&lt;code&gt;#&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用随机数生成器生成一个[1,min(height-2,width-2)]内随机的内部墙数量&lt;/li&gt;
&lt;li&gt;随机生成内部墙的坐标&lt;/li&gt;
&lt;li&gt;在对应位置处放置&lt;code&gt;#&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;随机生成食物的坐标&lt;/li&gt;
&lt;li&gt;在对应位置处放置&lt;code&gt;$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;随机生成蛇的坐标&lt;/li&gt;
&lt;li&gt;初始化蛇，方向向右&lt;/li&gt;
&lt;li&gt;在对应位置处放置&lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;辅助函数-1：随机数生成器&#34;&gt;&lt;a href=&#34;#辅助函数-1：随机数生成器&#34; class=&#34;headerlink&#34; title=&#34;辅助函数 1：随机数生成器&#34;&gt;&lt;/a&gt;辅助函数 1：随机数生成器&lt;/h3&gt;&lt;p&gt;C++ &lt;code&gt;std::rand()&lt;/code&gt; 函数生成一个 [0,&lt;code&gt;RAND_MAX&lt;/code&gt;) 之间的数字。如果我们想生成一个 [0,num] 范围内的数字，需要 &lt;code&gt;(1 + std::rand()) % num&lt;/code&gt;。如果&lt;code&gt;num&amp;lt;=0&lt;/code&gt;，我们不生成，直接返回 0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/**
 * @brief generate a random number between [1,num]
 *
 * @param num the maximum of the random number
 * @return int the random number generated
 */
int random(int num)
&amp;#123;
    if (num &amp;lt;= 0)
    &amp;#123;
        return 0;
    &amp;#125;
    return (1 + std::rand()) % num + 1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;辅助函数-2：place函数&#34;&gt;&lt;a href=&#34;#辅助函数-2：place函数&#34; class=&#34;headerlink&#34; title=&#34;辅助函数 2：place函数&#34;&gt;&lt;/a&gt;辅助函数 2：&lt;code&gt;place&lt;/code&gt;函数&lt;/h3&gt;&lt;p&gt;&lt;code&gt;food&lt;/code&gt;和&lt;code&gt;snake&lt;/code&gt;一次只放置 1 个。&lt;code&gt;food&lt;/code&gt;在初始化和每次被蛇吃掉后都需要重新放置（后期&lt;code&gt;update&lt;/code&gt;）中还需要调用，而&lt;code&gt;snake&lt;/code&gt;只有在初始化时候需要放置。因为其每次都是持续搜索，直到找到标记为&amp;#96;&amp;#96;的位置，因此我们写了一个&lt;code&gt;place&lt;/code&gt;函数用于放置内容。该函数返回一个&lt;code&gt;pair&lt;/code&gt;，用于&lt;code&gt;snake&lt;/code&gt;初始化时将坐标压到&lt;code&gt;deque&lt;/code&gt;中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/**
 * @brief the generic method to place some char in the board
 *
 * @param b board
 * @param p the character to be placed
 */
std::pair&amp;lt;int, int&amp;gt; place(board &amp;amp;b, char p)
&amp;#123;
    int xPos_max = b.height - 2;
    int yPos_max = b.width - 2;
    int x = random(xPos_max);
    int y = random(yPos_max);
    if (b.arr[x][y] != &amp;#39; &amp;#39;)
    &amp;#123;
        return place(b, p);
    &amp;#125;
    else
    &amp;#123;
        b.arr[x][y] = p;
        return std::make_pair(x, y);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;辅助函数-3：place-food-place-snake&#34;&gt;&lt;a href=&#34;#辅助函数-3：place-food-place-snake&#34; class=&#34;headerlink&#34; title=&#34;辅助函数 3：place_food &amp;amp; place_snake&#34;&gt;&lt;/a&gt;辅助函数 3：&lt;code&gt;place_food&lt;/code&gt; &amp;amp; &lt;code&gt;place_snake&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;place_food&lt;/code&gt;中，我们直接调用&lt;code&gt;place&lt;/code&gt;函数，将传入的&lt;code&gt;char&lt;/code&gt;设定为&lt;code&gt;$&lt;/code&gt;；而在&lt;code&gt;place_snake&lt;/code&gt;中，除了需要放置食物外，还需要将&lt;code&gt;place&lt;/code&gt;函数返回的坐标压到&lt;code&gt;deque&lt;/code&gt;中，并且初始化方向。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/**
 * @brief initialize the snake in the board
 *
 * @param b the game board
 */
void place_snake(board &amp;amp;b)
&amp;#123;
    std::pair&amp;lt;int, int&amp;gt; snake_pos = place(b, &amp;#39;S&amp;#39;);
    b.s.position.push_back(snake_pos);
    b.s.direction = RIGHT;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;辅助函数-4：print-board&#34;&gt;&lt;a href=&#34;#辅助函数-4：print-board&#34; class=&#34;headerlink&#34; title=&#34;辅助函数 4：print_board&#34;&gt;&lt;/a&gt;辅助函数 4：&lt;code&gt;print_board&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/**
 * @brief print the board of the game
 *
 * @param b the game board
 */
void print_board(board &amp;amp;b)
&amp;#123;
    int head_x = b.s.position[0].first;
    int head_y = b.s.position[0].second;
    for (int i = 0; i &amp;lt; b.height; i++)
    &amp;#123;
        for (int j = 0; j &amp;lt; b.width; j++)
        &amp;#123;
            if(i == head_x &amp;amp;&amp;amp; j == head_y) &amp;#123;
                std::cout &amp;lt;&amp;lt; &amp;quot;\033[0;31m&amp;quot; &amp;lt;&amp;lt; b.arr[i][j] &amp;lt;&amp;lt; &amp;quot;\033[0m&amp;quot; &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            &amp;#125;
            else&amp;#123;
                std::cout &amp;lt;&amp;lt; b.arr[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            &amp;#125;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; std::endl;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;初始化board&#34;&gt;&lt;a href=&#34;#初始化board&#34; class=&#34;headerlink&#34; title=&#34;初始化board&#34;&gt;&lt;/a&gt;初始化&lt;code&gt;board&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;该步骤遵循前文初始化步骤。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/**
 * @brief Initialize the board
 *
 * @param b the board struct
 * @param width the width of the board
 * @param height the height of the board
 */
void init_board(board &amp;amp;b, int width, int height)
&amp;#123;
    // init the width and height
    b.width = width;
    b.height = height;

    // init the board string and fill it with ` `
    b.arr = new char *[height];
    for (int i = 0; i &amp;lt; height; i++)
    &amp;#123;
        b.arr[i] = new char[width];
        std::fill(b.arr[i][0], b.arr[i][width - 1], &amp;#39; &amp;#39;);
    &amp;#125;

    // init the wall around the board
    std::fill(b.arr[0][0], b.arr[0][width - 1], &amp;#39;#&amp;#39;);
    for (int i = 1; i &amp;lt; height - 1; i++)
    &amp;#123;
        b.arr[i][0] = &amp;#39;#&amp;#39;;
        b.arr[i][width - 1] = &amp;#39;#&amp;#39;;
    &amp;#125;
    std::fill(b.arr[height - 1][0], b.arr[height - 1][width - 1], &amp;#39;#&amp;#39;);

    // calculate the scope of xPos and yPos
    int xPos_max = height - 2;
    int yPos_max = width - 2;

    // init the wall in inside the board
    int wall_num = random(std::min(height - 2, width - 2));
    for (int i = 0; i &amp;lt; wall_num; i++)
    &amp;#123;
        int x = random(xPos_max);
        int y = random(yPos_max);
        b.arr[x][y] = &amp;#39;#&amp;#39;;
    &amp;#125;

    // init the food
    place_food(b);

    // init the snake
    place_snake(b);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;游戏逻辑实现&#34;&gt;&lt;a href=&#34;#游戏逻辑实现&#34; class=&#34;headerlink&#34; title=&#34;游戏逻辑实现&#34;&gt;&lt;/a&gt;游戏逻辑实现&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;提示用户输入游戏场地规格：长，宽 &amp;#x2F; 默认（不输入）,如果长或宽小于 3,则提示用户重新输入&lt;/li&gt;
&lt;li&gt;提示用户输入姓名&lt;/li&gt;
&lt;li&gt;初始化游戏场地&lt;/li&gt;
&lt;li&gt;初始化游戏分数和状态&lt;/li&gt;
&lt;li&gt;初始化默认开始方向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt;游戏没有结束:&lt;/li&gt;
&lt;li&gt;获取用户方向输入&lt;/li&gt;
&lt;li&gt;如果没有输入方向，则按照上次的方向继续&lt;/li&gt;
&lt;li&gt;根据用户输入方向更新游戏状态&lt;/li&gt;
&lt;li&gt;通知用户游戏结束，打印其姓名和分数，清理程序中所有的值&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;    // the game loop
    while (!g.end)
    &amp;#123;
        if (_kbhit())
        &amp;#123;
            _getch();
            int key = _getch();
            b.s.direction = static_cast&amp;lt;INPUT_KEY&amp;gt;(key);
        &amp;#125;
        update(g, b);
        print_board(b);
        sleep(1);
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;游戏结束&#34;&gt;&lt;a href=&#34;#游戏结束&#34; class=&#34;headerlink&#34; title=&#34;游戏结束&#34;&gt;&lt;/a&gt;游戏结束&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;  // end the game
  std::cout &amp;lt;&amp;lt; &amp;quot;Game Over!&amp;quot; &amp;lt;&amp;lt; std::endl;
  std::cout &amp;lt;&amp;lt; &amp;quot;Your Score is: &amp;quot; &amp;lt;&amp;lt; g.score &amp;lt;&amp;lt; std::endl;

  // clear the game state
  delete[] name;
  for (int i = 0; i &amp;lt; b.height; i++)
  &amp;#123;
      delete[] b.arr[i];
  &amp;#125;
  delete[] b.arr;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;update函数更新游戏状态&#34;&gt;&lt;a href=&#34;#update函数更新游戏状态&#34; class=&#34;headerlink&#34; title=&#34;update函数更新游戏状态&#34;&gt;&lt;/a&gt;&lt;code&gt;update&lt;/code&gt;函数更新游戏状态&lt;/h1&gt;&lt;h2 id=&#34;步骤&#34;&gt;&lt;a href=&#34;#步骤&#34; class=&#34;headerlink&#34; title=&#34;步骤&#34;&gt;&lt;/a&gt;步骤&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. 根据蛇头，计算下一个位置的坐标
2. 如果场地中下个位置的值是`S`，判断其是否为蛇尾，如果不是蛇尾或者是墙，游戏结束
3. 如果下个位置是`$`，则(不去掉蛇尾):
   1. 游戏分数+1
4. 否则：
   1. 将场地蛇尾处`S`修改为&amp;#39; &amp;#39;
5. 将下一个位置加载蛇头
6. 将蛇头处&amp;#39; &amp;#39;修改为`S`
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;update函数&#34;&gt;&lt;a href=&#34;#update函数&#34; class=&#34;headerlink&#34; title=&#34;update函数&#34;&gt;&lt;/a&gt;&lt;code&gt;update&lt;/code&gt;函数&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;void update(game &amp;amp;g, board &amp;amp;b)
&amp;#123;
    // get the current snake head
    std::pair&amp;lt;int, int&amp;gt; head = b.s.position[0];
    int x = head.first;
    int y = head.second;

    // get the snake tail
    std::pair&amp;lt;int, int&amp;gt; tail = b.s.position.back();
    int tail_x = tail.first;
    int tail_y = tail.second;

    // obtain the next position
    switch (b.s.direction)
    &amp;#123;
    case UP:
        x -= 1;
        break;
    case DOWN:
        x += 1;
        break;
    case RIGHT:
        y += 1;
        break;
    case LEFT:
        y -= 1;
        break;
    default:
        break;
    &amp;#125;

    // if the next position is &amp;#39;#&amp;#39; or snake body, exit the game
    if (b.arr[x][y] == &amp;#39;#&amp;#39; || (b.arr[x][y] == &amp;#39;S&amp;#39; &amp;amp;&amp;amp; x != tail_x &amp;amp;&amp;amp; y != tail_y))
    &amp;#123;
        g.end = true;
        return;
    &amp;#125;

    // if the next poistion is food
    if (b.arr[x][y] == &amp;#39;$&amp;#39;)
    &amp;#123;
        g.score += 1;
    &amp;#125;
    else
    &amp;#123;
        b.arr[tail_x][tail_y] = &amp;#39; &amp;#39;;
        b.s.position.pop_back();
    &amp;#125;
    b.s.position.push_front(std::pair&amp;lt;int, int&amp;gt;(x, y));
    b.arr[x][y] = &amp;#39;S&amp;#39;;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;bug-修复&#34;&gt;&lt;a href=&#34;#bug-修复&#34; class=&#34;headerlink&#34; title=&#34;bug 修复&#34;&gt;&lt;/a&gt;bug 修复&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;random()&lt;/code&gt;随机数产生需要在后面 +1&lt;/li&gt;
&lt;li&gt;为&lt;code&gt;board&lt;/code&gt;新增&lt;code&gt;plain&lt;/code&gt;字段, 让蛇占据所有空间后,通知用户通关!&lt;/li&gt;
&lt;li&gt;长度为 1 时,可以反方向运动&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
    </channel>
</rss>
