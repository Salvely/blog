<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>望春风 • Posts by &#34;系统&#34; category</title>
        <link>https://salvely.github.io/blog</link>
        <description>计算机&amp;数理&amp;文学爱好者，喜欢健身、下厨、听音乐和看电影</description>
        <language>zh-CN</language>
        <pubDate>Mon, 05 Feb 2024 15:50:22 +0800</pubDate>
        <lastBuildDate>Mon, 05 Feb 2024 15:50:22 +0800</lastBuildDate>
        <category>C++</category>
        <category>Arch</category>
        <category>Linux</category>
        <category>安装教程</category>
        <category>操作系统</category>
        <category>notes</category>
        <category>配置教程</category>
        <category>Debian</category>
        <category>包管理</category>
        <category>参考资料</category>
        <category>CMake</category>
        <category>Makefile</category>
        <category>lab</category>
        <item>
            <guid isPermalink="true">https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</guid>
            <title>15213 Lab 1-data lab 实验总结</title>
            <link>https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</link>
            <category>lab</category>
            <pubDate>Mon, 05 Feb 2024 15:50:22 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;部分的题目我参考了一下网上的内容（出处已注明），其他的均为自己实现（有的题目的实现过程可能会有些繁琐），部分 dlc 检测出来可能会报些 error，但是 btest 均能过。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有 TA 可太难了！自己实现了一天多，终于苟完了。不算完美，但也能看吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;bitXor&#34;&gt;&lt;a href=&#34;#bitXor&#34; class=&#34;headerlink&#34; title=&#34;bitXor&#34;&gt;&lt;/a&gt;bitXor&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * bitXor - x^y using only ~ and &amp;amp;
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &amp;amp;
 *   Max ops: 14
 *   Rating: 1
 */
int bitXor(int x, int y)
&amp;#123;
   /**
    * x + y = ~( ~x &amp;amp; ~y)
    */
   return ~((~(x &amp;amp; ~y)) &amp;amp; (~(y &amp;amp; ~x)));
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bitXor 要求我们使用位操作来实现&lt;code&gt;^&lt;/code&gt;运算符。根据运算定律我们知道: &lt;code&gt;a ^ b = (a &amp;amp; (~b)) | (b &amp;amp; (~a))&lt;/code&gt;。但是问题来了，我们这里不允许使用&lt;code&gt;|&lt;/code&gt;，只能用&lt;code&gt;~&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;。那么我们就必须使用这两个操作符来实现&lt;code&gt;|&lt;/code&gt;运算。&lt;br&gt;通过德摩根定律我们知道：&lt;code&gt;a | b = ~((~a) &amp;amp; (~b))&lt;/code&gt;。这不就解决问题了嘛，所以将这两个式子综合一下，最后的结果是&lt;code&gt;~((~(x &amp;amp; ~y)) &amp;amp; (~(y &amp;amp; ~x)))&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;tmin&#34;&gt;&lt;a href=&#34;#tmin&#34; class=&#34;headerlink&#34; title=&#34;tmin&#34;&gt;&lt;/a&gt;tmin&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * tmin - return minimum two&amp;#39;s complement integer
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 4
 *   Rating: 1
 */
int tmin(void)
&amp;#123;
   /**
    * the most significant bit = 1, others = 0, so (1 &amp;lt;&amp;lt; 31)
    */
   return (1 &amp;lt;&amp;lt; 31);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题要求我们返回最小的补码整数，返回类型为&lt;code&gt;int&lt;/code&gt;。首先，在二进制补码表示中，最高位的权值为-1，其他位的权值为 1。因此，最小的补码整数 tmin 的最高位为 1，其他位为 0。而题目中&lt;code&gt;int&lt;/code&gt;类型为 32 位，因此只要返回&lt;code&gt;(1 &amp;lt;&amp;lt; 31)&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&#34;isTmax&#34;&gt;&lt;a href=&#34;#isTmax&#34; class=&#34;headerlink&#34; title=&#34;isTmax&#34;&gt;&lt;/a&gt;isTmax&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * isTmax - returns 1 if x is the maximum, two&amp;#39;s complement number,
 *     and 0 otherwise
 *   Legal ops: ! ~ &amp;amp; ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
int isTmax(int x)
&amp;#123;
   /**
    * Tmax ^ Tmin = 0xffffffff, ~0xffffffff = 0x0, !0x0 = 0x1
    */
   // return !(~(x ^ (1 &amp;lt;&amp;lt; 31)));

   /**
    * ~Tmax = Tmin -&amp;gt; ~Tmin + 1 = Tmin 且 Tmin != 0
    */
   int num = ~x;
   return !(num ^ (~num + 1)) &amp;amp; !!num;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tmax 是二进制补码中最大的数，通过分析这个数的特点，我们可以完成这道题目。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该数除了最高位是 0 外，其他位均是 1。因此该数和(1&amp;lt;&amp;lt;31)（也就是 tmin）的亦或（或者和）为&lt;code&gt;0xffffffff&lt;/code&gt;。&lt;code&gt;0xffffffff&lt;/code&gt;按位取反得到&lt;code&gt;0x0&lt;/code&gt;，而&lt;code&gt;0x0&lt;/code&gt;按位取反得到&lt;code&gt;0x1&lt;/code&gt;。但是其他的数并没有这个特性。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;return !(~(x ^ (1 &amp;lt;&amp;lt; 31)));
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;该数取反后得到 tmin，tmin 的一个特点是 tmin 和 -tmin 的表示相同。因此两者亦或得到 0。还有一个树也有这样的特性，也就是 0。因此我们需要排除 0 的可能性。我们使用&lt;code&gt;&amp;amp;&lt;/code&gt;操作符来实现两种特性的叠加。我本没有想到该方法，是从这篇&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=&#34;&gt;知乎帖子&lt;/span&gt;学习到的。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int num = ~x;
return !(num ^ (~num + 1)) &amp;amp; !!num;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是题目不允许在该题中使用移位运算符，因此只能使用方法二。&lt;/p&gt;
&lt;h2 id=&#34;allOddBits&#34;&gt;&lt;a href=&#34;#allOddBits&#34; class=&#34;headerlink&#34; title=&#34;allOddBits&#34;&gt;&lt;/a&gt;allOddBits&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 *   where bits are numbered from 0 (least significant) to 31 (most significant)
 *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 12
 *   Rating: 2
 */
int allOddBits(int x)
&amp;#123;
   /**
    * tear the number into 4 parts, get rid of the other digits except 0xaa
    * if the results are all the same, then compare it with 0xaa, if there are the same, xor returns 0
    * otherwise not all odd bits in word set is set to 1
    */
   int first = (x &amp;gt;&amp;gt; 24) &amp;amp; 0xaa;
   int second = (x &amp;gt;&amp;gt; 16) &amp;amp; 0xaa;
   int third = (x &amp;gt;&amp;gt; 8) &amp;amp; 0xaa;
   int fourth = x &amp;amp; 0xaa;
   return !((first &amp;amp; second &amp;amp; third &amp;amp; fourth) ^ 0xaa);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于单个字节的奇数位，我们可以使用&lt;code&gt;0xaa&lt;/code&gt;作为 mask。&lt;br&gt;本题目中我将位打成 4 个部分，每个部分与 mask 相与。如果每个奇数位都是 1 的话，四个部分的比较结果应该相同，都等于&lt;code&gt;0xaa&lt;/code&gt;，该值与&lt;code&gt;0xaa&lt;/code&gt;异或得到&lt;code&gt;0x0&lt;/code&gt;，取&lt;code&gt;!&lt;/code&gt;后得到&lt;code&gt;0x1&lt;/code&gt;。否则该值不为&lt;code&gt;0xaa&lt;/code&gt;，同&lt;code&gt;0xaa&lt;/code&gt;亦或得到其他非零值，取&lt;code&gt;!&lt;/code&gt;后得到&lt;code&gt;0x0&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;negate&#34;&gt;&lt;a href=&#34;#negate&#34; class=&#34;headerlink&#34; title=&#34;negate&#34;&gt;&lt;/a&gt;negate&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * negate - return -x
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 5
 *   Rating: 2
 */
int negate(int x)
&amp;#123;
   return (~x + 1);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该题目中我们需要求解某个数的相反数。在课堂中我们学过，一个数和它相反数的和为 0。那么如何获得其相反数呢？以&lt;code&gt;x&lt;/code&gt;为例，我们知道&lt;code&gt;x + ~x = ~0&lt;/code&gt;，也就是全 f，然后&lt;code&gt;~0 + 1 = 0&lt;/code&gt;。因此，&lt;code&gt;-x&lt;/code&gt;的补码表示即为&lt;code&gt;~x + 1&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;isAsciiDigit&#34;&gt;&lt;a href=&#34;#isAsciiDigit&#34; class=&#34;headerlink&#34; title=&#34;isAsciiDigit&#34;&gt;&lt;/a&gt;isAsciiDigit&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * isAsciiDigit - return 1 if 0x30 &amp;lt;= x &amp;lt;= 0x39 (ASCII codes for characters &amp;#39;0&amp;#39; to &amp;#39;9&amp;#39;)
 *   Example: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 15
 *   Rating: 3
 */
int isAsciiDigit(int x)
&amp;#123;
   /**
    * least = (x &amp;amp; 0xf) - 0xa
    * if least &amp;gt; 0 (with 0 in most significant bit) then least = 0
    * else least = 1
    */
   int least = ((((x &amp;amp; 0xf) + (~0xa + 1)) &amp;gt;&amp;gt; 31) &amp;amp; 0x1);
   int second = !((x &amp;gt;&amp;gt; 4) ^ 0x3);
   return least &amp;amp; second;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我使用的方法是将该数拆分为最低位和其他位来比较。我们将最低位与&lt;code&gt;0xa&lt;/code&gt;相减，如果求得的结果为负数，符号位即为 1，代表该值在 0-9 之间。接下来判断其他位是否为&lt;code&gt;0x3&lt;/code&gt;，如果是，则和&lt;code&gt;0x3&lt;/code&gt;异或结果为 0，通过逻辑&lt;code&gt;!&lt;/code&gt;返回 1。&lt;/p&gt;
&lt;h2 id=&#34;conditional&#34;&gt;&lt;a href=&#34;#conditional&#34; class=&#34;headerlink&#34; title=&#34;conditional&#34;&gt;&lt;/a&gt;conditional&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * conditional - same as x ? y : z
 *   Example: conditional(2,4,5) = 4
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 16
 *   Rating: 3
 */
int conditional(int x, int y, int z)
&amp;#123;
   /**
    * judge if x != 0, if true, !!x = 1, return y, otherwise !!x = 0, return z
    */

   // cond gets all f when !!x == 1
   int cond = ((!!x) &amp;lt;&amp;lt; 31) &amp;gt;&amp;gt; 31;
   return (cond &amp;amp; y) | (~cond &amp;amp; z);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们先获取&lt;code&gt;x&lt;/code&gt;的值，如果&lt;code&gt;x != 0&lt;/code&gt;，则&lt;code&gt;!!x = 0x1&lt;/code&gt;，否则为&lt;code&gt;0x0&lt;/code&gt;。扩展该值，当该值为&lt;code&gt;0x1&lt;/code&gt;时与&lt;code&gt;y&lt;/code&gt;相与得到 y。当该值为&lt;code&gt;0x0&lt;/code&gt;，取反后与 z 相与得到 z。因为这两个值只取其一，当一边不为 0 时另一边必然为 0，因此两边用&lt;code&gt;|&lt;/code&gt;连接。&lt;/p&gt;
&lt;h2 id=&#34;isLessOrEqual&#34;&gt;&lt;a href=&#34;#isLessOrEqual&#34; class=&#34;headerlink&#34; title=&#34;isLessOrEqual&#34;&gt;&lt;/a&gt;isLessOrEqual&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本题要求使用最多 24 个运算符，但是这里我使用的过多了，应该会有更好的办法。期待有人指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * isLessOrEqual - if x &amp;lt;= y  then return 1, else return 0
 *   Example: isLessOrEqual(4,5) = 1.
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 24
 *   Rating: 3
 */
int isLessOrEqual(int x, int y)
&amp;#123;
   // first compare their sign bit
   int sign_x = (x &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   int sign_y = (y &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   // return true if sign = 1(&amp;gt;0)
   int sign_diff = sign_x + (~sign_y + 1);
   int sign_bit = (sign_diff &amp;gt;&amp;gt; 31) &amp;amp; 0x1;

   // then compare the magnitude
   int mask = (~0) + (0x1 &amp;lt;&amp;lt; 31);
   int mag_x = x &amp;amp; mask;
   int mag_y = y &amp;amp; mask;
   int mag_diff = mag_x + (~mag_y + 1);
   int mag_sign = !(mag_x ^ mag_y) | ((mag_diff &amp;gt;&amp;gt; 31) &amp;amp; 0x1);

   /**
    * 2 conditions return true:
    * 1. sign of x = 1 and sign of y = 0
    * 2. sign of x and y equals, and magnitude of x &amp;lt;= y
    */
   return (((!sign_bit) &amp;amp; sign_diff) | ((!sign_diff) &amp;amp; mag_sign));
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里要分几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x 为负数，y 为正数，直接返回&lt;code&gt;0x1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;x 和 y 同符号，比较数值部分。x &amp;lt;&amp;#x3D; y 时，返回&lt;code&gt;0x1&lt;/code&gt;；x &amp;gt; y 时，返回&lt;code&gt;0x0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;x 为正数，y 为负数，返回&lt;code&gt;0x0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中&lt;code&gt;sign_diff&lt;/code&gt;为两数符号位之差，此处分三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x 为负数，符号位为 1；y 为正数，符号位为 0。那么两者符号位相减等于&lt;code&gt;0x1&lt;/code&gt;，该值的符号位为 0。（这是我们要返回&lt;code&gt;0x1&lt;/code&gt;的结果）&lt;/li&gt;
&lt;li&gt;x 为正数，符号位为 0；y 为负数，符号位为 1。那么两者符号位相减等于&lt;code&gt;0xffffffff&lt;/code&gt;(-1)，该值的符号位为 1。（我们不要这个结果）&lt;/li&gt;
&lt;li&gt;x 和 y 的符号位相同，两者相减为&lt;code&gt;0x0&lt;/code&gt;，该值的符号位为 0。（这里我们要看情况，看&lt;code&gt;x&lt;/code&gt;是否和&lt;code&gt;y&lt;/code&gt;相等）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码中&lt;code&gt;sign_diff&lt;/code&gt;为两符号位之差，&lt;code&gt;sign_bit&lt;/code&gt;为该做差结果的最高位。当 x 和 y 的符号位不相同时，当&lt;code&gt;sign_diff&lt;/code&gt;为&lt;code&gt;0x1&lt;/code&gt;且&lt;code&gt;sign_bit&lt;/code&gt;为&lt;code&gt;0x0&lt;/code&gt;是，我们返回&lt;code&gt;0x1&lt;/code&gt;。这也是运算结果&lt;code&gt;|&lt;/code&gt;左半边的由来。&lt;/p&gt;
&lt;p&gt;代码中&lt;code&gt;mag_diff&lt;/code&gt;为两者数值部分之差，&lt;code&gt;mag_sign&lt;/code&gt;为该差值的符号位。当&lt;code&gt;x &amp;lt; y&lt;/code&gt;时，&lt;code&gt;mag_diff&lt;/code&gt;为&lt;code&gt;0xffffffff&lt;/code&gt;。当&lt;code&gt;x == y&lt;/code&gt;时，&lt;code&gt;!(mag_x ^ mag_y)&lt;/code&gt;为&lt;code&gt;0x1&lt;/code&gt;。因此&lt;code&gt;mag_sign = !(mag_x ^ mag_y) | ((mag_diff &amp;gt;&amp;gt; 31) &amp;amp; 0x1)&lt;/code&gt;。在判断数值之差部分时，我们需要保证两数符号位之差为&lt;code&gt;0x0&lt;/code&gt;，而不是其他（如 x 正 y 负）。因此运算结果右半边的值为&lt;code&gt;(!sign_diff) &amp;amp; mag_sign&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;综上，最后的结果是&lt;code&gt;((!sign_bit) &amp;amp; sign_diff) | ((!sign_diff) &amp;amp; mag_sign)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;logicalNeg&#34;&gt;&lt;a href=&#34;#logicalNeg&#34; class=&#34;headerlink&#34; title=&#34;logicalNeg&#34;&gt;&lt;/a&gt;logicalNeg&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * logicalNeg - implement the ! operator, using all of
 *              the legal operators except !
 *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1
 *   Legal ops: ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 12
 *   Rating: 4
 */
int logicalNeg(int x)
&amp;#123;
   /**
    * if x == 0, x ^ 0x0 = 0
    */
   return ((x | (x + ~0 + (~(1 &amp;lt;&amp;lt; 31) + 1))) &amp;gt;&amp;gt; 31) + 1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这道题的难点在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 0 映射到 0x1&lt;/li&gt;
&lt;li&gt;将非 0 值映射到 0x0&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在一开始实现时，我的思路是对于 0，可以和&lt;code&gt;0x0&lt;/code&gt;异或，判断为 0。但是对于非 0 的数，和&lt;code&gt;0x0&lt;/code&gt;异或后还是他自己，我们也不知道 1 落在其中哪个位上，一个个位去找也不现实。那么就需要思考其他的办法。从&lt;code&gt;0x0&lt;/code&gt;这个数和其他数的特点下手。这里我参考了&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==&#34;&gt;这篇博客&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其给出的思路是：&lt;br&gt;-x 为 x 按位取反再+1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个数为全 0，和相反数相&lt;code&gt;|&lt;/code&gt;后结果全部是 0，加 1 后得到&lt;code&gt;0x1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则结果最高位必然含有 1。向右移动 31 位获得&lt;code&gt;~0&lt;/code&gt;，再加 1 得到&lt;code&gt;0x0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题可改为，如何判断一个数全为 0 。注意到，-x 相当于按位取反再加一，如果 x 为 非 0 数，那么 x|(-x) 后必定为 -1 。利用这个性质，即可判断是否为 0 。&lt;/p&gt;
&lt;h2 id=&#34;howManyBits&#34;&gt;&lt;a href=&#34;#howManyBits&#34; class=&#34;headerlink&#34; title=&#34;howManyBits&#34;&gt;&lt;/a&gt;howManyBits&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/* howManyBits - return the minimum number of bits required to represent x in
 *             two&amp;#39;s complement
 *  Examples: howManyBits(12) = 5
 *            howManyBits(298) = 10
 *            howManyBits(-5) = 4
 *            howManyBits(0)  = 1
 *            howManyBits(-1) = 1
 *            howManyBits(0x80000000) = 32
 *  Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *  Max ops: 90
 *  Rating: 4
 */
int howManyBits(int x)
&amp;#123;
   /**
    * divide and conquer
    * for positive number, the number of bits = the last position of 1 + 1
    * for negative number, the number of bits = the last position of 1
    * inverse negative number and deal with it as the same as positive number
    * 1. judge the sign bit of x, if x is negative, inverse it
    * 2. judge the high 16 bits, if true(high 16 bits != 0x0), result + 16
    * 3. judge the high 8 bits, if true, result + 8
    * 4. judge the high 4 bits, if true, result + 4
    * 5. judge the high 2 bits, if true, result + 2
    * 6. judge the high 1 bits, if true, result + 1
    * 7. judge the last 1 bit, if true, result + !!x
    * 8. the final sum must + 1
    * 9. return the result
    */
   // neg x if it&amp;#39;s negative
   int sign = ((x &amp;amp; (1 &amp;lt;&amp;lt; 31)) &amp;gt;&amp;gt; 31);
   x = (sign &amp;amp; ~x) | (~sign &amp;amp; x);

   int b16, b8, b4, b2, b1, b0;

   // int mask_16 = (1 &amp;lt;&amp;lt; 15) &amp;gt;&amp;gt; 15;
   b16 = !!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4;
   x = x &amp;gt;&amp;gt; b16;

   // int mask_8 = 0xff;
   b8 = !!(x &amp;gt;&amp;gt; 8) &amp;lt;&amp;lt; 3;
   x = x &amp;gt;&amp;gt; b8;

   // int mask_4 = 0xf;
   b4 = !!(x &amp;gt;&amp;gt; 4) &amp;lt;&amp;lt; 2;
   x = x &amp;gt;&amp;gt; b4;

   // int mask_2 = 0x3;
   b2 = !!(x &amp;gt;&amp;gt; 2) &amp;lt;&amp;lt; 1;
   x = x &amp;gt;&amp;gt; b2;

   // int mask_1 = 0x1;
   b1 = !!(x &amp;gt;&amp;gt; 1);
   x = x &amp;gt;&amp;gt; b1;

   //! judge if the last bit == 1
   b0 = !!x;

   return b16 + b8 + b4 + b2 + b1 + b0 + 1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个题目中，我们主要采用分而治之的方法。分治方法的几道例题可以参考 CMU 15-213 课程的&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MvYWNhZGVtaWMvY2xhc3MvMTUyMTMtZjIzL3d3dy9yZWNpdGF0aW9ucy9yZWMwMV9zb2x1dGlvbnMucGRm&#34;&gt;Recitation Slides&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;首先，我们可以看到，如果该数是一个正数，则其最高位必然是 0，该数的位数 &amp;#x3D; 最高一个 1 的位置 + 1；&lt;br&gt;如果该数是一个负数，该数的位数 &amp;#x3D; 最高一个 1 的位置。&lt;br&gt;我们不想那么麻烦，把正负数分开讨论，因此我们把负数翻转过来。&lt;/p&gt;
&lt;p&gt;在这道题中我们采用的方法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断高 16 位是否有 1（把数向右移动 16 位后，结果不为 0，&lt;code&gt;!!(x &amp;gt;&amp;gt; 16)&lt;/code&gt;）。&lt;code&gt;b16 = !!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4&lt;/code&gt;。如果是的话，把数值向右移动 16 位&lt;code&gt;(x&amp;gt;&amp;gt;b16)&lt;/code&gt;。把&lt;code&gt;b16&lt;/code&gt;添加到结果中去。这里一个妙用在于如果&lt;code&gt;!!(x &amp;gt;&amp;gt; 16）= 0x1&lt;/code&gt;，&lt;code&gt;!!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4&lt;/code&gt;可以直接起到获得数字 16 的方法，无需增加其他的运算。&lt;/li&gt;
&lt;li&gt;判断高 8 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断高 4 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断高 2 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断高 1 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断该位是否有 1&lt;/li&gt;
&lt;li&gt;结果 + 1（位数 &amp;#x3D; 最高一个 1 的位置 + 1）&lt;/li&gt;
&lt;li&gt;最后把所有判断结果加起来（每次判断的结果都是一个累加的位数，加在一起就是最后的总位数）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;浮点数复习&#34;&gt;&lt;a href=&#34;#浮点数复习&#34; class=&#34;headerlink&#34; title=&#34;浮点数复习&#34;&gt;&lt;/a&gt;浮点数复习&lt;/h2&gt;&lt;p&gt;在完成浮点数部分的题目之前，我们需要复习一下浮点数的和其表示方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单精度浮点数：1 位符号位 + 8 位阶码(exp) + 11 位尾数(frac)&lt;/li&gt;
&lt;li&gt;双精度浮点数：1 位符号位 + 11 位阶码(exp) + 52 位尾数(frac)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中阶码使用移码表示。$bias &amp;#x3D; 2^{k-1}-1$&lt;/p&gt;
&lt;p&gt;浮点数分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规格化数：阶码不全为 1 也不全为 0，尾数前有隐含的 1，指数$E&amp;#x3D;exp - bias$，分布在非规格化数外侧&lt;/li&gt;
&lt;li&gt;非规格化数：阶码全为 0，尾数前隐含 0，指数$E&amp;#x3D;1 - bias$，主要分布在靠近 0 侧&lt;/li&gt;
&lt;li&gt;特殊值：阶码全为 1，若尾数全为 0，则为&lt;code&gt;inf&lt;/code&gt;，否则为&lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;floatScale2&#34;&gt;&lt;a href=&#34;#floatScale2&#34; class=&#34;headerlink&#34; title=&#34;floatScale2&#34;&gt;&lt;/a&gt;floatScale2&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;// float
/*
 * floatScale2 - Return bit-level equivalent of expression 2*f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int&amp;#39;s, but
 *   they are to be interpreted as the bit-level representation of
 *   single-precision floating point values.
 *   When argument is NaN, return argument
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;amp;&amp;amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned floatScale2(unsigned uf)
&amp;#123;
   // first get the sign, exp and mag bit of the number
   unsigned sign = (uf &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   unsigned e = (uf &amp;gt;&amp;gt; 23) &amp;amp; ((1 &amp;lt;&amp;lt; 8) - 1);
   unsigned f = (uf &amp;amp; ((1 &amp;lt;&amp;lt; 23) - 1));

   if (e == 0)
   &amp;#123;
      // denormalized number
      // E = 1 - bias
      // frac = f

      //! how to multiply a denormalized number? frac * 2!
      f = f * 2;
   &amp;#125;
   else if (e == 0xff)
   &amp;#123;
      // special number
      // if frac = 0, then value = inf
      if (f == 0)
      &amp;#123;
         // frac = 1 / 0;
         return uf;
      &amp;#125;
      else
      &amp;#123;
         // if frac != 0, value = NaN
         return uf;
      &amp;#125;
   &amp;#125;
   else
   &amp;#123;
      // normalized number
      // E = e - bias
      // value = 1 + f

      e += 1;
      if (e == ~0)
      &amp;#123;
         return uf;
      &amp;#125;
   &amp;#125;

   return (sign &amp;lt;&amp;lt; 31) | (e &amp;lt;&amp;lt; 23) | f;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题目要求是计算一个 unsigned 形式表示的浮点数 &lt;code&gt;* 2&lt;/code&gt; 后的表示。在完成这题之前，我们首先把浮点数的几个部分提取出来，分几个情况讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非规格化数：指数不变，尾数乘 2。&lt;strong&gt;问题来了，这到底是为什么？因为当exp全为0时，exp &amp;#x3D; 0, E &amp;#x3D; 1 - bias, frac &amp;#x3D; 0.f。乘以2就相当于把f左移一位，最高位会进到exp的位置去。如果f最高位是0，左移一位不影响exp（全0）。如果f最高位是1，左移一位后该数变为规格化数，exp变为1，E依然等于 1 - bias。实现了非规格化数到规格化数的平滑过渡（非常重要！）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;规格化数：首先将指数 + 1，然后判断是否为特殊值，若是则返回&lt;code&gt;uf&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;特殊值：&lt;code&gt;e = 0&lt;/code&gt;，直接返回&lt;code&gt;uf&lt;/code&gt;（根据题目意思）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将符号位，指数和尾数三个部分拼凑起来，直接返回（本题中无需进行任何计算）。&lt;/p&gt;
&lt;h2 id=&#34;floatFloat2Int&#34;&gt;&lt;a href=&#34;#floatFloat2Int&#34; class=&#34;headerlink&#34; title=&#34;floatFloat2Int&#34;&gt;&lt;/a&gt;floatFloat2Int&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本题中不允许使用&lt;code&gt;double&lt;/code&gt;类型，我擅自用了，这里应该是不严谨的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * floatFloat2Int - Return bit-level equivalent of expression (int) f
 *   for floating point argument f.
 *   Argument is passed as unsigned int, but
 *   it is to be interpreted as the bit-level representation of a
 *   single-precision floating point value.
 *   Anything out of range (including NaN and infinity) should return
 *   0x80000000u.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;amp;&amp;amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
int floatFloat2Int(unsigned uf)
&amp;#123;
   // first get the sign, exp and mag bit of the number
   unsigned sign = (uf &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   unsigned e = (uf &amp;gt;&amp;gt; 23) &amp;amp; ((1 &amp;lt;&amp;lt; 8) - 1);
   float f = (uf &amp;amp; ((1 &amp;lt;&amp;lt; 23) - 1)) / (1 &amp;lt;&amp;lt; 23);

   // then get the exact sign, E and value of the number
   int s = 0;
   if (sign == 0)
      s = 1;
   else
      s = -1;

   int E = 0;
   float frac = 0;
   int bias = 127;
   if (e == 0)
   &amp;#123;
      // denormalized number
      // E = 1 - bias
      E = 1 - bias;
      // frac = f
      frac = f;
   &amp;#125;
   else if (e == 0xff)
   &amp;#123;
      //! COMPARE WITH 0XFF INSTEAD OF ~0
      // special number
      // if frac = 0, then value = inf
      if (f == 0)
      &amp;#123;
         // frac = 1 / 0;
         return 0x80000000u;
      &amp;#125;
      else
      &amp;#123;
         // if frac != 0, value = NaN
         return 0x80000000u;
      &amp;#125;
   &amp;#125;
   else
   &amp;#123;
      // normalized number
      // E = e - bias
      E = e - bias;
      // value = 1 + f
      frac = 1 + f;
   &amp;#125;
   if (E &amp;lt; 0)
   &amp;#123;
      return 0;
   &amp;#125;
   else if (E &amp;gt; 31)
   &amp;#123;
      //! REMEMBER THE SITUATION THAT E &amp;gt; 31
      return 0x80000000u;
   &amp;#125;

   return s * frac * (1 &amp;lt;&amp;lt; E);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题需要返回浮点数转化后的 int 类型数值。需要我们对浮点数的结构有所了解，并且其转化为 int 后需要切割掉小数部分，此外，我们还需要判断指数过大的情况（溢出）。&lt;/p&gt;
&lt;p&gt;本题中我们采用的步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提取出浮点数三个部分，计算符号位的值&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;e == 0&lt;/code&gt;时，为特殊值的情况，&lt;code&gt;E = 1 - bias&lt;/code&gt;，&lt;code&gt;frac = f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;e == 0xff&lt;/code&gt;时（注意不是&lt;code&gt;~0/0xffffffff&lt;/code&gt;,容易写错！），返回&lt;code&gt;0x80000000u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以上两种情况都不是，则该数为规格化数，&lt;code&gt;E = e - bias; frac = 1 + f;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，我们需要进行&lt;strong&gt;特殊情况的分类讨论&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;E &amp;lt; 0, 则最后生成的结果（无论规格化还是非规格化）肯定是个小数，打头的是 0 那种，要切割为&lt;code&gt;int&lt;/code&gt;类型，小数部分就被切割掉了&lt;/li&gt;
&lt;li&gt;E &amp;gt; 31, 超过了指数可以表示的范围（算是溢出了？），返回&lt;code&gt;0x80000000u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正常情况下返回&lt;code&gt;s * frac * (1 &amp;lt;&amp;lt; E)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;floatPower2&#34;&gt;&lt;a href=&#34;#floatPower2&#34; class=&#34;headerlink&#34; title=&#34;floatPower2&#34;&gt;&lt;/a&gt;floatPower2&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * floatPower2 - Return bit-level equivalent of the expression 2.0^x
 *   (2.0 raised to the power x) for any 32-bit integer x.
 *
 *   The unsigned value that is returned should have the identical bit
 *   representation as the single-precision floating-point number 2.0^x.
 *   If the result is too small to be represented as a denorm, return
 *   0. If too large, return +INF.
 *
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;amp;&amp;amp;. Also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned floatPower2(int x)
&amp;#123;
   //! REMEMEBER THAT FLOATING POINT ITSELF IS IN THE FORMAT (-1)^S * M * 2.0^E
   // fit x into E
   x = x + 127;
   //! MIND THE SITUATION THAT X IS TOO LARGE OR TOO SMALL
   if (x &amp;gt;= 0xff)
      x = 0xff;
   else if (x &amp;lt;= 0)
      x = 0;
   unsigned result = (x &amp;lt;&amp;lt; 23);
   return result;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为浮点数表示法本身就是以 2 为底，所以本实验就相当于如何把 x 转化为那个 8 位的阶码。因为&lt;code&gt;阶码 = 指数 + bias&lt;/code&gt;，这里&lt;code&gt;bias = 127&lt;/code&gt;，因此这里&lt;code&gt;E = x + 127&lt;/code&gt;。然后和上一题一样，我们需要判断一下 x 的范围是否在&lt;code&gt;0xff&lt;/code&gt;和&lt;code&gt;0&lt;/code&gt;之间。最后将 x 移动到阶码的位置返回(&lt;code&gt;return x &amp;lt;&amp;lt; 23&lt;/code&gt;)即可。&lt;/p&gt;
&lt;h2 id=&#34;参考实现&#34;&gt;&lt;a href=&#34;#参考实现&#34; class=&#34;headerlink&#34; title=&#34;参考实现&#34;&gt;&lt;/a&gt;参考实现&lt;/h2&gt;&lt;p&gt;在完成 data lab 过程中，我参考了部分如下几个博客的实现:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=&#34;&gt;CSAPP 实验一：DataLab 详细讲解与满分代码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NDk4Nzc0NzU=&#34;&gt;lab1 CSAPP：datalab&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTc0ODExMTI=&#34;&gt;CSAPP lab1: datalab&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==&#34;&gt;深入理解计算机系统之位操作实验&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://salvely.github.io/blog/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_Project/</guid>
            <title>Final Project: 多线程HTTP服务器 实现记录</title>
            <link>https://salvely.github.io/blog/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_Project/</link>
            <pubDate>Mon, 08 Jan 2024 10:32:56 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;进入课程网页的时候意外发现这个 Project 的代码已经被填完了。所以没什么好做的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;Overview&#34;&gt;&lt;a href=&#34;#Overview&#34; class=&#34;headerlink&#34; title=&#34;Overview&#34;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;多线程网络服务器大致功能：简单的搜索和文件浏览&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Part A: 实现服务器读取文件，统计文件中的单词个数&lt;/li&gt;
&lt;li&gt;Part B: 实现网络连接和 HTTP 请求响应&lt;/li&gt;
&lt;li&gt;Part C: 将 A 和 B 两部分结合起来&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-A&#34;&gt;&lt;a href=&#34;#Part-A&#34; class=&#34;headerlink&#34; title=&#34;Part A&#34;&gt;&lt;/a&gt;Part A&lt;/h2&gt;&lt;h3 id=&#34;FileReader-cc&#34;&gt;&lt;a href=&#34;#FileReader-cc&#34; class=&#34;headerlink&#34; title=&#34;FileReader.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;FileReader.cc&lt;/code&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;简单的文件阅读器&lt;/li&gt;
&lt;li&gt;在构建时读入文件名，&lt;code&gt;read_file&lt;/code&gt;将整个文件读入一个&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;POSIX&lt;/code&gt;, C 接口或者 C++文件流实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;WordIndex-h-WordIndex-cc&#34;&gt;&lt;a href=&#34;#WordIndex-h-WordIndex-cc&#34; class=&#34;headerlink&#34; title=&#34;WordIndex.h &amp;amp; WordIndex.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;WordIndex.h &amp;amp; WordIndex.cc&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;实现一个数据结构，用于存储各个文件中的单词及其出现次数&lt;/p&gt;
&lt;h3 id=&#34;CrawlFileTree-cc&#34;&gt;&lt;a href=&#34;#CrawlFileTree-cc&#34; class=&#34;headerlink&#34; title=&#34;CrawlFileTree.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;CrawlFileTree.cc&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;实现&lt;code&gt;HandleFile&lt;/code&gt;函数，其获取一个文件名和一个&lt;code&gt;WordIndex&lt;/code&gt;，这个函数读取对应文件，并且将每个单词及其对应的个数存储在&lt;code&gt;WordIndex&lt;/code&gt;中&lt;/p&gt;
&lt;h2 id=&#34;Part-B&#34;&gt;&lt;a href=&#34;#Part-B&#34; class=&#34;headerlink&#34; title=&#34;Part B&#34;&gt;&lt;/a&gt;Part B&lt;/h2&gt;&lt;h3 id=&#34;ServerSocket-cc&#34;&gt;&lt;a href=&#34;#ServerSocket-cc&#34; class=&#34;headerlink&#34; title=&#34;ServerSocket.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;ServerSocket.cc&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;实现一个类，这个类包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个服务器端的监听 socket&lt;/li&gt;
&lt;li&gt;从客户端接受新的连接请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServerSocket.h&lt;/code&gt;中提供了头文件，需要在&lt;code&gt;ServerSocket.cc&lt;/code&gt;中实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;HttpConnection-cc&#34;&gt;&lt;a href=&#34;#HttpConnection-cc&#34; class=&#34;headerlink&#34; title=&#34;HttpConnection.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;HttpConnection.cc&lt;/code&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HttpConnection&lt;/code&gt;处理&lt;code&gt;HTTP&lt;/code&gt;连接请求，将该请求转化为一个对象，并且负责将响应写回去&lt;/li&gt;
&lt;li&gt;该函数中主要实现&lt;code&gt;HTTP&lt;/code&gt;请求的读取和解析(string 操作)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;HttpUtils-cc&#34;&gt;&lt;a href=&#34;#HttpUtils-cc&#34; class=&#34;headerlink&#34; title=&#34;HttpUtils.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;HttpUtils.cc&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;主要负责一些其他功能，尤其是安全方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;escape_html&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;用于防止&lt;code&gt;cross-site scripting&lt;/code&gt;，参考&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Dcm9zcy1zaXRlX3NjcmlwdGluZw==&#34;&gt;Cross-site scripting&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;in_path_safe&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;保证使用该服务器的人只能获取到对应目录下的文件，其他目录下对他不开放权限&lt;/li&gt;
&lt;li&gt;否则可能会有攻击者使用&lt;code&gt;directory traverse attack&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-C&#34;&gt;&lt;a href=&#34;#Part-C&#34; class=&#34;headerlink&#34; title=&#34;Part C&#34;&gt;&lt;/a&gt;Part C&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HttpServer_ThrFn&lt;/code&gt;函数实现&lt;ul&gt;
&lt;li&gt;每个线程可以获取到一个连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两个&lt;code&gt;helper_function&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;分别处理两种类型的请求&lt;ul&gt;
&lt;li&gt;对查看文件的请求(&lt;code&gt;ProcessFileRequest&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;执行查询的请求(&lt;code&gt;ProcessQueryRequest&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;htttp&lt;/code&gt;测试&lt;code&gt;Http Server&lt;/code&gt;。输入命令&lt;code&gt;./httpd 3000 ./test_tree/&lt;/code&gt;，在显示&lt;code&gt;accepting connections...&lt;/code&gt;后，点击下方的&lt;code&gt;Open Server on port 3000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现步骤&#34;&gt;&lt;a href=&#34;#实现步骤&#34; class=&#34;headerlink&#34; title=&#34;实现步骤&#34;&gt;&lt;/a&gt;实现步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FileReader::read_file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WordIndex.cc &amp;amp; WordIndex.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CrawlFileTree.cc handle_file函数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServerSocket.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get_request &amp;amp; parse_request from HttpConnection.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;write_response in HttpConnection.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HttpUtils.cc&lt;/code&gt;两个函数实现&lt;/li&gt;
&lt;li&gt;test_suite 通过&lt;/li&gt;
&lt;li&gt;valgrind 通过&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HttpServer.cc&lt;/code&gt;实现并测试&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实现提示&#34;&gt;&lt;a href=&#34;#实现提示&#34; class=&#34;headerlink&#34; title=&#34;实现提示&#34;&gt;&lt;/a&gt;实现提示&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost&lt;/code&gt;库中的&lt;code&gt;split()/trim()/replace_all()&lt;/code&gt;函数可以使用，使用&lt;code&gt;split()&lt;/code&gt;时可以使用&lt;code&gt;is_any_of()/isalpha()/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;ServerSocket.cc&lt;/code&gt;时，留意&lt;code&gt;server_accept_rw_close&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有个小函数可以让&lt;code&gt;is_path_safe&lt;/code&gt;的实现更简单(留意&lt;code&gt;HttpUtils.cc&lt;/code&gt;中的注释，自己上网学习它的用法)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FileReader&lt;/code&gt;需要处理只含有 0 个字节的&lt;code&gt;binary_files&lt;/code&gt;，这里可以使用传入 2 个参数的&lt;code&gt;string&lt;/code&gt;构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;测试&#34;&gt;&lt;a href=&#34;#测试&#34; class=&#34;headerlink&#34; title=&#34;测试&#34;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;make
./test_suite
valgrind ./test_suite
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://salvely.github.io/blog/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW4/</guid>
            <title>HW4: Shell &amp; Pipe 实现记录</title>
            <link>https://salvely.github.io/blog/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW4/</link>
            <pubDate>Sat, 06 Jan 2024 14:49:15 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;要求&#34;&gt;&lt;a href=&#34;#要求&#34; class=&#34;headerlink&#34; title=&#34;要求&#34;&gt;&lt;/a&gt;要求&lt;/h1&gt;&lt;p&gt;实现一个只含有基本命令和 Pipe(不含重定向符及其他符号)的 Shell。&lt;/p&gt;
&lt;h1 id=&#34;指南&#34;&gt;&lt;a href=&#34;#指南&#34; class=&#34;headerlink&#34; title=&#34;指南&#34;&gt;&lt;/a&gt;指南&lt;/h1&gt;&lt;h2 id=&#34;相关文件&#34;&gt;&lt;a href=&#34;#相关文件&#34; class=&#34;headerlink&#34; title=&#34;相关文件&#34;&gt;&lt;/a&gt;相关文件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pipe_shell.cc&lt;/code&gt;:在其中实现 shell 程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sh.cc&lt;/code&gt;: 传入一个附带参数的程序，&lt;code&gt;fork()&lt;/code&gt;子程序然后&lt;code&gt;execvp()&lt;/code&gt;去执行它&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdin_echo.cc&lt;/code&gt;: 从&lt;code&gt;stdin&lt;/code&gt;中读取，输出读取的内容，直到获取&lt;code&gt;EOF&lt;/code&gt;，然后停止&lt;/li&gt;
&lt;li&gt;&lt;code&gt;example_tests/&lt;/code&gt;: 其中含有示例输入和对应输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;solution_binaries/&lt;/code&gt;: 官方答案执行码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;具体要求&#34;&gt;&lt;a href=&#34;#具体要求&#34; class=&#34;headerlink&#34; title=&#34;具体要求&#34;&gt;&lt;/a&gt;具体要求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序一次从标准输入读取一行命令&lt;/li&gt;
&lt;li&gt;一行命令包括命令本身和连接他们的 Pipe&lt;/li&gt;
&lt;li&gt;不停读入直到读入&lt;code&gt;EOF&lt;/code&gt;&amp;#x2F;用户输入&lt;code&gt;exit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在当前命令完成之后才能运行下一条命令&lt;/li&gt;
&lt;li&gt;命令可以是绝对路径或者是程序名（用&lt;code&gt;execvp&lt;/code&gt;执行）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;建议方法&#34;&gt;&lt;a href=&#34;#建议方法&#34; class=&#34;headerlink&#34; title=&#34;建议方法&#34;&gt;&lt;/a&gt;建议方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通读该指南和提供的源代码，搞清楚作业是在做什么&lt;/li&gt;
&lt;li&gt;执行一下&lt;code&gt;./solution_binaries/pipe_shell&lt;/code&gt;，看看结果长什么样&lt;/li&gt;
&lt;li&gt;开始实现&lt;code&gt;pipe_shell.cc&lt;/code&gt;，从循环提示用户输入开始，并且打印&lt;code&gt;$&lt;/code&gt;提示符，直到无输入或者遇到&lt;code&gt;EOF&lt;/code&gt;&amp;#x2F;输入&lt;code&gt;exit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;fork()&lt;/code&gt;，&lt;code&gt;pipe&lt;/code&gt;连接和命令的执行(&lt;code&gt;execvp&lt;/code&gt;或者直接运行命令路径)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现提示&#34;&gt;&lt;a href=&#34;#实现提示&#34; class=&#34;headerlink&#34; title=&#34;实现提示&#34;&gt;&lt;/a&gt;实现提示&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以使用&lt;code&gt;boost&lt;/code&gt;库中的&lt;code&gt;split()&lt;/code&gt;和&lt;code&gt;trim()&lt;/code&gt;方法，&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;execvp(), fork(), pipe(), waitpid()&lt;/code&gt;等函数&lt;/li&gt;
&lt;li&gt;注意不同情形：无管道，一个管道，多于一个管道&lt;/li&gt;
&lt;li&gt;两种方法&lt;ul&gt;
&lt;li&gt;使用一个 pipe 数组&lt;/li&gt;
&lt;li&gt;每次&lt;code&gt;fork()&lt;/code&gt;之前创建一个&lt;code&gt;pipe&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个子进程只需要两个端口，从上一个进程送来的读端口，和给下一个子进程的写端口&lt;/li&gt;
&lt;li&gt;子进程用完端口之后关闭端口，否则程序无法正常退出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;测试&#34;&gt;&lt;a href=&#34;#测试&#34; class=&#34;headerlink&#34; title=&#34;测试&#34;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普通测试: &lt;code&gt;make &amp;amp;&amp;amp; ./pipe_shell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内存泄漏测试: &lt;code&gt;valgrind --leak-check=full ./pipe_shell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;比较自己的程序和&lt;code&gt;solution_binaries/pipe_shell&lt;/code&gt;的结果：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;cat ./tests/simple_input.txt | ./pipe_shell &amp;amp;&amp;gt; my_output.txt
diff my_output.txt ./tests/simple_output.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pipe-shell-cc&#34;&gt;&lt;a href=&#34;#pipe-shell-cc&#34; class=&#34;headerlink&#34; title=&#34;pipe_shell.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;pipe_shell.cc&lt;/code&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;实现核心：&lt;code&gt;pipe&lt;/code&gt;的内存在操作系统内核中。在每次循环前创建一个&lt;code&gt;pipe&lt;/code&gt;，然后&lt;code&gt;fork()&lt;/code&gt;一个子进程读取上一个&lt;code&gt;pipe&lt;/code&gt;的内容，写入当前这个&lt;code&gt;pipe&lt;/code&gt;。使用完毕后关闭这个&lt;code&gt;pipe&lt;/code&gt;的写端，保留这个&lt;code&gt;pipe&lt;/code&gt;的读端口。进而让下一次&lt;code&gt;dup2&lt;/code&gt;导入时使用，使用完后可关闭该&lt;code&gt;pipe&lt;/code&gt;的读端口。&lt;code&gt;pipe&lt;/code&gt;不会像本地变量那样随着循环的进行而消失，只要保存一下读&amp;#x2F;写端口，在下一轮循环中就可以正常的进行读写。&lt;br&gt;此外，我们使用&lt;code&gt;dup2&lt;/code&gt;来进行端口的重定向。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;lt;unistd.h&amp;gt;    // for fork()
#include &amp;lt;sys/types.h&amp;gt; // for pid_t
#include &amp;lt;sys/wait.h&amp;gt;  // for wait(), waitpid(), etc.

#include &amp;lt;cstdlib&amp;gt; // for exit(), EXIT_SUCCESS, and EXIT_FAILURE
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;boost/algorithm/string.hpp&amp;gt;

using namespace std;

#define BUF_SIZ 1000

int main()
&amp;#123;
    string s;
    cout &amp;lt;&amp;lt; &amp;quot;$ &amp;quot;;
    while (getline(std::cin, s))
    &amp;#123;
        if (s == &amp;quot;exit&amp;quot;)
        &amp;#123;
            return EXIT_SUCCESS;
        &amp;#125;

        int fd[2];
        int in_fd = 0; // input fd

        // split the command into multiple parts
        vector&amp;lt;string&amp;gt; tokens;
        boost::algorithm::split(tokens, s, boost::is_any_of(&amp;quot;|&amp;quot;), boost::token_compress_on);

        int count = 1;
        int command_num = tokens.size();

        for (auto &amp;amp;command : tokens)
        &amp;#123;
            // initialize a pipe
            if (pipe(fd) == -1)
            &amp;#123;
                perror(&amp;quot;pipe creation failed!&amp;quot;);
                return EXIT_FAILURE;
            &amp;#125;

            // prepare to run the current command

            // get the current command
            boost::algorithm::trim(command);
            // split the command into an array of args
            vector&amp;lt;string&amp;gt; args;
            boost::algorithm::split(args, command, boost::is_any_of(&amp;quot; &amp;quot;), boost::token_compress_on);
            int argc = args.size();
            if (argc &amp;lt; 1)
            &amp;#123;
                cerr &amp;lt;&amp;lt; &amp;quot;We need a command!&amp;quot; &amp;lt;&amp;lt; endl;
                return EXIT_FAILURE;
            &amp;#125;

            // run the current command
            pid_t child = fork();
            if (child == 0)
            &amp;#123;
                // setup the file name and input arguments
                const char *filename = args[0].c_str();
                char **argv = new char *[argc + 1];
                for (int i = 0; i &amp;lt; argc; i++)
                &amp;#123;
                    string args_str = args[i];
                    argv[i] = new char[10];
                    strcpy(argv[i], args_str.c_str());
                &amp;#125;
                argv[argc] = nullptr;

                if (in_fd != 0)
                &amp;#123;
                    // write the pipe value into stdin
                    dup2(in_fd, STDIN_FILENO);
                    close(in_fd);
                &amp;#125;

                if (count != command_num)
                &amp;#123;
                    // write stdout to the pipe
                    dup2(fd[1], STDOUT_FILENO);
                    close(fd[1]);
                &amp;#125;

                // use execvp() to run the commmand
                execvp(filename, argv);

                // exec didn&amp;#39;t work, so an error must have been occurred
                cerr &amp;lt;&amp;lt; strerror(errno) &amp;lt;&amp;lt; endl;
                delete[] argv;
                return EXIT_FAILURE;
            &amp;#125;

            // wait for the child process to complete
            int status;
            waitpid(child, &amp;amp;status, 0);

            // close the current pipe write fd
            close(fd[1]);
            in_fd = fd[0];
            count += 1;
        &amp;#125;

        // // read out the pipe
        // char buffer[BUF_SIZ];
        // int count = read(in_fd, buffer, BUF_SIZ);
        // buffer[count] = &amp;#39;\0&amp;#39;;
        // if (count &amp;gt; 0)
        // &amp;#123;
        //     fprintf(stdout, &amp;quot;%s&amp;quot;, buffer);
        // &amp;#125;
        close(in_fd);

        cout &amp;lt;&amp;lt; &amp;quot;$ &amp;quot;;
    &amp;#125;
    return EXIT_SUCCESS;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://salvely.github.io/blog/2024/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW3/</guid>
            <title>HW3: LRU SimpleVM 实现记录</title>
            <link>https://salvely.github.io/blog/2024/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW3/</link>
            <pubDate>Thu, 04 Jan 2024 13:27:01 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Overview&#34;&gt;&lt;a href=&#34;#Overview&#34; class=&#34;headerlink&#34; title=&#34;Overview&#34;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;本作业要求实现:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Page 对象：&lt;ul&gt;
&lt;li&gt;若 Page 不在 memory 中，那么它的数据被存储在磁盘上的&lt;code&gt;swap file&lt;/code&gt;部分。在&lt;code&gt;swap file&lt;/code&gt;中，每一页都有对应的顺序存储的数据。&lt;/li&gt;
&lt;li&gt;可以使用 C++ &lt;code&gt;fstream&lt;/code&gt;类进行 I&amp;#x2F;O 读写。尤其是&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PageTable 对象&lt;ul&gt;
&lt;li&gt;包含多个 page 以及&lt;code&gt;swap file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这里主要要求实现 LRU 算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;相关文件&#34;&gt;&lt;a href=&#34;#相关文件&#34; class=&#34;headerlink&#34; title=&#34;相关文件&#34;&gt;&lt;/a&gt;相关文件&lt;/h1&gt;&lt;h2 id=&#34;Page&#34;&gt;&lt;a href=&#34;#Page&#34; class=&#34;headerlink&#34; title=&#34;Page&#34;&gt;&lt;/a&gt;Page&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Page.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Page.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PageTemplates.cc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;PageTable&#34;&gt;&lt;a href=&#34;#PageTable&#34; class=&#34;headerlink&#34; title=&#34;PageTable&#34;&gt;&lt;/a&gt;PageTable&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PageTable.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PageTable.cc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Testing&#34;&gt;&lt;a href=&#34;#Testing&#34; class=&#34;headerlink&#34; title=&#34;Testing&#34;&gt;&lt;/a&gt;Testing&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test_page.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test_pagetable.cc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;实现提示&#34;&gt;&lt;a href=&#34;#实现提示&#34; class=&#34;headerlink&#34; title=&#34;实现提示&#34;&gt;&lt;/a&gt;实现提示&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;map, unordered_map, list, vector 结构都很有用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fstream&lt;/code&gt;中的&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;很有用&lt;/li&gt;
&lt;li&gt;需要将&lt;code&gt;uint8_t&lt;/code&gt;切换到&lt;code&gt;char&lt;/code&gt;类型来使用&lt;code&gt;fstream&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;利用初始化列表来初始化引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Page实现&#34;&gt;&lt;a href=&#34;#Page实现&#34; class=&#34;headerlink&#34; title=&#34;Page实现&#34;&gt;&lt;/a&gt;Page实现&lt;/h1&gt;&lt;h2 id=&#34;Page-源码分析&#34;&gt;&lt;a href=&#34;#Page-源码分析&#34; class=&#34;headerlink&#34; title=&#34;Page 源码分析&#34;&gt;&lt;/a&gt;Page 源码分析&lt;/h2&gt;&lt;p&gt;&lt;code&gt;simplevm namespace&lt;/code&gt;中存在一个类&lt;code&gt;Page&lt;/code&gt;，此外还有一个&lt;code&gt;uint32_t&lt;/code&gt;类型(&lt;code&gt;pno_t&lt;/code&gt;类型)的变量，用来表示页号。&lt;code&gt;Page&lt;/code&gt;页的解释如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页对象存在-&amp;gt;页被导入到 physical memory-&amp;gt;创建一个&lt;code&gt;page&lt;/code&gt;，并且从&lt;code&gt;swap_file&lt;/code&gt;中读&lt;code&gt;page&lt;/code&gt;数据。页的数据从&lt;code&gt;virtual_pno * Page::PAGE_SIZE&lt;/code&gt;开始&lt;/li&gt;
&lt;li&gt;页对象不存在-&amp;gt;数据存储在&lt;code&gt;swap_file&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;用户可以&lt;ul&gt;
&lt;li&gt;获取数据&lt;/li&gt;
&lt;li&gt;存储数据&lt;/li&gt;
&lt;li&gt;将数据刷新到&lt;code&gt;swap file&lt;/code&gt;中（多余的无法放入 physical memory 的虚拟内存所存储的地方）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Page&lt;/code&gt;类中包含如下&lt;code&gt;public&lt;/code&gt;方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Page(fstream&amp;amp; swap_file, pno_t virtual_pno);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;构造函数，传入该&lt;code&gt;page&lt;/code&gt;对应的&lt;code&gt;swap_file&lt;/code&gt;和页号&lt;/li&gt;
&lt;li&gt;我们从&lt;code&gt;swap_file&lt;/code&gt;读入页数据，刷新时将页数据写入&lt;code&gt;swap_file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;页号规定了我们在&lt;code&gt;swap_file&lt;/code&gt;的哪里写入数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Page(const Page&amp;amp; other);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;利用一个页来复制构造另一个页，两个页具有相同的页号和&lt;code&gt;swap_file&lt;/code&gt;地址，但是数据是复制了的（不是引用）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~Page()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;清理声明的变量&lt;/li&gt;
&lt;li&gt;如果当前数据为 dirty 状态，那么将其刷新到对应的&lt;code&gt;swap_file&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Page&amp;amp; operator=(const Page&amp;amp; rhs)&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;赋值函数，同复制构造函数，两个&lt;code&gt;Page&lt;/code&gt;具有相同的&lt;code&gt;swap_file&lt;/code&gt;和页号，但是&lt;code&gt;data&lt;/code&gt;是被复制了的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt; T access(uint32_t virtual_address);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;获取该页面的值（需要考虑错误情况）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T store(uint32_t virtual address, const T&amp;amp; to_write)&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;存储值到该页面中去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool operator&amp;lt;(const Page&amp;amp; rhs);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;比较两个页面顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pno_t pno();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;获取该页面的页号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool dirty();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 是否为 dirty 状态(如果有人在 flush 之后，向该 page 写过值就是 dirty)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void flush();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如果该 page 是 dirty 状态，就把内容刷新到&lt;code&gt;swap_file&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;变量：&lt;code&gt;static constexpr size_t PAGE_SIZE = 4096U;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Page 中还包括如下&lt;code&gt;private&lt;/code&gt;变量:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fstream&amp;amp; swap_file_;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;注意这里是个引用，一个 page 没有对&lt;code&gt;swap_file&lt;/code&gt;的所有权，只能 access 到它，所以这里&lt;code&gt;swap_file&lt;/code&gt;是个引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pno_t virtual_pno_;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 的页号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uint8_t *bytes_;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 的字节内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool dirty_;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 是否在 flush 后被写入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Page-设计&#34;&gt;&lt;a href=&#34;#Page-设计&#34; class=&#34;headerlink&#34; title=&#34;Page 设计&#34;&gt;&lt;/a&gt;Page 设计&lt;/h2&gt;&lt;h2 id=&#34;PageTemplates-cc实现&#34;&gt;&lt;a href=&#34;#PageTemplates-cc实现&#34; class=&#34;headerlink&#34; title=&#34;PageTemplates.cc实现&#34;&gt;&lt;/a&gt;&lt;code&gt;PageTemplates.cc&lt;/code&gt;实现&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PageTemplates.cc&lt;/code&gt;在&lt;code&gt;simplevm namespace&lt;/code&gt;中。源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;
namespace simplevm &amp;#123;
  // TODO: implement all template member functions for Page

  // This function allows users to read various data types
  // from the page. Trying to read a non-primitive type or use
  // a virtual address that doesn&amp;#39;t map to this page results
  // in undefined behaviour. You can also assume that
  // anything being read fits in on the page we are reading
  // is not partially on another page.
  // If you are familiar with endianness, it shouldn&amp;#39;t be
  // considered for this function.
  //
  // Arguments:
  //   - virtual_address: a virtual address that maps somewhere
  //     into the page, where we will read data of type T
  //
  // Returns:
  //   - the data of type T that was read from the page
  template &amp;lt;typename T&amp;gt;
  T Page::access(uint32_t virtual_address) &amp;#123;
    if(virtual_address / PAGE_SIZE != virtual_pno_)
        return 0;
    virtual_address = virtual_address % PAGE_SIZE;
    T* address = (T*)(bytes_ + virtual_address);
    return *address;
  &amp;#125;

  // This function allows users to write various data types
  // to the page. Trying to write a non-primitive type or use
  // a virtual address that doesn&amp;#39;t map to this page results
  // in undefined behaviour. You can also assume that
  // anything being written fits on the current page
  // is not partially on another page.
  // If you are familiar with endianness, it shouldn&amp;#39;t be
  // considered for this function.
  //
  // Arguments:
  //   - virtual_address: a virtual address that maps somewhere
  //     into the page, where we will read data of type T
  //   - to_write: the data of type T to write to the page
  //
  // Returns: nothing

  template &amp;lt;typename T&amp;gt;
  void Page::store(uint32_t virtual_address, const T&amp;amp; to_write) &amp;#123;
    if(virtual_address / PAGE_SIZE != virtual_pno_)
        return;
    virtual_address = virtual_address % PAGE_SIZE;
    T* address = (T*)(bytes_ + virtual_address);
    *address = to_write;
    dirty_ = true;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Page-h定义&#34;&gt;&lt;a href=&#34;#Page-h定义&#34; class=&#34;headerlink&#34; title=&#34;Page.h定义&#34;&gt;&lt;/a&gt;&lt;code&gt;Page.h&lt;/code&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Page.h&lt;/code&gt;在&lt;code&gt;simplevm namespace&lt;/code&gt;中。源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#ifndef PAGE_H_
#define PAGE_H_

#include &amp;lt;cstdint&amp;gt;
#include &amp;lt;fstream&amp;gt;

using std::fstream;

namespace simplevm &amp;#123;

// defines the type pno_t, which is the type
// that represents a page number
typedef uint32_t pno_t;

///////////////////////////////////////////////////////////////////////////////
// A Page is a class that represents a page of memory
// in our simple virtual memory model.
// If a page object exists, then we say that the page is loaded
// into physical memory. When the page object doesn&amp;#39;t exist, then its
// data is stored in the swap_file. When we load in a page to
// &amp;quot;physical memory&amp;quot;, we are creating the page and we read the page&amp;#39;s data
// from the swap file. A page&amp;#39;s data in the swap file starts at
// virtual_pno * Page::PAGE_SIZE
//
// This Class manages a page&amp;#39;s worth of data
// Users can access or store data, sa well as flush the data in the
// page to the specified swap file. A swap file is where exceess virtual
// memory is stored when it can&amp;#39;t fit in physical memory.
///////////////////////////////////////////////////////////////////////////////
class Page &amp;#123;
 public:
  // Constructs a new Page object associated
  // with a swap_file and a virtual page number.
  // The swap file is where we will load in the page
  // contents and flush the page contents. The virtual
  // page number decides where in that file we read
  // and write this page.
  // Passing in an invalid page number is undefined behaviour
  // Note that a Page does not have ownership
  // of the swap_file_, just access to it.
  //
  // Arguments:
  //  - swap_file the swap_file associated with the page
  //  - the virtual page number of our new page
  Page(fstream&amp;amp; swap_file, pno_t virtual_pno);

  // Constructs a new Page object that is a copy of
  // another page object. Both pages will have
  // the same page number and swap_file, but should
  // have independent copies of the page data.
  //
  // Misc: this means that there could be issues with
  // having the original and copy page having differnt
  // data. This cctor should only really be used
  // in the context of managing pages with something
  // like STL, where the original page used for the cctor
  // will be discarded. In real C++, we would want to
  // use move semantics here.
  //
  // Arguements:
  //   - other: the page we are copying
  Page(const Page&amp;amp; other);

  // Destructor for the page object
  // Cleans up any dynamically allocated data or
  // otherwise allocated resources AND should flush
  // its contents if the page is dirty at time of
  // destruction.
  ~Page();

  // Set the current Page object so that is a copy of
  // another page object. Both pages will have
  // the same page number and swap_file, but should
  // have independent copies of the page data.
  //
  // Misc: this means that there could be issues with
  // having the original and copy page having differnt
  // data. This op= should only really be used
  // in the context of managing pages with something
  // like STL, where the original page used for the cctor
  // will be discarded. In real C++, we would want to
  // use move semantics here.
  //
  // You can assume each page has the same swap_file.
  //
  // Arguements:
  //   - rhs: the page we are copying
  Page&amp;amp; operator=(const Page&amp;amp; rhs);

  // This function is not required, but you may add it
  // if it is needed for some of the STL containers
  // you use in PageTable
  //
  // Determines if this page should go before another page if they
  // were in sorted order.
  //
  // Arguments:
  //   - rhs: the Page we are comparing this to
  //
  // Returns: true iff this page would show up before the other
  // page in sorted order. False otherwise.
  bool operator&amp;lt;(const Page&amp;amp; rhs);

  // This function allows users to read various data types
  // from the page. Trying to read a non-primitive type or use
  // a virtual address that doesn&amp;#39;t map to this page results
  // in undefined behaviour. You can also assume that
  // anything being read fits in on the page we are reading
  // is not partially on another page.
  // If you are familiar with endianness, it shouldn&amp;#39;t be
  // considered for this function.
  //
  // Arguments:
  //   - virtual_address: a virtual address that maps somewhere
  //     into the page, where we will read data of type T
  //
  // Returns:
  //   - the data of type T that was read from the page
  template &amp;lt;typename T&amp;gt;
  T access(uint32_t virtual_address);

  // This function allows users to write various data types
  // to the page. Trying to write a non-primitive type or use
  // a virtual address that doesn&amp;#39;t map to this page results
  // in undefined behaviour. You can also assume that
  // anything being written fits on the current page
  // is not partially on another page.
  // If you are familiar with endianness, it shouldn&amp;#39;t be
  // considered for this function.
  //
  // Arguments:
  //   - virtual_address: a virtual address that maps somewhere
  //     into the page, where we will read data of type T
  //   - to_write: the data of type T to write to the page
  //
  // Returns: nothing
  template &amp;lt;typename T&amp;gt;
  void store(uint32_t virtual_address, const T&amp;amp; to_write);

  // Returns the virtual page number of this page
  //
  // Arguments: None
  //
  // Returns: this page&amp;#39;s virtual page number
  pno_t pno();

  // Returns whether or not a page is dirty
  // A page is &amp;quot;dirty&amp;quot; if someone has written to the data managed
  // by the page since the last time the page was flush()&amp;#39;d.
  //
  // Arguments: None
  //
  // Returns: Whether this page is dirty or not
  bool dirty();

  // Flushes the page to the swap file if it is dirty.
  // Flushing a page to the swap file involves writing
  // the page at the the spot correspoding to its page number
  // in the swap_file. For a description of what it means
  // for a page to be dirty, see the dirty() member function.
  // The page should not be written if it is not dirty.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void flush();

  // The amount of memory a page represents
  static constexpr size_t PAGE_SIZE = 4096U;

 private:
  // The file we will be reading/writing to
  // Note how this is a reference
  //
  // also note that a Page does not have ownership
  // of the swap_file_, just access to it.
  fstream&amp;amp; swap_file_;

  // the virtual page number
  pno_t virtual_pno_;

  // The bytes of the page. One byte is 8 bits
  // so we use 8-bit unsigned integers.
  // You can also assume that a &amp;#39;char&amp;#39; is one byte big
  uint8_t *bytes_;

  // Whether the page is dirty or not
  bool dirty_;
&amp;#125;;

&amp;#125;

// since we have template code
#include &amp;quot;./PageTemplates.cc&amp;quot;

#endif  // PAGE_H_
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Page-cc实现&#34;&gt;&lt;a href=&#34;#Page-cc实现&#34; class=&#34;headerlink&#34; title=&#34;Page.cc实现&#34;&gt;&lt;/a&gt;&lt;code&gt;Page.cc&lt;/code&gt;实现&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Page.cc&lt;/code&gt;在&lt;code&gt;simplevm namespace&lt;/code&gt;中。源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;quot;./Page.h&amp;quot;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

namespace simplevm &amp;#123;
  // TODO: implement all non template member functions for Page
    // Constructs a new Page object associated
  // with a swap_file and a virtual page number.
  // The swap file is where we will load in the page
  // contents and flush the page contents. The virtual
  // page number decides where in that file we read
  // and write this page.
  // Passing in an invalid page number is undefined behaviour
  // Note that a Page does not have ownership
  // of the swap_file_, just access to it.
  //
  // Arguments:
  //  - swap_file the swap_file associated with the page
  //  - the virtual page number of our new page
  Page::Page(fstream&amp;amp; swap_file, pno_t virtual_pno):swap_file_(swap_file) &amp;#123;
    this-&amp;gt;virtual_pno_ = virtual_pno;
    this-&amp;gt;bytes_ = new uint8_t[PAGE_SIZE];
    // seek the correct position
    swap_file_.seekg(virtual_pno_ * PAGE_SIZE, std::ios::beg);
    // read from the swap file
    swap_file_.read((char*)bytes_,PAGE_SIZE);
    if(!swap_file_) &amp;#123;
        std::cerr &amp;lt;&amp;lt; &amp;quot;Swap file read failed!&amp;quot; &amp;lt;&amp;lt; std::endl;
        exit(1);
    &amp;#125;
    this-&amp;gt;dirty_ = false;
  &amp;#125;

  // Constructs a new Page object that is a copy of
  // another page object. Both pages will have
  // the same page number and swap_file, but should
  // have independent copies of the page data.
  //
  // Misc: this means that there could be issues with
  // having the original and copy page having differnt
  // data. This cctor should only really be used
  // in the context of managing pages with something
  // like STL, where the original page used for the cctor
  // will be discarded. In real C++, we would want to
  // use move semantics here.
  //
  // Arguements:
  //   - other: the page we are copying
  Page::Page(const Page&amp;amp; other):swap_file_(other.swap_file_) &amp;#123;
    this-&amp;gt;virtual_pno_ = other.virtual_pno_;
    this-&amp;gt;bytes_ = new uint8_t[PAGE_SIZE];
    memcpy(this-&amp;gt;bytes_,other.bytes_,PAGE_SIZE);
    this-&amp;gt;dirty_ = other.dirty_;
  &amp;#125;

  // Destructor for the page object
  // Cleans up any dynamically allocated data or
  // otherwise allocated resources AND should flush
  // its contents if the page is dirty at time of
  // destruction.
  Page::~Page() &amp;#123;
    if(dirty_) &amp;#123;
        flush();
    &amp;#125;
    dirty_ = false;
    delete[] bytes_;
  &amp;#125;

  // Set the current Page object so that is a copy of
  // another page object. Both pages will have
  // the same page number and swap_file, but should
  // have independent copies of the page data.
  //
  // Misc: this means that there could be issues with
  // having the original and copy page having differnt
  // data. This op= should only really be used
  // in the context of managing pages with something
  // like STL, where the original page used for the cctor
  // will be discarded. In real C++, we would want to
  // use move semantics here.
  //
  // You can assume each page has the same swap_file.
  //
  // Arguements:
  //   - rhs: the page we are copying
  Page&amp;amp; Page::operator=(const Page&amp;amp; rhs) &amp;#123;
    if (this!=&amp;amp;rhs)
    &amp;#123;
        this-&amp;gt;~Page();
        new (this)Page(rhs);
    &amp;#125;

    return *this;
  &amp;#125;

  // This function is not required, but you may add it
  // if it is needed for some of the STL containers
  // you use in PageTable
  //
  // Determines if this page should go before another page if they
  // were in sorted order.
  //
  // Arguments:
  //   - rhs: the Page we are comparing this to
  //
  // Returns: true iff this page would show up before the other
  // page in sorted order. False otherwise.
  bool Page::operator&amp;lt;(const Page&amp;amp; rhs) &amp;#123;
    return this-&amp;gt;virtual_pno_ &amp;lt; rhs.virtual_pno_;
  &amp;#125;

  // Returns the virtual page number of this page
  //
  // Arguments: None
  //
  // Returns: this page&amp;#39;s virtual page number
  pno_t Page::pno() &amp;#123;
    return this-&amp;gt;virtual_pno_;
  &amp;#125;

  // Returns whether or not a page is dirty
  // A page is &amp;quot;dirty&amp;quot; if someone has written to the data managed
  // by the page since the last time the page was flush()&amp;#39;d.
  //
  // Arguments: None
  //
  // Returns: Whether this page is dirty or not
  bool Page::dirty() &amp;#123;
    return this-&amp;gt;dirty_;
  &amp;#125;

  // Flushes the page to the swap file if it is dirty.
  // Flushing a page to the swap file involves writing
  // the page at the the spot correspoding to its page number
  // in the swap_file. For a description of what it means
  // for a page to be dirty, see the dirty() member function.
  // The page should not be written if it is not dirty.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void Page::flush() &amp;#123;
    if(dirty()) &amp;#123;
        // seek the correct position
        swap_file_.seekg(virtual_pno_ * PAGE_SIZE,std::ios::beg);
        // write to the swap file
        swap_file_.write((char*)bytes_,PAGE_SIZE);
        if(!swap_file_) &amp;#123;
            std::cerr &amp;lt;&amp;lt; &amp;quot;Swap file write failed!&amp;quot; &amp;lt;&amp;lt; std::endl;
            exit(1);
        &amp;#125;
        dirty_ = false;
    &amp;#125;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;PageTable实现&#34;&gt;&lt;a href=&#34;#PageTable实现&#34; class=&#34;headerlink&#34; title=&#34;PageTable实现&#34;&gt;&lt;/a&gt;PageTable实现&lt;/h1&gt;&lt;h2 id=&#34;PageTable-源码分析&#34;&gt;&lt;a href=&#34;#PageTable-源码分析&#34; class=&#34;headerlink&#34; title=&#34;PageTable 源码分析&#34;&gt;&lt;/a&gt;PageTable 源码分析&lt;/h2&gt;&lt;p&gt;PageTable 的作用如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理一个进程的地址空间&lt;/li&gt;
&lt;li&gt;包括&lt;code&gt;swap_file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从 physical memory 中读取页&lt;/li&gt;
&lt;li&gt;选择页淘汰，进行页替换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;PageTable.cc&lt;/code&gt;中有如下一些方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PageTable(std::string swap_file_name, size_t page_capacity);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;初始化页表，制定&lt;code&gt;swap_file&lt;/code&gt;名称和页容量&lt;/li&gt;
&lt;li&gt;存储的页不可超过页容量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~PageTable();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;清理所有变量&lt;/li&gt;
&lt;li&gt;flush dirty pages&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Page&amp;amp; get_page(uint32_t virtual_address);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;返回一个虚拟地址对应的 page&lt;/li&gt;
&lt;li&gt;将该页导入 physical memory&lt;/li&gt;
&lt;li&gt;返回它&lt;/li&gt;
&lt;li&gt;有几种可能情况&lt;ul&gt;
&lt;li&gt;该页在 Physical memory 中，返回对应的页的引用，并且将该页标记为最新（挪到 vector 最前）&lt;/li&gt;
&lt;li&gt;该页不在 physical memory 中，并且 physical memory 还没满。那么将其导入 physical memory，并且标记为最新（挪到 vector 最前），返回该页引用&lt;/li&gt;
&lt;li&gt;该页不在 Physical memory 中，并且 physical memory 已经满了，那么先执行淘汰算法，淘汰最老的页，将其写入&lt;code&gt;swap_file&lt;/code&gt;。然后将该页从&lt;code&gt;swap_file&lt;/code&gt;中导入进来，放在 vector 最前&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：&lt;ul&gt;
&lt;li&gt;virtual address !&amp;#x3D; 页号，可能有多个 virtual address 对应同一个页号(一页有 4096 个字节嘛)&lt;/li&gt;
&lt;li&gt;页的最新和最老完全取决于&lt;code&gt;get_page&lt;/code&gt;函数的调用情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t capacity();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;返回页容量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t loaded_pages();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;返回导入 physical memory 的页数目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool page_available(pno_t virtual_pno);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;返回对应页是否存在 physical memory 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void flush_all_pages();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;将所有页都刷新到&lt;code&gt;swap_file&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void flush_page(pno_t virtual_pno);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;将对应的页刷新到&lt;code&gt;swap_file&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void discard_page(pno_t virtual_pno);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;从页表中丢弃对应的页。如果该页不存在，则返回。否则，若该页为 dirty，则将该页数据写入&lt;code&gt;swap_file&lt;/code&gt;，然后丢弃它&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void evict_page();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;若没有 page 在页表中，则什么也不做。否则丢弃最老的一页（丢弃前记得将其写入&lt;code&gt;swap_file&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;PageTable.cc&lt;/code&gt;有两个&lt;code&gt;private&lt;/code&gt;变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fstream swap_file_&lt;/code&gt;: 交换文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t capacity&lt;/code&gt;: 页容量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t page_num&lt;/code&gt;: 当前已经导入 physical memory 的页数目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::vector&amp;lt;Page*&amp;gt; page_list&lt;/code&gt;: 记录所有在 physical memory 中的页&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::unordered_map&amp;lt;pno_t,Page*&amp;gt; mp&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;PageTable-h设计&#34;&gt;&lt;a href=&#34;#PageTable-h设计&#34; class=&#34;headerlink&#34; title=&#34;PageTable.h设计&#34;&gt;&lt;/a&gt;&lt;code&gt;PageTable.h&lt;/code&gt;设计&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#ifndef PAGE_TABLE_H_
#define PAGE_TABLE_H_

#include &amp;lt;fstream&amp;gt;
#include &amp;lt;cstdint&amp;gt;
// #include &amp;lt;vector&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;list&amp;gt;

#include &amp;quot;./Page.h&amp;quot;

using std::fstream;

namespace simplevm &amp;#123;

///////////////////////////////////////////////////////////////////////////////
// A PageTable manages a processes memeory for our simplified
// virtual memory model. This involves managing a swap_file
// which is where pages of data are stored when they aren&amp;#39;t loaded
// into physical memory. For our software model, we will say a page
// is in &amp;quot;physical memory&amp;quot; if it is loaded into our memory space
// (e.g. it is on the heap). Pages that aren&amp;#39;t loaded in will have
// their contents stored in the swap_file and will not have an
// associated Page object (see Page.h). Our page table can only have
// so many pages stored in memory at one time, which is specified
// on PageTable Creation. We implement an LRU page replacement
// policy to decide which pages to evict if we need to load a new page
// and we already have reached our capacity on the numberof pages we can
// hold.
//
// Users can get a page from the cache, flush pages to the swap_file,
// request any page is evicted, and specifically ask for a page to be evicted.
///////////////////////////////////////////////////////////////////////////////
class PageTable &amp;#123;
 public:
  // Constructs a new page table with the specified
  // swap file and the specified page capacity, which is
  // the number of pages that can be held in memory
  // at one time. There cannot be more than page_capacity
  // number of pages loaded in at a time.
  //
  // Arguments:
  //   - swap_file_name: the name of the swap_file
  //   - page_capacity: the maximum number of pages that can be held
  //     in memory at one time.
  PageTable(std::string swap_file_name, size_t page_capacity);

  // Destructs the page table, freeing any allocated resources
  // and flushing any pages currently loaded into memory that
  // are dirty
  ~PageTable();

  // Given a virtual address, gets the associated
  // page for that virtual address. This page will
  // be &amp;quot;loaded&amp;quot; into physical memory by the time it
  // is returned.
  //
  // There are three possiblities when a page is requested:
  // 1. The page is currently in the &amp;quot;loaded&amp;quot; and in the cache.
  //    In this case, a reference to the page is returned and
  //    and the page is marked as most recently used in the cache
  // 2. The page is not currently &amp;quot;loaded&amp;quot;, and the PageTable
  //    has not reached its page capacity:
  //    In this case, the page is loaded from the swap file and added
  //    to the cache as the most recently used page.
  // 3. The page is not currently &amp;quot;loaded&amp;quot;, and the PageTable
  //    is at page capacity:
  //    The least recently used page in the cache is evicted from the
  //    cache. Afterwards the requested page is loaded from the swap file
  //    and added to the cache as the most recently used page.
  //
  // NOTE: What decides how recntly used a page was used is entirely
  // decided by how recntly it was returned by a call to get_page.
  //
  // Arguments:
  //   - virtual_address: A virtual address that is associated
  //     with a requested page. The virutal address is represented
  //     as a unsigned 32 bit integer. NOTE: a virtual address
  //     is NOT the same as a page number. Multiple virtual addresses
  //     could be associated with the same page number.
  //
  // Returns:
  //   - the requested page, which is loaded into the cache and
  //     marked as the most recently used page
  Page&amp;amp; get_page(uint32_t virtual_address);

  // Returns the page capacity of the page table
  //
  // Arguments: None
  //
  // Returns: the page capacity of the page table
  size_t capacity();

  // Returns the number of pages currently loaded into &amp;quot;physical memory&amp;quot;
  //
  // Arguments: None
  //
  // Returns: the number of pages currently loaded into &amp;quot;physical memory&amp;quot;
  size_t loaded_pages();

  // Checks to see if the specified page is loaded into memory
  //
  // Arguments: The virtual page number of the page to check for
  //
  // Returns: True iff the page is loaded into memory, false otherwise
  bool page_available(pno_t virtual_pno);

  // Makes sure that all currently loaded pages are flushed
  // meaning tha the page contents are updated on the swap file.
  // This should not affect how recently used each page is and all pages
  // will remain loaded into memory after this operation is performed.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void flush_all_pages();

  // Flushes the specified page to the swap file.
  // This should not affect how recently used each page is and all pages
  // will remain loaded into memory after this operation is performed.
  //
  // Arguments: the virtual page number of the page to flush
  //
  // Returns: Nothing
  void flush_page(pno_t virtual_pno);

  // Discards the specified page from the PageTable.
  // If the page is dirty, then it is flushed before it is discarded.
  // If the page is not in the table, then nothing happens.
  //
  // Arguments: the virtual page number of the page to discard.
  //
  // Returns: Nothing
  void discard_page(pno_t virtual_pno);

  // Evicts a page from the PageTable. The page evicted
  // should be the least recntly used page in the cache.
  // If the evicted page is dirty, then it is flushed before it is evicted.
  // If there are no pages in the cache, then do nothing.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void evict_page();

 private:
  // The swap file where pages are stored
  fstream swap_file_;

  // The number of pages that can be stored
  // in the PageTable at one time.
  size_t capacity_;

  // TODO: add fields
  size_t page_num;

  // a vector to store pages in physical memory
  std::list&amp;lt;std::pair&amp;lt;pno_t,Page*&amp;gt;&amp;gt; page_list;

  // use an unordered_map to quickly determined the corresponding page
  std::unordered_map&amp;lt;pno_t,Page*&amp;gt; mp;
&amp;#125;;

&amp;#125;


#endif  // PAGE_TABLE_H_
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;PageTable-cc实现&#34;&gt;&lt;a href=&#34;#PageTable-cc实现&#34; class=&#34;headerlink&#34; title=&#34;PageTable.cc实现&#34;&gt;&lt;/a&gt;&lt;code&gt;PageTable.cc&lt;/code&gt;实现&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;quot;./PageTable.h&amp;quot;
#include &amp;quot;./Page.h&amp;quot;

namespace simplevm &amp;#123;
  // TODO: implment PageTable member functions
  // Constructs a new page table with the specified
  // swap file and the specified page capacity, which is
  // the number of pages that can be held in memory
  // at one time. There cannot be more than page_capacity
  // number of pages loaded in at a time.
  //
  // Arguments:
  //   - swap_file_name: the name of the swap_file
  //   - page_capacity: the maximum number of pages that can be held
  //     in memory at one time.
  PageTable::PageTable(std::string swap_file_name, size_t page_capacity) &amp;#123;
    swap_file_.open(swap_file_name);
    this-&amp;gt;capacity_ = page_capacity;
    this-&amp;gt;page_num = 0;
  &amp;#125;

  // Destructs the page table, freeing any allocated resources
  // and flushing any pages currently loaded into memory that
  // are dirty
  PageTable::~PageTable() &amp;#123;
    while(page_num &amp;gt; 0) &amp;#123;
        Page* deleted_page = page_list.back().second;
        page_list.pop_back();
        deleted_page-&amp;gt;~Page();
        page_num -= 1;
    &amp;#125;
    mp.clear();
    page_list.clear();
  &amp;#125;

  // Given a virtual address, gets the associated
  // page for that virtual address. This page will
  // be &amp;quot;loaded&amp;quot; into physical memory by the time it
  // is returned.
  //
  // There are three possiblities when a page is requested:
  // 1. The page is currently in the &amp;quot;loaded&amp;quot; and in the cache.
  //    In this case, a reference to the page is returned and
  //    and the page is marked as most recently used in the cache
  // 2. The page is not currently &amp;quot;loaded&amp;quot;, and the PageTable
  //    has not reached its page capacity:
  //    In this case, the page is loaded from the swap file and added
  //    to the cache as the most recently used page.
  // 3. The page is not currently &amp;quot;loaded&amp;quot;, and the PageTable
  //    is at page capacity:
  //    The least recently used page in the cache is evicted from the
  //    cache. Afterwards the requested page is loaded from the swap file
  //    and added to the cache as the most recently used page.
  //
  // NOTE: What decides how recntly used a page was used is entirely
  // decided by how recntly it was returned by a call to get_page.
  //
  // Arguments:
  //   - virtual_address: A virtual address that is associated
  //     with a requested page. The virutal address is represented
  //     as a unsigned 32 bit integer. NOTE: a virtual address
  //     is NOT the same as a page number. Multiple virtual addresses
  //     could be associated with the same page number.
  //
  // Returns:
  //   - the requested page, which is loaded into the cache and
  //     marked as the most recently used page
  Page&amp;amp; PageTable::get_page(uint32_t virtual_address) &amp;#123;
    // obtain the virtual_pno according to the virtual address
    pno_t pno = virtual_address / Page::PAGE_SIZE;
    if(page_available(pno)) &amp;#123;
        Page* p = mp[pno];
        page_list.remove(std::make_pair(pno,p));
        page_list.push_front(std::make_pair(pno,p));
        return *p;
    &amp;#125;
    else &amp;#123;
        Page* pg = new Page(swap_file_,pno);

        if(page_num &amp;lt; capacity_) &amp;#123;
            page_list.push_front(std::make_pair(pno,pg));
            flush_page(pno);
            page_num += 1;
        &amp;#125;
        else &amp;#123;
            // LRU Algorithms
            // evict the oldest page, and flush it
            evict_page();
            // add the new page to the front of the list
            page_list.push_front(std::make_pair(pno,pg));
            page_num += 1;
        &amp;#125;
        mp[pno] = pg;
        return *(mp[pno]);
    &amp;#125;
  &amp;#125;

  // Returns the page capacity of the page table
  //
  // Arguments: None
  //
  // Returns: the page capacity of the page table
  size_t PageTable::capacity() &amp;#123;
    return capacity_;
  &amp;#125;

  // Returns the number of pages currently loaded into &amp;quot;physical memory&amp;quot;
  //
  // Arguments: None
  //
  // Returns: the number of pages currently loaded into &amp;quot;physical memory&amp;quot;
  size_t PageTable::loaded_pages() &amp;#123;
    return page_num;
  &amp;#125;

  // Checks to see if the specified page is loaded into memory
  //
  // Arguments: The virtual page number of the page to check for
  //
  // Returns: True iff the page is loaded into memory, false otherwise
  bool PageTable::page_available(pno_t virtual_pno) &amp;#123;
    return mp.find(virtual_pno) != mp.end();
  &amp;#125;

  // Makes sure that all currently loaded pages are flushed
  // meaning tha the page contents are updated on the swap file.
  // This should not affect how recently used each page is and all pages
  // will remain loaded into memory after this operation is performed.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void PageTable::flush_all_pages() &amp;#123;
    for(auto p:page_list) &amp;#123;
        p.second-&amp;gt;flush();
    &amp;#125;
  &amp;#125;

  // Flushes the specified page to the swap file.
  // This should not affect how recently used each page is and all pages
  // will remain loaded into memory after this operation is performed.
  //
  // Arguments: the virtual page number of the page to flush
  //
  // Returns: Nothing
  void PageTable::flush_page(pno_t virtual_pno) &amp;#123;
    if(page_available(virtual_pno))&amp;#123;
        Page* p = mp.find(virtual_pno)-&amp;gt;second;
        p-&amp;gt;flush();
    &amp;#125;
  &amp;#125;

  // Discards the specified page from the PageTable.
  // If the page is dirty, then it is flushed before it is discarded.
  // If the page is not in the table, then nothing happens.
  //
  // Arguments: the virtual page number of the page to discard.
  //
  // Returns: Nothing
  void PageTable::discard_page(pno_t virtual_pno) &amp;#123;
    if(page_available(virtual_pno))&amp;#123;
        Page* p = mp.find(virtual_pno)-&amp;gt;second;
        p-&amp;gt;flush();
        page_list.remove(std::make_pair(virtual_pno,p));
        mp.erase(virtual_pno);
        page_num -= 1;
    &amp;#125;
  &amp;#125;

  // Evicts a page from the PageTable. The page evicted
  // should be the least recntly used page in the cache.
  // If the evicted page is dirty, then it is flushed before it is evicted.
  // If there are no pages in the cache, then do nothing.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void PageTable::evict_page() &amp;#123;
    pno_t current_pno = page_list.back().first;
    Page* p = page_list.back().second;
    // find the value in unordered_map
    for(auto it = mp.begin(); it != mp.end(); it++) &amp;#123;
        if(it-&amp;gt;first == current_pno &amp;amp;&amp;amp; it-&amp;gt;second == p) &amp;#123;
            mp.erase(it);
            break;
        &amp;#125;
    &amp;#125;
    page_list.pop_back();
    p-&amp;gt;flush();
    page_num -= 1;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>
