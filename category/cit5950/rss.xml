<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>望春风 • Posts by &#34;cit5950&#34; category</title>
        <link>https://salvely.github.io/blog</link>
        <description>计算机&amp;数理&amp;文学爱好者，喜欢健身、下厨、听音乐和看电影</description>
        <language>zh-CN</language>
        <pubDate>Mon, 08 Jan 2024 10:32:56 +0800</pubDate>
        <lastBuildDate>Mon, 08 Jan 2024 10:32:56 +0800</lastBuildDate>
        <category>C++</category>
        <category>Arch</category>
        <category>Linux</category>
        <category>安装教程</category>
        <category>操作系统</category>
        <category>notes</category>
        <category>配置教程</category>
        <category>Debian</category>
        <category>包管理</category>
        <category>参考资料</category>
        <category>CMake</category>
        <category>Makefile</category>
        <item>
            <guid isPermalink="true">https://salvely.github.io/blog/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_Project/</guid>
            <title>Final Project: 多线程HTTP服务器 实现记录</title>
            <link>https://salvely.github.io/blog/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_Project/</link>
            <pubDate>Mon, 08 Jan 2024 10:32:56 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;进入课程网页的时候意外发现这个 Project 的代码已经被填完了。所以没什么好做的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;Overview&#34;&gt;&lt;a href=&#34;#Overview&#34; class=&#34;headerlink&#34; title=&#34;Overview&#34;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;多线程网络服务器大致功能：简单的搜索和文件浏览&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Part A: 实现服务器读取文件，统计文件中的单词个数&lt;/li&gt;
&lt;li&gt;Part B: 实现网络连接和 HTTP 请求响应&lt;/li&gt;
&lt;li&gt;Part C: 将 A 和 B 两部分结合起来&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-A&#34;&gt;&lt;a href=&#34;#Part-A&#34; class=&#34;headerlink&#34; title=&#34;Part A&#34;&gt;&lt;/a&gt;Part A&lt;/h2&gt;&lt;h3 id=&#34;FileReader-cc&#34;&gt;&lt;a href=&#34;#FileReader-cc&#34; class=&#34;headerlink&#34; title=&#34;FileReader.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;FileReader.cc&lt;/code&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;简单的文件阅读器&lt;/li&gt;
&lt;li&gt;在构建时读入文件名，&lt;code&gt;read_file&lt;/code&gt;将整个文件读入一个&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;POSIX&lt;/code&gt;, C 接口或者 C++文件流实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;WordIndex-h-WordIndex-cc&#34;&gt;&lt;a href=&#34;#WordIndex-h-WordIndex-cc&#34; class=&#34;headerlink&#34; title=&#34;WordIndex.h &amp;amp; WordIndex.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;WordIndex.h &amp;amp; WordIndex.cc&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;实现一个数据结构，用于存储各个文件中的单词及其出现次数&lt;/p&gt;
&lt;h3 id=&#34;CrawlFileTree-cc&#34;&gt;&lt;a href=&#34;#CrawlFileTree-cc&#34; class=&#34;headerlink&#34; title=&#34;CrawlFileTree.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;CrawlFileTree.cc&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;实现&lt;code&gt;HandleFile&lt;/code&gt;函数，其获取一个文件名和一个&lt;code&gt;WordIndex&lt;/code&gt;，这个函数读取对应文件，并且将每个单词及其对应的个数存储在&lt;code&gt;WordIndex&lt;/code&gt;中&lt;/p&gt;
&lt;h2 id=&#34;Part-B&#34;&gt;&lt;a href=&#34;#Part-B&#34; class=&#34;headerlink&#34; title=&#34;Part B&#34;&gt;&lt;/a&gt;Part B&lt;/h2&gt;&lt;h3 id=&#34;ServerSocket-cc&#34;&gt;&lt;a href=&#34;#ServerSocket-cc&#34; class=&#34;headerlink&#34; title=&#34;ServerSocket.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;ServerSocket.cc&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;实现一个类，这个类包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个服务器端的监听 socket&lt;/li&gt;
&lt;li&gt;从客户端接受新的连接请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServerSocket.h&lt;/code&gt;中提供了头文件，需要在&lt;code&gt;ServerSocket.cc&lt;/code&gt;中实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;HttpConnection-cc&#34;&gt;&lt;a href=&#34;#HttpConnection-cc&#34; class=&#34;headerlink&#34; title=&#34;HttpConnection.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;HttpConnection.cc&lt;/code&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HttpConnection&lt;/code&gt;处理&lt;code&gt;HTTP&lt;/code&gt;连接请求，将该请求转化为一个对象，并且负责将响应写回去&lt;/li&gt;
&lt;li&gt;该函数中主要实现&lt;code&gt;HTTP&lt;/code&gt;请求的读取和解析(string 操作)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;HttpUtils-cc&#34;&gt;&lt;a href=&#34;#HttpUtils-cc&#34; class=&#34;headerlink&#34; title=&#34;HttpUtils.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;HttpUtils.cc&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;主要负责一些其他功能，尤其是安全方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;escape_html&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;用于防止&lt;code&gt;cross-site scripting&lt;/code&gt;，参考&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Dcm9zcy1zaXRlX3NjcmlwdGluZw==&#34;&gt;Cross-site scripting&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;in_path_safe&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;保证使用该服务器的人只能获取到对应目录下的文件，其他目录下对他不开放权限&lt;/li&gt;
&lt;li&gt;否则可能会有攻击者使用&lt;code&gt;directory traverse attack&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-C&#34;&gt;&lt;a href=&#34;#Part-C&#34; class=&#34;headerlink&#34; title=&#34;Part C&#34;&gt;&lt;/a&gt;Part C&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HttpServer_ThrFn&lt;/code&gt;函数实现&lt;ul&gt;
&lt;li&gt;每个线程可以获取到一个连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两个&lt;code&gt;helper_function&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;分别处理两种类型的请求&lt;ul&gt;
&lt;li&gt;对查看文件的请求(&lt;code&gt;ProcessFileRequest&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;执行查询的请求(&lt;code&gt;ProcessQueryRequest&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;htttp&lt;/code&gt;测试&lt;code&gt;Http Server&lt;/code&gt;。输入命令&lt;code&gt;./httpd 3000 ./test_tree/&lt;/code&gt;，在显示&lt;code&gt;accepting connections...&lt;/code&gt;后，点击下方的&lt;code&gt;Open Server on port 3000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现步骤&#34;&gt;&lt;a href=&#34;#实现步骤&#34; class=&#34;headerlink&#34; title=&#34;实现步骤&#34;&gt;&lt;/a&gt;实现步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FileReader::read_file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WordIndex.cc &amp;amp; WordIndex.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CrawlFileTree.cc handle_file函数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServerSocket.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get_request &amp;amp; parse_request from HttpConnection.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;write_response in HttpConnection.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HttpUtils.cc&lt;/code&gt;两个函数实现&lt;/li&gt;
&lt;li&gt;test_suite 通过&lt;/li&gt;
&lt;li&gt;valgrind 通过&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HttpServer.cc&lt;/code&gt;实现并测试&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实现提示&#34;&gt;&lt;a href=&#34;#实现提示&#34; class=&#34;headerlink&#34; title=&#34;实现提示&#34;&gt;&lt;/a&gt;实现提示&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost&lt;/code&gt;库中的&lt;code&gt;split()/trim()/replace_all()&lt;/code&gt;函数可以使用，使用&lt;code&gt;split()&lt;/code&gt;时可以使用&lt;code&gt;is_any_of()/isalpha()/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;ServerSocket.cc&lt;/code&gt;时，留意&lt;code&gt;server_accept_rw_close&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有个小函数可以让&lt;code&gt;is_path_safe&lt;/code&gt;的实现更简单(留意&lt;code&gt;HttpUtils.cc&lt;/code&gt;中的注释，自己上网学习它的用法)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FileReader&lt;/code&gt;需要处理只含有 0 个字节的&lt;code&gt;binary_files&lt;/code&gt;，这里可以使用传入 2 个参数的&lt;code&gt;string&lt;/code&gt;构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;测试&#34;&gt;&lt;a href=&#34;#测试&#34; class=&#34;headerlink&#34; title=&#34;测试&#34;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;make
./test_suite
valgrind ./test_suite
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://salvely.github.io/blog/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW4/</guid>
            <title>HW4: Shell &amp; Pipe 实现记录</title>
            <link>https://salvely.github.io/blog/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW4/</link>
            <pubDate>Sat, 06 Jan 2024 14:49:15 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;要求&#34;&gt;&lt;a href=&#34;#要求&#34; class=&#34;headerlink&#34; title=&#34;要求&#34;&gt;&lt;/a&gt;要求&lt;/h1&gt;&lt;p&gt;实现一个只含有基本命令和 Pipe(不含重定向符及其他符号)的 Shell。&lt;/p&gt;
&lt;h1 id=&#34;指南&#34;&gt;&lt;a href=&#34;#指南&#34; class=&#34;headerlink&#34; title=&#34;指南&#34;&gt;&lt;/a&gt;指南&lt;/h1&gt;&lt;h2 id=&#34;相关文件&#34;&gt;&lt;a href=&#34;#相关文件&#34; class=&#34;headerlink&#34; title=&#34;相关文件&#34;&gt;&lt;/a&gt;相关文件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pipe_shell.cc&lt;/code&gt;:在其中实现 shell 程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sh.cc&lt;/code&gt;: 传入一个附带参数的程序，&lt;code&gt;fork()&lt;/code&gt;子程序然后&lt;code&gt;execvp()&lt;/code&gt;去执行它&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdin_echo.cc&lt;/code&gt;: 从&lt;code&gt;stdin&lt;/code&gt;中读取，输出读取的内容，直到获取&lt;code&gt;EOF&lt;/code&gt;，然后停止&lt;/li&gt;
&lt;li&gt;&lt;code&gt;example_tests/&lt;/code&gt;: 其中含有示例输入和对应输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;solution_binaries/&lt;/code&gt;: 官方答案执行码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;具体要求&#34;&gt;&lt;a href=&#34;#具体要求&#34; class=&#34;headerlink&#34; title=&#34;具体要求&#34;&gt;&lt;/a&gt;具体要求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序一次从标准输入读取一行命令&lt;/li&gt;
&lt;li&gt;一行命令包括命令本身和连接他们的 Pipe&lt;/li&gt;
&lt;li&gt;不停读入直到读入&lt;code&gt;EOF&lt;/code&gt;&amp;#x2F;用户输入&lt;code&gt;exit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在当前命令完成之后才能运行下一条命令&lt;/li&gt;
&lt;li&gt;命令可以是绝对路径或者是程序名（用&lt;code&gt;execvp&lt;/code&gt;执行）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;建议方法&#34;&gt;&lt;a href=&#34;#建议方法&#34; class=&#34;headerlink&#34; title=&#34;建议方法&#34;&gt;&lt;/a&gt;建议方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通读该指南和提供的源代码，搞清楚作业是在做什么&lt;/li&gt;
&lt;li&gt;执行一下&lt;code&gt;./solution_binaries/pipe_shell&lt;/code&gt;，看看结果长什么样&lt;/li&gt;
&lt;li&gt;开始实现&lt;code&gt;pipe_shell.cc&lt;/code&gt;，从循环提示用户输入开始，并且打印&lt;code&gt;$&lt;/code&gt;提示符，直到无输入或者遇到&lt;code&gt;EOF&lt;/code&gt;&amp;#x2F;输入&lt;code&gt;exit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;fork()&lt;/code&gt;，&lt;code&gt;pipe&lt;/code&gt;连接和命令的执行(&lt;code&gt;execvp&lt;/code&gt;或者直接运行命令路径)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现提示&#34;&gt;&lt;a href=&#34;#实现提示&#34; class=&#34;headerlink&#34; title=&#34;实现提示&#34;&gt;&lt;/a&gt;实现提示&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以使用&lt;code&gt;boost&lt;/code&gt;库中的&lt;code&gt;split()&lt;/code&gt;和&lt;code&gt;trim()&lt;/code&gt;方法，&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;execvp(), fork(), pipe(), waitpid()&lt;/code&gt;等函数&lt;/li&gt;
&lt;li&gt;注意不同情形：无管道，一个管道，多于一个管道&lt;/li&gt;
&lt;li&gt;两种方法&lt;ul&gt;
&lt;li&gt;使用一个 pipe 数组&lt;/li&gt;
&lt;li&gt;每次&lt;code&gt;fork()&lt;/code&gt;之前创建一个&lt;code&gt;pipe&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个子进程只需要两个端口，从上一个进程送来的读端口，和给下一个子进程的写端口&lt;/li&gt;
&lt;li&gt;子进程用完端口之后关闭端口，否则程序无法正常退出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;测试&#34;&gt;&lt;a href=&#34;#测试&#34; class=&#34;headerlink&#34; title=&#34;测试&#34;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普通测试: &lt;code&gt;make &amp;amp;&amp;amp; ./pipe_shell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内存泄漏测试: &lt;code&gt;valgrind --leak-check=full ./pipe_shell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;比较自己的程序和&lt;code&gt;solution_binaries/pipe_shell&lt;/code&gt;的结果：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;cat ./tests/simple_input.txt | ./pipe_shell &amp;amp;&amp;gt; my_output.txt
diff my_output.txt ./tests/simple_output.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pipe-shell-cc&#34;&gt;&lt;a href=&#34;#pipe-shell-cc&#34; class=&#34;headerlink&#34; title=&#34;pipe_shell.cc&#34;&gt;&lt;/a&gt;&lt;code&gt;pipe_shell.cc&lt;/code&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;实现核心：&lt;code&gt;pipe&lt;/code&gt;的内存在操作系统内核中。在每次循环前创建一个&lt;code&gt;pipe&lt;/code&gt;，然后&lt;code&gt;fork()&lt;/code&gt;一个子进程读取上一个&lt;code&gt;pipe&lt;/code&gt;的内容，写入当前这个&lt;code&gt;pipe&lt;/code&gt;。使用完毕后关闭这个&lt;code&gt;pipe&lt;/code&gt;的写端，保留这个&lt;code&gt;pipe&lt;/code&gt;的读端口。进而让下一次&lt;code&gt;dup2&lt;/code&gt;导入时使用，使用完后可关闭该&lt;code&gt;pipe&lt;/code&gt;的读端口。&lt;code&gt;pipe&lt;/code&gt;不会像本地变量那样随着循环的进行而消失，只要保存一下读&amp;#x2F;写端口，在下一轮循环中就可以正常的进行读写。&lt;br&gt;此外，我们使用&lt;code&gt;dup2&lt;/code&gt;来进行端口的重定向。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;lt;unistd.h&amp;gt;    // for fork()
#include &amp;lt;sys/types.h&amp;gt; // for pid_t
#include &amp;lt;sys/wait.h&amp;gt;  // for wait(), waitpid(), etc.

#include &amp;lt;cstdlib&amp;gt; // for exit(), EXIT_SUCCESS, and EXIT_FAILURE
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;boost/algorithm/string.hpp&amp;gt;

using namespace std;

#define BUF_SIZ 1000

int main()
&amp;#123;
    string s;
    cout &amp;lt;&amp;lt; &amp;quot;$ &amp;quot;;
    while (getline(std::cin, s))
    &amp;#123;
        if (s == &amp;quot;exit&amp;quot;)
        &amp;#123;
            return EXIT_SUCCESS;
        &amp;#125;

        int fd[2];
        int in_fd = 0; // input fd

        // split the command into multiple parts
        vector&amp;lt;string&amp;gt; tokens;
        boost::algorithm::split(tokens, s, boost::is_any_of(&amp;quot;|&amp;quot;), boost::token_compress_on);

        int count = 1;
        int command_num = tokens.size();

        for (auto &amp;amp;command : tokens)
        &amp;#123;
            // initialize a pipe
            if (pipe(fd) == -1)
            &amp;#123;
                perror(&amp;quot;pipe creation failed!&amp;quot;);
                return EXIT_FAILURE;
            &amp;#125;

            // prepare to run the current command

            // get the current command
            boost::algorithm::trim(command);
            // split the command into an array of args
            vector&amp;lt;string&amp;gt; args;
            boost::algorithm::split(args, command, boost::is_any_of(&amp;quot; &amp;quot;), boost::token_compress_on);
            int argc = args.size();
            if (argc &amp;lt; 1)
            &amp;#123;
                cerr &amp;lt;&amp;lt; &amp;quot;We need a command!&amp;quot; &amp;lt;&amp;lt; endl;
                return EXIT_FAILURE;
            &amp;#125;

            // run the current command
            pid_t child = fork();
            if (child == 0)
            &amp;#123;
                // setup the file name and input arguments
                const char *filename = args[0].c_str();
                char **argv = new char *[argc + 1];
                for (int i = 0; i &amp;lt; argc; i++)
                &amp;#123;
                    string args_str = args[i];
                    argv[i] = new char[10];
                    strcpy(argv[i], args_str.c_str());
                &amp;#125;
                argv[argc] = nullptr;

                if (in_fd != 0)
                &amp;#123;
                    // write the pipe value into stdin
                    dup2(in_fd, STDIN_FILENO);
                    close(in_fd);
                &amp;#125;

                if (count != command_num)
                &amp;#123;
                    // write stdout to the pipe
                    dup2(fd[1], STDOUT_FILENO);
                    close(fd[1]);
                &amp;#125;

                // use execvp() to run the commmand
                execvp(filename, argv);

                // exec didn&amp;#39;t work, so an error must have been occurred
                cerr &amp;lt;&amp;lt; strerror(errno) &amp;lt;&amp;lt; endl;
                delete[] argv;
                return EXIT_FAILURE;
            &amp;#125;

            // wait for the child process to complete
            int status;
            waitpid(child, &amp;amp;status, 0);

            // close the current pipe write fd
            close(fd[1]);
            in_fd = fd[0];
            count += 1;
        &amp;#125;

        // // read out the pipe
        // char buffer[BUF_SIZ];
        // int count = read(in_fd, buffer, BUF_SIZ);
        // buffer[count] = &amp;#39;\0&amp;#39;;
        // if (count &amp;gt; 0)
        // &amp;#123;
        //     fprintf(stdout, &amp;quot;%s&amp;quot;, buffer);
        // &amp;#125;
        close(in_fd);

        cout &amp;lt;&amp;lt; &amp;quot;$ &amp;quot;;
    &amp;#125;
    return EXIT_SUCCESS;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://salvely.github.io/blog/2024/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW3/</guid>
            <title>HW3: LRU SimpleVM 实现记录</title>
            <link>https://salvely.github.io/blog/2024/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW3/</link>
            <pubDate>Thu, 04 Jan 2024 13:27:01 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Overview&#34;&gt;&lt;a href=&#34;#Overview&#34; class=&#34;headerlink&#34; title=&#34;Overview&#34;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;本作业要求实现:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Page 对象：&lt;ul&gt;
&lt;li&gt;若 Page 不在 memory 中，那么它的数据被存储在磁盘上的&lt;code&gt;swap file&lt;/code&gt;部分。在&lt;code&gt;swap file&lt;/code&gt;中，每一页都有对应的顺序存储的数据。&lt;/li&gt;
&lt;li&gt;可以使用 C++ &lt;code&gt;fstream&lt;/code&gt;类进行 I&amp;#x2F;O 读写。尤其是&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PageTable 对象&lt;ul&gt;
&lt;li&gt;包含多个 page 以及&lt;code&gt;swap file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这里主要要求实现 LRU 算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;相关文件&#34;&gt;&lt;a href=&#34;#相关文件&#34; class=&#34;headerlink&#34; title=&#34;相关文件&#34;&gt;&lt;/a&gt;相关文件&lt;/h1&gt;&lt;h2 id=&#34;Page&#34;&gt;&lt;a href=&#34;#Page&#34; class=&#34;headerlink&#34; title=&#34;Page&#34;&gt;&lt;/a&gt;Page&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Page.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Page.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PageTemplates.cc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;PageTable&#34;&gt;&lt;a href=&#34;#PageTable&#34; class=&#34;headerlink&#34; title=&#34;PageTable&#34;&gt;&lt;/a&gt;PageTable&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PageTable.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PageTable.cc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Testing&#34;&gt;&lt;a href=&#34;#Testing&#34; class=&#34;headerlink&#34; title=&#34;Testing&#34;&gt;&lt;/a&gt;Testing&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test_page.cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test_pagetable.cc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;实现提示&#34;&gt;&lt;a href=&#34;#实现提示&#34; class=&#34;headerlink&#34; title=&#34;实现提示&#34;&gt;&lt;/a&gt;实现提示&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;map, unordered_map, list, vector 结构都很有用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fstream&lt;/code&gt;中的&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;很有用&lt;/li&gt;
&lt;li&gt;需要将&lt;code&gt;uint8_t&lt;/code&gt;切换到&lt;code&gt;char&lt;/code&gt;类型来使用&lt;code&gt;fstream&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;利用初始化列表来初始化引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Page实现&#34;&gt;&lt;a href=&#34;#Page实现&#34; class=&#34;headerlink&#34; title=&#34;Page实现&#34;&gt;&lt;/a&gt;Page实现&lt;/h1&gt;&lt;h2 id=&#34;Page-源码分析&#34;&gt;&lt;a href=&#34;#Page-源码分析&#34; class=&#34;headerlink&#34; title=&#34;Page 源码分析&#34;&gt;&lt;/a&gt;Page 源码分析&lt;/h2&gt;&lt;p&gt;&lt;code&gt;simplevm namespace&lt;/code&gt;中存在一个类&lt;code&gt;Page&lt;/code&gt;，此外还有一个&lt;code&gt;uint32_t&lt;/code&gt;类型(&lt;code&gt;pno_t&lt;/code&gt;类型)的变量，用来表示页号。&lt;code&gt;Page&lt;/code&gt;页的解释如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页对象存在-&amp;gt;页被导入到 physical memory-&amp;gt;创建一个&lt;code&gt;page&lt;/code&gt;，并且从&lt;code&gt;swap_file&lt;/code&gt;中读&lt;code&gt;page&lt;/code&gt;数据。页的数据从&lt;code&gt;virtual_pno * Page::PAGE_SIZE&lt;/code&gt;开始&lt;/li&gt;
&lt;li&gt;页对象不存在-&amp;gt;数据存储在&lt;code&gt;swap_file&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;用户可以&lt;ul&gt;
&lt;li&gt;获取数据&lt;/li&gt;
&lt;li&gt;存储数据&lt;/li&gt;
&lt;li&gt;将数据刷新到&lt;code&gt;swap file&lt;/code&gt;中（多余的无法放入 physical memory 的虚拟内存所存储的地方）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Page&lt;/code&gt;类中包含如下&lt;code&gt;public&lt;/code&gt;方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Page(fstream&amp;amp; swap_file, pno_t virtual_pno);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;构造函数，传入该&lt;code&gt;page&lt;/code&gt;对应的&lt;code&gt;swap_file&lt;/code&gt;和页号&lt;/li&gt;
&lt;li&gt;我们从&lt;code&gt;swap_file&lt;/code&gt;读入页数据，刷新时将页数据写入&lt;code&gt;swap_file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;页号规定了我们在&lt;code&gt;swap_file&lt;/code&gt;的哪里写入数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Page(const Page&amp;amp; other);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;利用一个页来复制构造另一个页，两个页具有相同的页号和&lt;code&gt;swap_file&lt;/code&gt;地址，但是数据是复制了的（不是引用）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~Page()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;清理声明的变量&lt;/li&gt;
&lt;li&gt;如果当前数据为 dirty 状态，那么将其刷新到对应的&lt;code&gt;swap_file&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Page&amp;amp; operator=(const Page&amp;amp; rhs)&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;赋值函数，同复制构造函数，两个&lt;code&gt;Page&lt;/code&gt;具有相同的&lt;code&gt;swap_file&lt;/code&gt;和页号，但是&lt;code&gt;data&lt;/code&gt;是被复制了的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt; T access(uint32_t virtual_address);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;获取该页面的值（需要考虑错误情况）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T store(uint32_t virtual address, const T&amp;amp; to_write)&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;存储值到该页面中去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool operator&amp;lt;(const Page&amp;amp; rhs);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;比较两个页面顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pno_t pno();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;获取该页面的页号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool dirty();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 是否为 dirty 状态(如果有人在 flush 之后，向该 page 写过值就是 dirty)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void flush();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如果该 page 是 dirty 状态，就把内容刷新到&lt;code&gt;swap_file&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;变量：&lt;code&gt;static constexpr size_t PAGE_SIZE = 4096U;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Page 中还包括如下&lt;code&gt;private&lt;/code&gt;变量:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fstream&amp;amp; swap_file_;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;注意这里是个引用，一个 page 没有对&lt;code&gt;swap_file&lt;/code&gt;的所有权，只能 access 到它，所以这里&lt;code&gt;swap_file&lt;/code&gt;是个引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pno_t virtual_pno_;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 的页号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uint8_t *bytes_;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 的字节内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool dirty_;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;该 page 是否在 flush 后被写入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Page-设计&#34;&gt;&lt;a href=&#34;#Page-设计&#34; class=&#34;headerlink&#34; title=&#34;Page 设计&#34;&gt;&lt;/a&gt;Page 设计&lt;/h2&gt;&lt;h2 id=&#34;PageTemplates-cc实现&#34;&gt;&lt;a href=&#34;#PageTemplates-cc实现&#34; class=&#34;headerlink&#34; title=&#34;PageTemplates.cc实现&#34;&gt;&lt;/a&gt;&lt;code&gt;PageTemplates.cc&lt;/code&gt;实现&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PageTemplates.cc&lt;/code&gt;在&lt;code&gt;simplevm namespace&lt;/code&gt;中。源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;
namespace simplevm &amp;#123;
  // TODO: implement all template member functions for Page

  // This function allows users to read various data types
  // from the page. Trying to read a non-primitive type or use
  // a virtual address that doesn&amp;#39;t map to this page results
  // in undefined behaviour. You can also assume that
  // anything being read fits in on the page we are reading
  // is not partially on another page.
  // If you are familiar with endianness, it shouldn&amp;#39;t be
  // considered for this function.
  //
  // Arguments:
  //   - virtual_address: a virtual address that maps somewhere
  //     into the page, where we will read data of type T
  //
  // Returns:
  //   - the data of type T that was read from the page
  template &amp;lt;typename T&amp;gt;
  T Page::access(uint32_t virtual_address) &amp;#123;
    if(virtual_address / PAGE_SIZE != virtual_pno_)
        return 0;
    virtual_address = virtual_address % PAGE_SIZE;
    T* address = (T*)(bytes_ + virtual_address);
    return *address;
  &amp;#125;

  // This function allows users to write various data types
  // to the page. Trying to write a non-primitive type or use
  // a virtual address that doesn&amp;#39;t map to this page results
  // in undefined behaviour. You can also assume that
  // anything being written fits on the current page
  // is not partially on another page.
  // If you are familiar with endianness, it shouldn&amp;#39;t be
  // considered for this function.
  //
  // Arguments:
  //   - virtual_address: a virtual address that maps somewhere
  //     into the page, where we will read data of type T
  //   - to_write: the data of type T to write to the page
  //
  // Returns: nothing

  template &amp;lt;typename T&amp;gt;
  void Page::store(uint32_t virtual_address, const T&amp;amp; to_write) &amp;#123;
    if(virtual_address / PAGE_SIZE != virtual_pno_)
        return;
    virtual_address = virtual_address % PAGE_SIZE;
    T* address = (T*)(bytes_ + virtual_address);
    *address = to_write;
    dirty_ = true;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Page-h定义&#34;&gt;&lt;a href=&#34;#Page-h定义&#34; class=&#34;headerlink&#34; title=&#34;Page.h定义&#34;&gt;&lt;/a&gt;&lt;code&gt;Page.h&lt;/code&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Page.h&lt;/code&gt;在&lt;code&gt;simplevm namespace&lt;/code&gt;中。源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#ifndef PAGE_H_
#define PAGE_H_

#include &amp;lt;cstdint&amp;gt;
#include &amp;lt;fstream&amp;gt;

using std::fstream;

namespace simplevm &amp;#123;

// defines the type pno_t, which is the type
// that represents a page number
typedef uint32_t pno_t;

///////////////////////////////////////////////////////////////////////////////
// A Page is a class that represents a page of memory
// in our simple virtual memory model.
// If a page object exists, then we say that the page is loaded
// into physical memory. When the page object doesn&amp;#39;t exist, then its
// data is stored in the swap_file. When we load in a page to
// &amp;quot;physical memory&amp;quot;, we are creating the page and we read the page&amp;#39;s data
// from the swap file. A page&amp;#39;s data in the swap file starts at
// virtual_pno * Page::PAGE_SIZE
//
// This Class manages a page&amp;#39;s worth of data
// Users can access or store data, sa well as flush the data in the
// page to the specified swap file. A swap file is where exceess virtual
// memory is stored when it can&amp;#39;t fit in physical memory.
///////////////////////////////////////////////////////////////////////////////
class Page &amp;#123;
 public:
  // Constructs a new Page object associated
  // with a swap_file and a virtual page number.
  // The swap file is where we will load in the page
  // contents and flush the page contents. The virtual
  // page number decides where in that file we read
  // and write this page.
  // Passing in an invalid page number is undefined behaviour
  // Note that a Page does not have ownership
  // of the swap_file_, just access to it.
  //
  // Arguments:
  //  - swap_file the swap_file associated with the page
  //  - the virtual page number of our new page
  Page(fstream&amp;amp; swap_file, pno_t virtual_pno);

  // Constructs a new Page object that is a copy of
  // another page object. Both pages will have
  // the same page number and swap_file, but should
  // have independent copies of the page data.
  //
  // Misc: this means that there could be issues with
  // having the original and copy page having differnt
  // data. This cctor should only really be used
  // in the context of managing pages with something
  // like STL, where the original page used for the cctor
  // will be discarded. In real C++, we would want to
  // use move semantics here.
  //
  // Arguements:
  //   - other: the page we are copying
  Page(const Page&amp;amp; other);

  // Destructor for the page object
  // Cleans up any dynamically allocated data or
  // otherwise allocated resources AND should flush
  // its contents if the page is dirty at time of
  // destruction.
  ~Page();

  // Set the current Page object so that is a copy of
  // another page object. Both pages will have
  // the same page number and swap_file, but should
  // have independent copies of the page data.
  //
  // Misc: this means that there could be issues with
  // having the original and copy page having differnt
  // data. This op= should only really be used
  // in the context of managing pages with something
  // like STL, where the original page used for the cctor
  // will be discarded. In real C++, we would want to
  // use move semantics here.
  //
  // You can assume each page has the same swap_file.
  //
  // Arguements:
  //   - rhs: the page we are copying
  Page&amp;amp; operator=(const Page&amp;amp; rhs);

  // This function is not required, but you may add it
  // if it is needed for some of the STL containers
  // you use in PageTable
  //
  // Determines if this page should go before another page if they
  // were in sorted order.
  //
  // Arguments:
  //   - rhs: the Page we are comparing this to
  //
  // Returns: true iff this page would show up before the other
  // page in sorted order. False otherwise.
  bool operator&amp;lt;(const Page&amp;amp; rhs);

  // This function allows users to read various data types
  // from the page. Trying to read a non-primitive type or use
  // a virtual address that doesn&amp;#39;t map to this page results
  // in undefined behaviour. You can also assume that
  // anything being read fits in on the page we are reading
  // is not partially on another page.
  // If you are familiar with endianness, it shouldn&amp;#39;t be
  // considered for this function.
  //
  // Arguments:
  //   - virtual_address: a virtual address that maps somewhere
  //     into the page, where we will read data of type T
  //
  // Returns:
  //   - the data of type T that was read from the page
  template &amp;lt;typename T&amp;gt;
  T access(uint32_t virtual_address);

  // This function allows users to write various data types
  // to the page. Trying to write a non-primitive type or use
  // a virtual address that doesn&amp;#39;t map to this page results
  // in undefined behaviour. You can also assume that
  // anything being written fits on the current page
  // is not partially on another page.
  // If you are familiar with endianness, it shouldn&amp;#39;t be
  // considered for this function.
  //
  // Arguments:
  //   - virtual_address: a virtual address that maps somewhere
  //     into the page, where we will read data of type T
  //   - to_write: the data of type T to write to the page
  //
  // Returns: nothing
  template &amp;lt;typename T&amp;gt;
  void store(uint32_t virtual_address, const T&amp;amp; to_write);

  // Returns the virtual page number of this page
  //
  // Arguments: None
  //
  // Returns: this page&amp;#39;s virtual page number
  pno_t pno();

  // Returns whether or not a page is dirty
  // A page is &amp;quot;dirty&amp;quot; if someone has written to the data managed
  // by the page since the last time the page was flush()&amp;#39;d.
  //
  // Arguments: None
  //
  // Returns: Whether this page is dirty or not
  bool dirty();

  // Flushes the page to the swap file if it is dirty.
  // Flushing a page to the swap file involves writing
  // the page at the the spot correspoding to its page number
  // in the swap_file. For a description of what it means
  // for a page to be dirty, see the dirty() member function.
  // The page should not be written if it is not dirty.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void flush();

  // The amount of memory a page represents
  static constexpr size_t PAGE_SIZE = 4096U;

 private:
  // The file we will be reading/writing to
  // Note how this is a reference
  //
  // also note that a Page does not have ownership
  // of the swap_file_, just access to it.
  fstream&amp;amp; swap_file_;

  // the virtual page number
  pno_t virtual_pno_;

  // The bytes of the page. One byte is 8 bits
  // so we use 8-bit unsigned integers.
  // You can also assume that a &amp;#39;char&amp;#39; is one byte big
  uint8_t *bytes_;

  // Whether the page is dirty or not
  bool dirty_;
&amp;#125;;

&amp;#125;

// since we have template code
#include &amp;quot;./PageTemplates.cc&amp;quot;

#endif  // PAGE_H_
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Page-cc实现&#34;&gt;&lt;a href=&#34;#Page-cc实现&#34; class=&#34;headerlink&#34; title=&#34;Page.cc实现&#34;&gt;&lt;/a&gt;&lt;code&gt;Page.cc&lt;/code&gt;实现&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Page.cc&lt;/code&gt;在&lt;code&gt;simplevm namespace&lt;/code&gt;中。源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;quot;./Page.h&amp;quot;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

namespace simplevm &amp;#123;
  // TODO: implement all non template member functions for Page
    // Constructs a new Page object associated
  // with a swap_file and a virtual page number.
  // The swap file is where we will load in the page
  // contents and flush the page contents. The virtual
  // page number decides where in that file we read
  // and write this page.
  // Passing in an invalid page number is undefined behaviour
  // Note that a Page does not have ownership
  // of the swap_file_, just access to it.
  //
  // Arguments:
  //  - swap_file the swap_file associated with the page
  //  - the virtual page number of our new page
  Page::Page(fstream&amp;amp; swap_file, pno_t virtual_pno):swap_file_(swap_file) &amp;#123;
    this-&amp;gt;virtual_pno_ = virtual_pno;
    this-&amp;gt;bytes_ = new uint8_t[PAGE_SIZE];
    // seek the correct position
    swap_file_.seekg(virtual_pno_ * PAGE_SIZE, std::ios::beg);
    // read from the swap file
    swap_file_.read((char*)bytes_,PAGE_SIZE);
    if(!swap_file_) &amp;#123;
        std::cerr &amp;lt;&amp;lt; &amp;quot;Swap file read failed!&amp;quot; &amp;lt;&amp;lt; std::endl;
        exit(1);
    &amp;#125;
    this-&amp;gt;dirty_ = false;
  &amp;#125;

  // Constructs a new Page object that is a copy of
  // another page object. Both pages will have
  // the same page number and swap_file, but should
  // have independent copies of the page data.
  //
  // Misc: this means that there could be issues with
  // having the original and copy page having differnt
  // data. This cctor should only really be used
  // in the context of managing pages with something
  // like STL, where the original page used for the cctor
  // will be discarded. In real C++, we would want to
  // use move semantics here.
  //
  // Arguements:
  //   - other: the page we are copying
  Page::Page(const Page&amp;amp; other):swap_file_(other.swap_file_) &amp;#123;
    this-&amp;gt;virtual_pno_ = other.virtual_pno_;
    this-&amp;gt;bytes_ = new uint8_t[PAGE_SIZE];
    memcpy(this-&amp;gt;bytes_,other.bytes_,PAGE_SIZE);
    this-&amp;gt;dirty_ = other.dirty_;
  &amp;#125;

  // Destructor for the page object
  // Cleans up any dynamically allocated data or
  // otherwise allocated resources AND should flush
  // its contents if the page is dirty at time of
  // destruction.
  Page::~Page() &amp;#123;
    if(dirty_) &amp;#123;
        flush();
    &amp;#125;
    dirty_ = false;
    delete[] bytes_;
  &amp;#125;

  // Set the current Page object so that is a copy of
  // another page object. Both pages will have
  // the same page number and swap_file, but should
  // have independent copies of the page data.
  //
  // Misc: this means that there could be issues with
  // having the original and copy page having differnt
  // data. This op= should only really be used
  // in the context of managing pages with something
  // like STL, where the original page used for the cctor
  // will be discarded. In real C++, we would want to
  // use move semantics here.
  //
  // You can assume each page has the same swap_file.
  //
  // Arguements:
  //   - rhs: the page we are copying
  Page&amp;amp; Page::operator=(const Page&amp;amp; rhs) &amp;#123;
    if (this!=&amp;amp;rhs)
    &amp;#123;
        this-&amp;gt;~Page();
        new (this)Page(rhs);
    &amp;#125;

    return *this;
  &amp;#125;

  // This function is not required, but you may add it
  // if it is needed for some of the STL containers
  // you use in PageTable
  //
  // Determines if this page should go before another page if they
  // were in sorted order.
  //
  // Arguments:
  //   - rhs: the Page we are comparing this to
  //
  // Returns: true iff this page would show up before the other
  // page in sorted order. False otherwise.
  bool Page::operator&amp;lt;(const Page&amp;amp; rhs) &amp;#123;
    return this-&amp;gt;virtual_pno_ &amp;lt; rhs.virtual_pno_;
  &amp;#125;

  // Returns the virtual page number of this page
  //
  // Arguments: None
  //
  // Returns: this page&amp;#39;s virtual page number
  pno_t Page::pno() &amp;#123;
    return this-&amp;gt;virtual_pno_;
  &amp;#125;

  // Returns whether or not a page is dirty
  // A page is &amp;quot;dirty&amp;quot; if someone has written to the data managed
  // by the page since the last time the page was flush()&amp;#39;d.
  //
  // Arguments: None
  //
  // Returns: Whether this page is dirty or not
  bool Page::dirty() &amp;#123;
    return this-&amp;gt;dirty_;
  &amp;#125;

  // Flushes the page to the swap file if it is dirty.
  // Flushing a page to the swap file involves writing
  // the page at the the spot correspoding to its page number
  // in the swap_file. For a description of what it means
  // for a page to be dirty, see the dirty() member function.
  // The page should not be written if it is not dirty.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void Page::flush() &amp;#123;
    if(dirty()) &amp;#123;
        // seek the correct position
        swap_file_.seekg(virtual_pno_ * PAGE_SIZE,std::ios::beg);
        // write to the swap file
        swap_file_.write((char*)bytes_,PAGE_SIZE);
        if(!swap_file_) &amp;#123;
            std::cerr &amp;lt;&amp;lt; &amp;quot;Swap file write failed!&amp;quot; &amp;lt;&amp;lt; std::endl;
            exit(1);
        &amp;#125;
        dirty_ = false;
    &amp;#125;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;PageTable实现&#34;&gt;&lt;a href=&#34;#PageTable实现&#34; class=&#34;headerlink&#34; title=&#34;PageTable实现&#34;&gt;&lt;/a&gt;PageTable实现&lt;/h1&gt;&lt;h2 id=&#34;PageTable-源码分析&#34;&gt;&lt;a href=&#34;#PageTable-源码分析&#34; class=&#34;headerlink&#34; title=&#34;PageTable 源码分析&#34;&gt;&lt;/a&gt;PageTable 源码分析&lt;/h2&gt;&lt;p&gt;PageTable 的作用如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理一个进程的地址空间&lt;/li&gt;
&lt;li&gt;包括&lt;code&gt;swap_file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从 physical memory 中读取页&lt;/li&gt;
&lt;li&gt;选择页淘汰，进行页替换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;PageTable.cc&lt;/code&gt;中有如下一些方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PageTable(std::string swap_file_name, size_t page_capacity);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;初始化页表，制定&lt;code&gt;swap_file&lt;/code&gt;名称和页容量&lt;/li&gt;
&lt;li&gt;存储的页不可超过页容量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~PageTable();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;清理所有变量&lt;/li&gt;
&lt;li&gt;flush dirty pages&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Page&amp;amp; get_page(uint32_t virtual_address);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;返回一个虚拟地址对应的 page&lt;/li&gt;
&lt;li&gt;将该页导入 physical memory&lt;/li&gt;
&lt;li&gt;返回它&lt;/li&gt;
&lt;li&gt;有几种可能情况&lt;ul&gt;
&lt;li&gt;该页在 Physical memory 中，返回对应的页的引用，并且将该页标记为最新（挪到 vector 最前）&lt;/li&gt;
&lt;li&gt;该页不在 physical memory 中，并且 physical memory 还没满。那么将其导入 physical memory，并且标记为最新（挪到 vector 最前），返回该页引用&lt;/li&gt;
&lt;li&gt;该页不在 Physical memory 中，并且 physical memory 已经满了，那么先执行淘汰算法，淘汰最老的页，将其写入&lt;code&gt;swap_file&lt;/code&gt;。然后将该页从&lt;code&gt;swap_file&lt;/code&gt;中导入进来，放在 vector 最前&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：&lt;ul&gt;
&lt;li&gt;virtual address !&amp;#x3D; 页号，可能有多个 virtual address 对应同一个页号(一页有 4096 个字节嘛)&lt;/li&gt;
&lt;li&gt;页的最新和最老完全取决于&lt;code&gt;get_page&lt;/code&gt;函数的调用情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t capacity();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;返回页容量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t loaded_pages();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;返回导入 physical memory 的页数目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool page_available(pno_t virtual_pno);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;返回对应页是否存在 physical memory 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void flush_all_pages();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;将所有页都刷新到&lt;code&gt;swap_file&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void flush_page(pno_t virtual_pno);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;将对应的页刷新到&lt;code&gt;swap_file&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void discard_page(pno_t virtual_pno);&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;从页表中丢弃对应的页。如果该页不存在，则返回。否则，若该页为 dirty，则将该页数据写入&lt;code&gt;swap_file&lt;/code&gt;，然后丢弃它&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void evict_page();&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;若没有 page 在页表中，则什么也不做。否则丢弃最老的一页（丢弃前记得将其写入&lt;code&gt;swap_file&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;PageTable.cc&lt;/code&gt;有两个&lt;code&gt;private&lt;/code&gt;变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fstream swap_file_&lt;/code&gt;: 交换文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t capacity&lt;/code&gt;: 页容量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t page_num&lt;/code&gt;: 当前已经导入 physical memory 的页数目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::vector&amp;lt;Page*&amp;gt; page_list&lt;/code&gt;: 记录所有在 physical memory 中的页&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::unordered_map&amp;lt;pno_t,Page*&amp;gt; mp&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;PageTable-h设计&#34;&gt;&lt;a href=&#34;#PageTable-h设计&#34; class=&#34;headerlink&#34; title=&#34;PageTable.h设计&#34;&gt;&lt;/a&gt;&lt;code&gt;PageTable.h&lt;/code&gt;设计&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#ifndef PAGE_TABLE_H_
#define PAGE_TABLE_H_

#include &amp;lt;fstream&amp;gt;
#include &amp;lt;cstdint&amp;gt;
// #include &amp;lt;vector&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;list&amp;gt;

#include &amp;quot;./Page.h&amp;quot;

using std::fstream;

namespace simplevm &amp;#123;

///////////////////////////////////////////////////////////////////////////////
// A PageTable manages a processes memeory for our simplified
// virtual memory model. This involves managing a swap_file
// which is where pages of data are stored when they aren&amp;#39;t loaded
// into physical memory. For our software model, we will say a page
// is in &amp;quot;physical memory&amp;quot; if it is loaded into our memory space
// (e.g. it is on the heap). Pages that aren&amp;#39;t loaded in will have
// their contents stored in the swap_file and will not have an
// associated Page object (see Page.h). Our page table can only have
// so many pages stored in memory at one time, which is specified
// on PageTable Creation. We implement an LRU page replacement
// policy to decide which pages to evict if we need to load a new page
// and we already have reached our capacity on the numberof pages we can
// hold.
//
// Users can get a page from the cache, flush pages to the swap_file,
// request any page is evicted, and specifically ask for a page to be evicted.
///////////////////////////////////////////////////////////////////////////////
class PageTable &amp;#123;
 public:
  // Constructs a new page table with the specified
  // swap file and the specified page capacity, which is
  // the number of pages that can be held in memory
  // at one time. There cannot be more than page_capacity
  // number of pages loaded in at a time.
  //
  // Arguments:
  //   - swap_file_name: the name of the swap_file
  //   - page_capacity: the maximum number of pages that can be held
  //     in memory at one time.
  PageTable(std::string swap_file_name, size_t page_capacity);

  // Destructs the page table, freeing any allocated resources
  // and flushing any pages currently loaded into memory that
  // are dirty
  ~PageTable();

  // Given a virtual address, gets the associated
  // page for that virtual address. This page will
  // be &amp;quot;loaded&amp;quot; into physical memory by the time it
  // is returned.
  //
  // There are three possiblities when a page is requested:
  // 1. The page is currently in the &amp;quot;loaded&amp;quot; and in the cache.
  //    In this case, a reference to the page is returned and
  //    and the page is marked as most recently used in the cache
  // 2. The page is not currently &amp;quot;loaded&amp;quot;, and the PageTable
  //    has not reached its page capacity:
  //    In this case, the page is loaded from the swap file and added
  //    to the cache as the most recently used page.
  // 3. The page is not currently &amp;quot;loaded&amp;quot;, and the PageTable
  //    is at page capacity:
  //    The least recently used page in the cache is evicted from the
  //    cache. Afterwards the requested page is loaded from the swap file
  //    and added to the cache as the most recently used page.
  //
  // NOTE: What decides how recntly used a page was used is entirely
  // decided by how recntly it was returned by a call to get_page.
  //
  // Arguments:
  //   - virtual_address: A virtual address that is associated
  //     with a requested page. The virutal address is represented
  //     as a unsigned 32 bit integer. NOTE: a virtual address
  //     is NOT the same as a page number. Multiple virtual addresses
  //     could be associated with the same page number.
  //
  // Returns:
  //   - the requested page, which is loaded into the cache and
  //     marked as the most recently used page
  Page&amp;amp; get_page(uint32_t virtual_address);

  // Returns the page capacity of the page table
  //
  // Arguments: None
  //
  // Returns: the page capacity of the page table
  size_t capacity();

  // Returns the number of pages currently loaded into &amp;quot;physical memory&amp;quot;
  //
  // Arguments: None
  //
  // Returns: the number of pages currently loaded into &amp;quot;physical memory&amp;quot;
  size_t loaded_pages();

  // Checks to see if the specified page is loaded into memory
  //
  // Arguments: The virtual page number of the page to check for
  //
  // Returns: True iff the page is loaded into memory, false otherwise
  bool page_available(pno_t virtual_pno);

  // Makes sure that all currently loaded pages are flushed
  // meaning tha the page contents are updated on the swap file.
  // This should not affect how recently used each page is and all pages
  // will remain loaded into memory after this operation is performed.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void flush_all_pages();

  // Flushes the specified page to the swap file.
  // This should not affect how recently used each page is and all pages
  // will remain loaded into memory after this operation is performed.
  //
  // Arguments: the virtual page number of the page to flush
  //
  // Returns: Nothing
  void flush_page(pno_t virtual_pno);

  // Discards the specified page from the PageTable.
  // If the page is dirty, then it is flushed before it is discarded.
  // If the page is not in the table, then nothing happens.
  //
  // Arguments: the virtual page number of the page to discard.
  //
  // Returns: Nothing
  void discard_page(pno_t virtual_pno);

  // Evicts a page from the PageTable. The page evicted
  // should be the least recntly used page in the cache.
  // If the evicted page is dirty, then it is flushed before it is evicted.
  // If there are no pages in the cache, then do nothing.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void evict_page();

 private:
  // The swap file where pages are stored
  fstream swap_file_;

  // The number of pages that can be stored
  // in the PageTable at one time.
  size_t capacity_;

  // TODO: add fields
  size_t page_num;

  // a vector to store pages in physical memory
  std::list&amp;lt;std::pair&amp;lt;pno_t,Page*&amp;gt;&amp;gt; page_list;

  // use an unordered_map to quickly determined the corresponding page
  std::unordered_map&amp;lt;pno_t,Page*&amp;gt; mp;
&amp;#125;;

&amp;#125;


#endif  // PAGE_TABLE_H_
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;PageTable-cc实现&#34;&gt;&lt;a href=&#34;#PageTable-cc实现&#34; class=&#34;headerlink&#34; title=&#34;PageTable.cc实现&#34;&gt;&lt;/a&gt;&lt;code&gt;PageTable.cc&lt;/code&gt;实现&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#include &amp;quot;./PageTable.h&amp;quot;
#include &amp;quot;./Page.h&amp;quot;

namespace simplevm &amp;#123;
  // TODO: implment PageTable member functions
  // Constructs a new page table with the specified
  // swap file and the specified page capacity, which is
  // the number of pages that can be held in memory
  // at one time. There cannot be more than page_capacity
  // number of pages loaded in at a time.
  //
  // Arguments:
  //   - swap_file_name: the name of the swap_file
  //   - page_capacity: the maximum number of pages that can be held
  //     in memory at one time.
  PageTable::PageTable(std::string swap_file_name, size_t page_capacity) &amp;#123;
    swap_file_.open(swap_file_name);
    this-&amp;gt;capacity_ = page_capacity;
    this-&amp;gt;page_num = 0;
  &amp;#125;

  // Destructs the page table, freeing any allocated resources
  // and flushing any pages currently loaded into memory that
  // are dirty
  PageTable::~PageTable() &amp;#123;
    while(page_num &amp;gt; 0) &amp;#123;
        Page* deleted_page = page_list.back().second;
        page_list.pop_back();
        deleted_page-&amp;gt;~Page();
        page_num -= 1;
    &amp;#125;
    mp.clear();
    page_list.clear();
  &amp;#125;

  // Given a virtual address, gets the associated
  // page for that virtual address. This page will
  // be &amp;quot;loaded&amp;quot; into physical memory by the time it
  // is returned.
  //
  // There are three possiblities when a page is requested:
  // 1. The page is currently in the &amp;quot;loaded&amp;quot; and in the cache.
  //    In this case, a reference to the page is returned and
  //    and the page is marked as most recently used in the cache
  // 2. The page is not currently &amp;quot;loaded&amp;quot;, and the PageTable
  //    has not reached its page capacity:
  //    In this case, the page is loaded from the swap file and added
  //    to the cache as the most recently used page.
  // 3. The page is not currently &amp;quot;loaded&amp;quot;, and the PageTable
  //    is at page capacity:
  //    The least recently used page in the cache is evicted from the
  //    cache. Afterwards the requested page is loaded from the swap file
  //    and added to the cache as the most recently used page.
  //
  // NOTE: What decides how recntly used a page was used is entirely
  // decided by how recntly it was returned by a call to get_page.
  //
  // Arguments:
  //   - virtual_address: A virtual address that is associated
  //     with a requested page. The virutal address is represented
  //     as a unsigned 32 bit integer. NOTE: a virtual address
  //     is NOT the same as a page number. Multiple virtual addresses
  //     could be associated with the same page number.
  //
  // Returns:
  //   - the requested page, which is loaded into the cache and
  //     marked as the most recently used page
  Page&amp;amp; PageTable::get_page(uint32_t virtual_address) &amp;#123;
    // obtain the virtual_pno according to the virtual address
    pno_t pno = virtual_address / Page::PAGE_SIZE;
    if(page_available(pno)) &amp;#123;
        Page* p = mp[pno];
        page_list.remove(std::make_pair(pno,p));
        page_list.push_front(std::make_pair(pno,p));
        return *p;
    &amp;#125;
    else &amp;#123;
        Page* pg = new Page(swap_file_,pno);

        if(page_num &amp;lt; capacity_) &amp;#123;
            page_list.push_front(std::make_pair(pno,pg));
            flush_page(pno);
            page_num += 1;
        &amp;#125;
        else &amp;#123;
            // LRU Algorithms
            // evict the oldest page, and flush it
            evict_page();
            // add the new page to the front of the list
            page_list.push_front(std::make_pair(pno,pg));
            page_num += 1;
        &amp;#125;
        mp[pno] = pg;
        return *(mp[pno]);
    &amp;#125;
  &amp;#125;

  // Returns the page capacity of the page table
  //
  // Arguments: None
  //
  // Returns: the page capacity of the page table
  size_t PageTable::capacity() &amp;#123;
    return capacity_;
  &amp;#125;

  // Returns the number of pages currently loaded into &amp;quot;physical memory&amp;quot;
  //
  // Arguments: None
  //
  // Returns: the number of pages currently loaded into &amp;quot;physical memory&amp;quot;
  size_t PageTable::loaded_pages() &amp;#123;
    return page_num;
  &amp;#125;

  // Checks to see if the specified page is loaded into memory
  //
  // Arguments: The virtual page number of the page to check for
  //
  // Returns: True iff the page is loaded into memory, false otherwise
  bool PageTable::page_available(pno_t virtual_pno) &amp;#123;
    return mp.find(virtual_pno) != mp.end();
  &amp;#125;

  // Makes sure that all currently loaded pages are flushed
  // meaning tha the page contents are updated on the swap file.
  // This should not affect how recently used each page is and all pages
  // will remain loaded into memory after this operation is performed.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void PageTable::flush_all_pages() &amp;#123;
    for(auto p:page_list) &amp;#123;
        p.second-&amp;gt;flush();
    &amp;#125;
  &amp;#125;

  // Flushes the specified page to the swap file.
  // This should not affect how recently used each page is and all pages
  // will remain loaded into memory after this operation is performed.
  //
  // Arguments: the virtual page number of the page to flush
  //
  // Returns: Nothing
  void PageTable::flush_page(pno_t virtual_pno) &amp;#123;
    if(page_available(virtual_pno))&amp;#123;
        Page* p = mp.find(virtual_pno)-&amp;gt;second;
        p-&amp;gt;flush();
    &amp;#125;
  &amp;#125;

  // Discards the specified page from the PageTable.
  // If the page is dirty, then it is flushed before it is discarded.
  // If the page is not in the table, then nothing happens.
  //
  // Arguments: the virtual page number of the page to discard.
  //
  // Returns: Nothing
  void PageTable::discard_page(pno_t virtual_pno) &amp;#123;
    if(page_available(virtual_pno))&amp;#123;
        Page* p = mp.find(virtual_pno)-&amp;gt;second;
        p-&amp;gt;flush();
        page_list.remove(std::make_pair(virtual_pno,p));
        mp.erase(virtual_pno);
        page_num -= 1;
    &amp;#125;
  &amp;#125;

  // Evicts a page from the PageTable. The page evicted
  // should be the least recntly used page in the cache.
  // If the evicted page is dirty, then it is flushed before it is evicted.
  // If there are no pages in the cache, then do nothing.
  //
  // Arguments: None
  //
  // Returns: Nothing
  void PageTable::evict_page() &amp;#123;
    pno_t current_pno = page_list.back().first;
    Page* p = page_list.back().second;
    // find the value in unordered_map
    for(auto it = mp.begin(); it != mp.end(); it++) &amp;#123;
        if(it-&amp;gt;first == current_pno &amp;amp;&amp;amp; it-&amp;gt;second == p) &amp;#123;
            mp.erase(it);
            break;
        &amp;#125;
    &amp;#125;
    page_list.pop_back();
    p-&amp;gt;flush();
    page_num -= 1;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>
