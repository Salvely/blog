{
    "version": "https://jsonfeed.org/version/1",
    "title": "望春风 • All posts by \"c++\" tag",
    "description": "计算机&数理&文学爱好者，喜欢健身、下厨、听音乐和看电影",
    "home_page_url": "https://salvely.github.io/blog",
    "items": [
        {
            "id": "https://salvely.github.io/blog/2023/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/",
            "url": "https://salvely.github.io/blog/2023/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/",
            "title": "C++编译与工程构建",
            "date_published": "2023-10-27T09:45:08.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>我们在课程中写的都是代码量不大的小文件，但是在实际工程开发中，情况可就不一样了。但是那么多的代码，我们不可能将它们放在同一个文件中，肯定要分成不同的源文件。但是如何分解程序？如何实现程序之间的交流，就成了一个问题。本节中我们将探讨如何将一个大的工程分成不同的源程序，并且实现这些源程序之间的交流。我们首先介绍 C++ 的编译模型，也就是 C++ 源程序是如何编译成为机器可理解的二进制代码的。然后，我们讨论如何将一个大的工程分解为多个小的源程序，并且实现他们之间的交流。最后，我们探讨 C++ 的预处理器的工作模式。</p>\n<h1 id=\"c-编译模型\"><a class=\"markdownIt-Anchor\" href=\"#c-编译模型\">#</a> C++ 编译模型</h1>\n<p>C++ 是一种编译型的语言，即通过编译器将源代码转化为机器可以理解的二进制代码。其编译过程分为 3 个阶段：</p>\n<ul>\n<li>预处理阶段：扩展头文件，进行宏替换等</li>\n<li>编译阶段：将预处理后的高级语言代码转化为机器可以理解的二进制代码，即目标文件。在这个阶段，编译器会检查一些语法错误，如漏掉了 <code>;</code>  等</li>\n<li>链接阶段：将生成的多个目标文件合并成一个最终的可执行文件</li>\n</ul>\n<p>语法错误主要集中在编译阶段进行检查，而程序的一些其他问题则多半是出现在链接阶段。例如，程序可能定义了一个函数的原型，并且对他进行了调用，但是却没有实现这个函数。又或者，定义的函数原型和实现不一样，按照函数原型进行调用以后，程序找不到函数的实现。有的人会奇怪为什么这种错误会出现在链接阶段，是因为链接器没有在这个文件中找到函数原型时，他会本能的想到是不是在需要链接的其他文件中。如果在其他文件中也没有找到的话，链接器才会告诉你出现了链接错误。</p>\n<h1 id=\"模块化与分解\"><a class=\"markdownIt-Anchor\" href=\"#模块化与分解\">#</a> 模块化与分解</h1>\n<p>通常来说，对于一个大的工程问题，我们无法一口气思考到所有的细节。而在这种情况下，我们倾向于将问题分解成不同的模块，然后通过不同模块间的合作和交流来解决。但是，如何确定模块划分的粒度呢？毕竟越往下分，细节就越多。而在这个时候，我们会选择使用一些抽象的接口。举个例子，我们无需设计 C++ STL，只需要调用其提供给我们的接口，便可以实现多种功能。而这就是模块划分的尽头。<br>\n对于模块化，通常来说遵循 3 个原则：</p>\n<ul>\n<li>简单化：提供一个较为简单的接口</li>\n<li>可扩展：在需要的时候，我们可以在不改变接口的条件下改变其实现方式。</li>\n<li>可复用：接口足够泛用（使用泛型，模板之类），可以保证函数可以被用在多个不同的项目中</li>\n</ul>\n<h1 id=\"c-预处理器\"><a class=\"markdownIt-Anchor\" href=\"#c-预处理器\">#</a> C++ 预处理器</h1>\n<h2 id=\"前言-2\"><a class=\"markdownIt-Anchor\" href=\"#前言-2\">#</a> 前言</h2>\n<p>在编写 C++ 程序时，我们通常把一个程序分为 <code>file.h</code>  和 <code>file.cpp</code>  两个部分。 <code>file.h</code>  中描述的是程序提供的类及函数接口（定义），而 <code>.cpp</code>  文件中描述的是其实现。此外，通常在 <code>.h</code>  文件的前后，会加上如下内容：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">StrUtils_Included</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">StrUtils_Included</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>string <span class=\"token function\">ConvertToUpperCase</span><span class=\"token punctuation\">(</span>string input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>string <span class=\"token function\">ConvertToLowerCase</span><span class=\"token punctuation\">(</span>string input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>string <span class=\"token function\">IntegerToString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>string <span class=\"token function\">DoubleToString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr></table></figure><h2 id=\"include头文件\"><a class=\"markdownIt-Anchor\" href=\"#include头文件\">#</a>  <code>include</code>  头文件</h2>\n<p>其作用在于将头文件的内容复制到 <code>#include</code>  处。头文件分为两种，一种用 <code>&lt;&gt;</code>  包起，是 C++ 标准库中的文件；而另外一种用 <code>&quot;&quot;</code>  包起，是用户自定义的头文件，编译器会在当前工程文件夹下找。</p>\n<h2 id=\"define定义与替换\"><a class=\"markdownIt-Anchor\" href=\"#define定义与替换\">#</a>  <code>define</code>  定义与替换</h2>\n<p>宏定义的基本格式是 <code>define val replacement</code> 。在进行宏替换时，做的不是值替换，而是普通的字符串的替换。即将程序中所有的 <code>val</code>  都替换成 <code>replacement</code> 。在进行宏替换时编译器并不理解这到底是什么东西，就是简单的左无脑替换。因此在替换时必须要注意，譬如：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">a</span> <span class=\"token expression\"><span class=\"token number\">5</span> <span class=\"token operator\">+</span> <span class=\"token number\">10</span></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> a<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在进行宏替换后，效果如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token number\">5</span> <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>而不是:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5</span> <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>因为它做的仅仅是简单的字符串替换。这种错误经常发生，而要避免这类错误的方法是：</p>\n<ol>\n<li>在 <code>define</code>  时使用 <code>()</code>  圆括号</li>\n<li>使用 <code>const</code>  语句</li>\n</ol>\n<h2 id=\"include-guard\"><a class=\"markdownIt-Anchor\" href=\"#include-guard\">#</a>  <code>include guard</code></h2>\n<p>预处理语句可以通过条件判断来决定是否要定义某些文件，一个简单的格式如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ifndef<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>define<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>endif</pre></td></tr></table></figure><p>这套语句的基本意思是：如果已经 <code>#include</code>  过上述文件，就不需要再定义一次了。C++ 工程文件之间相互 <code>#include</code>  是家常便饭，这样做是为了防止由于多次互相 <code>#include</code>  带来的重定义问题。上述语句只是一个较为简化的版本，更为完整的定义是：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\">statement</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">elif</span> <span class=\"token expression\">another<span class=\"token operator\">-</span>statement</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">elif</span> <span class=\"token expression\">yet<span class=\"token operator\">-</span>another<span class=\"token operator\">-</span>statement</span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr></table></figure><p>这其中的 <code>statement</code>  可以是条件判断语句，也可以是 <code>define()</code>  语句。做条件判断时，使用的必须是已经定义过的变量，如：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\">MY_CONSTANT <span class=\"token operator\">></span> <span class=\"token number\">137</span> </span><span class=\"token comment\">// Legal</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\">MY_CONSTANT <span class=\"token operator\">*</span> <span class=\"token number\">42</span> <span class=\"token operator\">==</span> MY_CONSTANT </span><span class=\"token comment\">// Legal</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\"><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span>MY_CONSTANT<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span> </span><span class=\"token comment\">// Illegal, cannot call function sqrt</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\">MY_CONSTANT <span class=\"token operator\">==</span> <span class=\"token number\">3.14</span> </span><span class=\"token comment\">// Illegal, can only use integral values</span></span></pre></td></tr></table></figure><p>而使用 <code>define</code>  语句时，如果变量已经定义，则 <code>define()</code>  返回 <code>true</code> ，否则返回 <code>false</code> 。例如：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\"><span class=\"token function\">defined</span><span class=\"token punctuation\">(</span>MY_CONSTANT<span class=\"token punctuation\">)</span> </span><span class=\"token comment\">// Evaluates to true.</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\"><span class=\"token function\">defined</span><span class=\"token punctuation\">(</span>OTHER_CONSTANT<span class=\"token punctuation\">)</span> </span><span class=\"token comment\">// Evaluates to false.</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\"><span class=\"token operator\">!</span><span class=\"token function\">defined</span><span class=\"token punctuation\">(</span>MY_CONSTANT<span class=\"token punctuation\">)</span> </span><span class=\"token comment\">// Evaluates to false.</span></span></pre></td></tr></table></figure><p>其判断结果被应用在 <code>if</code>  语句中。例如：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\"><span class=\"token function\">defined</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"A is defined.\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">elif</span> <span class=\"token expression\"><span class=\"token function\">defined</span><span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"B is defined.\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">elif</span> <span class=\"token expression\"><span class=\"token function\">defined</span><span class=\"token punctuation\">(</span>C<span class=\"token punctuation\">)</span></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre> \tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"C is defined.\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"None of A, B, or C is defined.\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr></table></figure><p>这套语句的效果相当于将所有 <code>include</code>  的内容复制粘贴到源程序中，但是注释掉重复定义的部分。它和注释不一样之处在于，这套语句可以嵌套，而注释不能。</p>\n<h2 id=\"宏\"><a class=\"markdownIt-Anchor\" href=\"#宏\">#</a> 宏</h2>\n<h2 id=\"内联函数\"><a class=\"markdownIt-Anchor\" href=\"#内联函数\">#</a> 内联函数</h2>\n",
            "tags": [
                "C++",
                "CMake",
                "Makefile"
            ]
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/",
            "url": "https://salvely.github.io/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/",
            "title": "C++参考资料",
            "date_published": "2023-10-22T08:47:56.000Z",
            "content_html": "<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pc29jcHAuZ2l0aHViLmlvL0NwcENvcmVHdWlkZWxpbmVzL0NwcENvcmVHdWlkZWxpbmVz\">C++ Core Guidelines</span></li>\n<li></li>\n</ul>\n",
            "tags": [
                "C++",
                "参考资料"
            ]
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/CS106L/",
            "url": "https://salvely.github.io/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/CS106L/",
            "title": "Stanford CS106L:Standard C++ Programming",
            "date_published": "2023-10-22T03:36:26.000Z",
            "content_html": "<h1 id=\"课程资料\"><a class=\"markdownIt-Anchor\" href=\"#课程资料\">#</a> 课程资料</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUs4NDExYjdBVS8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT04NWFjZjBhNTlkZWQwMmU0Yzc1YWUxMTU4YmFjYTIwNw==\">Video</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2FyY2hpdmUvY3MvY3MxMDZsL2NzMTA2bC4xMjI0Lw==\">Slides/Code</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2NzMTA2bC9mdWxsX2NvdXJzZV9yZWFkZXIucGRm\">Course Reader</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2NzMTA2bC9hc3NpZ25tZW50LXNldHVw\">Assignment</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29yZ3MvY291cnNld29ya3MvcmVwb3NpdG9yaWVzP3E9QVAxNDAxLTImYW1wO3R5cGU9YWxsJmFtcDtsYW5ndWFnZT0mYW1wO3NvcnQ9\">AP1401-2</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2FyY2hpdmUvY3MvY3MxMDZsL2NzMTA2bC4xMjEyLw==\">Spring 2021 资料</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2NzMTA2bC9sZWN0dXJlcy8=\">综合资料</span></li>\n</ul>\n<h1 id=\"学习流程\"><a class=\"markdownIt-Anchor\" href=\"#学习流程\">#</a> 学习流程</h1>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">17</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token number\">1.</span> 阅读 Course Reader对应章节</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token number\">2.</span> 观看video</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token number\">3.</span> 阅读Slides</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token number\">4.</span> 整理Code</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>以上流程完成后：</p>\n<ol>\n<li>完成 CS106L 所有 Assignment</li>\n<li>完成 AP1401-2 所有作业</li>\n</ol>\n<h1 id=\"welcome\"><a class=\"markdownIt-Anchor\" href=\"#welcome\">#</a> Welcome</h1>\n<p>本节课主要讲述了 C++ 的应用前景，历史发展和设计哲学。</p>\n<h2 id=\"c应用前景\"><a class=\"markdownIt-Anchor\" href=\"#c应用前景\">#</a> C++ 应用前景</h2>\n<p><img data-src=\"future.png\" alt=\"C++应用前景\"></p>\n<h2 id=\"c的历史\"><a class=\"markdownIt-Anchor\" href=\"#c的历史\">#</a> C++ 的历史</h2>\n<h3 id=\"汇编语言\"><a class=\"markdownIt-Anchor\" href=\"#汇编语言\">#</a> 汇编语言</h3>\n<p>在早期阶段，尚没有高级语言这一说。程序员大多使用汇编语言编写程序，汇编语言的好处在于：</p>\n<ul>\n<li>使用较为简单的指令进行编程</li>\n<li>汇编语言执行速度较快</li>\n<li>程序员可以直接操作计算机底层寄存器等</li>\n</ul>\n<p>但是，汇编语言编程也有它的缺陷，缺陷就在于：</p>\n<ul>\n<li>程序涉及到对计算机底层硬件的基础操作，而不只是处理逻辑，因此对其他程序员来说，阅读起来较为困难</li>\n<li>因为汇编语言涉及到指令集架构，而指令集架构和计算机底层硬件和操作系统紧密相关，因此在一台机器上运行的程序可能无法迁移到另一台程序，简单来说就是可移植性较差</li>\n<li>汇编语言编写的程序因为使用的是一些基本的操作，因此程序较长</li>\n</ul>\n<p>因此， <code>Ken Thompson</code>  和 <code>Dennis Ritchie</code>  于 1972 年发明了 C 语言。</p>\n<h3 id=\"c-语言\"><a class=\"markdownIt-Anchor\" href=\"#c-语言\">#</a> C 语言</h3>\n<p>C 语言是一门高级语言，相较汇编，它的优势在于：</p>\n<ul>\n<li>面向过程编程，较为简单。程序员在编写程序时，无需考虑计算机底层架构，而只需要考虑处理逻辑，因此编程较为简单</li>\n<li>C 语言可以由编译器编译为汇编指令，在不同的机器上，可以编译出不同的汇编指令，而后汇编器又可以将汇编指令转化为针对该计算机指令集架构的机器指令，实现 C 语言的可迁移性</li>\n<li>C 语言程序执行速度非常快</li>\n</ul>\n<p>然而，在面对更复杂的编程问题时，C 语言也表现出了它的不足：</p>\n<ul>\n<li>C 语言是面向过程的语言，它无法面向对象。当我们需要更复杂的结构和它的一系列方法时，C 语言只为我们提供了一些有限的结构，无法满足我们对高级结构的需求</li>\n<li>C 语言无法对不同类型提供一个泛化的模板，对于不同类型的传入参数，我们可能需要重复写多个几乎一致的处理函数</li>\n<li>写大型项目时，很多时候很难将一个问题拆解为一个面向过程的模型，不是所有问题都可以使用模块化的过程方法解决</li>\n<li>写出来的程序较长</li>\n</ul>\n<h3 id=\"c\"><a class=\"markdownIt-Anchor\" href=\"#c\">#</a> C++</h3>\n<p>针对 C 语言的问题， <code>Bjarne Stroustrup</code>  于 1983 年开发了 C++ 语言，他希望能够在 C 语言基础上实现一个具有多种不同特性的高级语言。 C++ 语言一开始只是 <code>C with classes</code> ，实现了 C 语言面向对象的延伸。而后逐步发展，直到今天的 <code>C++23</code> 。</p>\n<p><img data-src=\"evolution.png\" alt=\"C++的演化\"></p>\n<h2 id=\"c的几大特性\"><a class=\"markdownIt-Anchor\" href=\"#c的几大特性\">#</a> C++ 的几大特性</h2>\n<ul>\n<li>通用语言<br>\n有的语言可以在应用到多个场景中，但是在解决特定场景问题时会显得复杂，比如 C++ 在做矩阵乘除法时，需要程序员手动编写程序，效率较低。但是 C++ 的用途很广。而有的语言，可以解决特定问题，但是并不泛用。比如 Matlab 在做科学计算时非常的常用，但是在解决其他问题时并没有 C++ 高效。</li>\n<li>编译型语言<br>\n高级语言需要转换成机器可以阅读的二进制码才能被计算机执行。而高级语言分为编译型和解释型。其区别在于，解释型语言使用解释器 (Interpreters) 进行翻译，一边翻译一边执行。解释器在执行一条语句的同时，获取下一条语句。而编译型语言使用编译器进行编译。将整个源代码编译完成后，直接执行生成的二进制码。</li>\n<li>静态类型语言<br>\n静态类型语言是指语句中的每个变量在声明后都有固定的类型，一旦确定，不能随意更改。而动态类型（如 Python、Javascript）会在执行的过程中动态的判断变量的类型。静态类型语言会在编译阶段检查语句是否合法，否则产生编译错误。而动态类型通常无法在编译阶段确定该语句是否有编译错误，错误均在程序运行时产生，也称为运行时错误。编译阶段排错让运行时错误出现的概率大大降低。这样无需运行即可排除程序错误。</li>\n<li>多范式语言<br>\n部分语言只有单一范式，如 C 语言，无法编写面向对象程序。而 C++ 可以同时实现面向对象特性，泛型特性，和面向过程的特性。非常灵活。</li>\n<li>中间语言<br>\n部分底层语言（如汇编）直接和计算机内存打交道，但是利用其写出的程序逻辑不清晰，难以理解。而部分语言无法直接对计算机底层进行操纵（如 Python、Java) 等，程序员在编写程序时就像是被禁锢，无法探索底层的奥秘。C++ 可以像 C 语言那样接触底层硬件（利用指针），也可以利用其面向对象特性构造大型程序，同时实现封装和抽象。触及底层系统和实现抽象的目的同时达到，非常便于程序员大展身手。</li>\n</ul>\n<h2 id=\"c的设计哲学\"><a class=\"markdownIt-Anchor\" href=\"#c的设计哲学\">#</a> C++ 的设计哲学</h2>\n<ul>\n<li>只有在需要解决特定问题时引入新的特性</li>\n<li>程序员可以自由选择编程风格</li>\n<li>隐藏实现细节，抽象出编程接口</li>\n<li>让程序员能够完全以自己想要的方式编写程序</li>\n<li>让编写的程序尽可能高效</li>\n<li>编译时进行类型检查</li>\n<li>可以兼容早期版本程序，也兼容 C 语言程序</li>\n</ul>\n<h2 id=\"c的应用\"><a class=\"markdownIt-Anchor\" href=\"#c的应用\">#</a> C++ 的应用</h2>\n<ul>\n<li>浏览器</li>\n<li>JVM</li>\n<li>火星探索车</li>\n<li>等等</li>\n</ul>\n<h1 id=\"type-and-structs\"><a class=\"markdownIt-Anchor\" href=\"#type-and-structs\">#</a> Type and Structs</h1>\n<p>关于类型和结构体没什么好说的，主要的用法和 C 语言中差不多。但是 <code>string</code>  类在使用之前需要在程序最开始处 <code>#include&lt;string&gt;</code> ，并且最好是不要使用 <code>using namespace std</code> ，而是使用 <code>std::string</code> ，对于 <code>std::cout</code>  和 <code>std::cin</code>  也是一样。这样做是为了保证程序员在自主开发时，不和 <code>std</code>  域内的的东西重名导致出错。</p>\n<h2 id=\"stdpair\"><a class=\"markdownIt-Anchor\" href=\"#stdpair\">#</a>  <code>std::pair</code></h2>\n<p>一种 <code>STL</code>  内置结构，其中包括两个域。 <code>std::pair</code>  相当于是个模板，其中域的类型随意。声明时使用如下格式：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span>string<span class=\"token operator\">></span> p <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"st\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>此外，还可以在程序中使用如下方法构建 <code>std::pair</code> ：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span>string<span class=\"token operator\">></span> p <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"st\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在使用 <code>pair</code>  时，分别用 <code>p.first</code>  和 <code>p.second</code>  来引用两个域。</p>\n<h2 id=\"auto类型推导\"><a class=\"markdownIt-Anchor\" href=\"#auto类型推导\">#</a>  <code>auto</code>  类型推导</h2>\n<p>使用 <code>auto</code>  变量表示允许编译器自行推导值的类型。</p>\n<div class=\"note info\">\n<p>什么时候使用 <code>auto</code> ？</p>\n<ul>\n<li>使用迭代器时，我不关心值的类型</li>\n<li>使用模板时，值的类型已经可以根据上下文推断出来</li>\n<li>使用 <code>lambda</code>  时，咱不知道值是啥类型</li>\n<li>没那个必要时，尽量不要将 <code>auto</code>  作为返回值类型</li>\n</ul>\n</div>\n<h1 id=\"streams\"><a class=\"markdownIt-Anchor\" href=\"#streams\">#</a> Streams</h1>\n<blockquote>\n<p>How can we convert between string-represented data and the real thing? Streams!</p>\n</blockquote>\n<p>本节首先介绍了什么是环境，而后引入 <code>Stream</code>  的概念，讲解了 <code>Streams</code>  在读入和写出数据时的一些特点。而 <code>Streams</code>  可以利用 <code>cin</code>  和 <code>cout</code>  这两种 <code>iostream</code>  类的对象，实现从标准输入和控制台进行读取。也可以通过 <code>ifstream</code>  和 <code>ofstream</code>  两种来实现文件的读取和写入。亦可以通过 <code>istringstrean</code>  和 <code>ostringstream</code>  来实现字符串和其他类型之间的连接。但是普通的 <code>cin</code>  和 <code>cout</code>  在使用时也可能出现读取的问题，因此我们还可以使用 <code>std::getline()</code>  来进行一行一次的读取。此外，在使用 <code>Stream</code>  时，还应该注意判别读取异常和写入异常。</p>\n<h2 id=\"streams-overview\"><a class=\"markdownIt-Anchor\" href=\"#streams-overview\">#</a> Streams Overview</h2>\n<h3 id=\"environment\"><a class=\"markdownIt-Anchor\" href=\"#environment\">#</a> Environment</h3>\n<p>在学习 Stream 之前，我们先要了解 <code>Environment</code> （环境）的概念。我们家里有温度计，我们通常通过温度计上的水银球去检测环境温度，然后将摄氏度显示在数轴上，人们通过观测数轴上的数字来查看当前温度。在这个例子中，外界就是环境，水银球就是将温度转化为实际示数的媒介，而数轴就是温度的输出，将温度显示出来供人们了解。而在程序编写的过程中，也可能存在一个外部环境，程序需要从这个环境获取信息，然后在利用一些处理逻辑来进行一些计算，最后返回输出或者将输出打印在屏幕上。这个环境可能是用户输入，也可能是外部文件，还有可能是其他程序。</p>\n<h3 id=\"stream-是什么\"><a class=\"markdownIt-Anchor\" href=\"#stream-是什么\">#</a> Stream 是什么</h3>\n<blockquote>\n<p>Streams is an abstraction for input and output. Streams convert between data and the string representation of data.</p>\n</blockquote>\n<p>Stream 是程序与外部环境交流的媒介。Stream 的输入与输出可能来自用户，也可能来自程序，也可能来自其他文件。如果要将一个变量输出到终端，那么变量就会以字符串的形式打入 Stream，然后 Stream 将其输出到终端。如果要从用户输入读取数据，那么也是将用户输入转化为字符串存储在 Stream 中，然后再将其转储到变量中。</p>\n<h3 id=\"stream-特点\"><a class=\"markdownIt-Anchor\" href=\"#stream-特点\">#</a> Stream 特点</h3>\n<ul>\n<li>可以对大体积数据进行分片读取，然后存储</li>\n<li>可以读取多个类型的数据</li>\n<li>可以串联多个 <code>&lt;&lt;</code>  读取</li>\n</ul>\n<h2 id=\"cin-与-cout来自键盘去往终端\"><a class=\"markdownIt-Anchor\" href=\"#cin-与-cout来自键盘去往终端\">#</a> cin 与 cout：来自键盘，去往终端</h2>\n<p><code>cout</code>  为 Stream 对象，它从变量中获取数据，存储到一个 Buffer 中，然后将其<strong>输出到终端上</strong>。<br>\n <code>cin</code>  也是 Stream 对象，它从<strong>用户输入</strong>获取值，存储到一个 Buffer 中，然后将其转储到对应类型的变量中。<br>\n在使用这两个输入流前，需要在程序开始处 <code>#include &lt;iostream&gt;</code></p>\n<h2 id=\"ifstream-与-ofstream来自文件去往文件\"><a class=\"markdownIt-Anchor\" href=\"#ifstream-与-ofstream来自文件去往文件\">#</a> ifstream 与 ofstream：来自文件，去往文件</h2>\n<div class=\"note info\">\n<p>问题思考：</p>\n<ol>\n<li><code>ifstream</code>  和 <code>ofstream</code>  分别是什么？</li>\n<li>还有什么特殊的读写文件类？特殊在哪？</li>\n<li><code>i/ofstream</code>  和 <code>cin/cout</code>  在使用上有什么不一样之处？</li>\n<li>使用 <code>ifstream</code>  和 <code>ofstream</code>  需要包含什么头文件？</li>\n<li><code>ifstream</code>  怎么初始化？初始化后需要做哪些检查？</li>\n<li><code>ofstream</code>  怎么初始化？初始化后需要做哪些检查？</li>\n<li>如果传入的文件名是 <code>string</code>  类型，如何处理？</li>\n<li><code>close()</code>  时有哪些需要注意的地方？</li>\n</ol>\n</div>\n<h3 id=\"ifstream-ofstream-overview\"><a class=\"markdownIt-Anchor\" href=\"#ifstream-ofstream-overview\">#</a> ifstream &amp; ofstream Overview</h3>\n<p><code>ifstream</code>  和 <code>ofstream</code>  分别从文件读取和写入文件。此外，还有一个叫做 <code>fstream</code>  的类型，即可以完成写入，又可以完成读取）。此外， <code>ifstream</code>  和 <code>ofstream</code>  在使用上与 <code>cin/cout</code>  不一样之处在于， <code>ifstream</code>  和 <code>ofstream</code>  是一个类型，而不是一个对象，但是 <code>cin</code>  及 <code>cout</code>  分别是 <code>std::istream</code>  和 <code>std::ostream</code>  类的对象。在使用对象的方法时 ( <code>&lt;&lt;</code>  和 <code>&gt;&gt;</code>  已被重载) 可以直接调用，但是在使用一个类的方法时，首先需要初始化这个类的一个对象，然后再对其方法进行调用。</p>\n<h3 id=\"ifstream-ofstream-使用说明\"><a class=\"markdownIt-Anchor\" href=\"#ifstream-ofstream-使用说明\">#</a> ifstream &amp; ofstream 使用说明</h3>\n<h4 id=\"包含头文件\"><a class=\"markdownIt-Anchor\" href=\"#包含头文件\">#</a> 包含头文件</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;fstream></span></span></pre></td></tr></table></figure><h4 id=\"ifstream-初始化-使用\"><a class=\"markdownIt-Anchor\" href=\"#ifstream-初始化-使用\">#</a> ifstream 初始化 &amp; 使用</h4>\n<p>可以直接使用构造函数，在参数列表中填入文件名进行初始化：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ifstream <span class=\"token function\">myStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>也可以在使用默认构造函数初始化后，利用类的 <code>open()</code>  方法打开文件：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ifstream myStream<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>myStream<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>使用 <code>ifstream</code>  对象的方法与使用 <code>cin</code>  相似，如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>myStream <span class=\"token operator\">>></span> myInteger</pre></td></tr></table></figure><p>注意，在 <code>open()</code>  方法调用后，推荐使用 <code>myStream.is_open()</code>  来探测是否真的成功打开了文件。</p>\n<h4 id=\"ofstream-初始化-使用\"><a class=\"markdownIt-Anchor\" href=\"#ofstream-初始化-使用\">#</a> ofstream 初始化 &amp; 使用</h4>\n<p><code>ofstream</code>  初始化过程及使用过程与前文 <code>ifstream</code>  相似。若文件不存在，调用 <code>open()</code>  方法会新创建一个文件，否则会覆盖原有的同名文件。（所以尽量做好备份）</p>\n<h4 id=\"关闭流close\"><a class=\"markdownIt-Anchor\" href=\"#关闭流close\">#</a> 关闭流： <code>close()</code></h4>\n<ol>\n<li>当流的生命周期结束时，C++ 会为你自动关闭流</li>\n<li>你也可以手动使用 <code>close()</code>  方法关闭流</li>\n</ol>\n<h4 id=\"使用-string-作为文件名时\"><a class=\"markdownIt-Anchor\" href=\"#使用-string-作为文件名时\">#</a> 使用 string 作为文件名时…</h4>\n<p>注意， <code>string</code>  类的开发时间要晚于 <code>ifstream</code>  和 <code>ofstream</code> ，彼时 <code>ifstream</code>  和 <code>ofstream</code>  只接受 C 语言的字符串类型。因此，要将一个 <code>string</code>  类型的文件名传入这两个类的对象，我们必须调用 <code>.c_str()</code>  来将其转化为 C 语言格式的字符串。</p>\n<h2 id=\"stream-manipulators\"><a class=\"markdownIt-Anchor\" href=\"#stream-manipulators\">#</a> Stream manipulators</h2>\n<p><code>stream manipulator</code>  可以让对变量及输出的处理更加方便，程序员无需手动编程实现一些较为繁琐的功能。几种常用的 <code>stream manipulator</code>  如下：</p>\n<ol>\n<li><code>endl</code> : 输出后换行</li>\n<li><code>setw</code> : 设置输出的宽度</li>\n<li><code>left/right</code> : 通常与 <code>setw</code>  连用，表示左补空格 / 右补空格</li>\n<li><code>setfill</code> : 在宽度一定，文字没有填满处补充特定的占位符</li>\n<li><code>boolalpha</code> : 用 <code>true/false</code>  表示 <code>1/0</code></li>\n<li><code>hex</code> : 将输入输出理解为 16 进制</li>\n<li><code>dec</code> : 输入输出为 10 进制</li>\n<li><code>oct</code> : 输入输出为 8 进制</li>\n<li><code>ws</code> : 跳过所有的空格</li>\n</ol>\n<h2 id=\"stream-异常处理\"><a class=\"markdownIt-Anchor\" href=\"#stream-异常处理\">#</a> Stream 异常处理</h2>\n<p>在使用 <code>stream</code>  进行读取时，可能会出现读取异常的情况，比如读进来的值是个字符串，但是程序想把它保存到一个 <code>int</code>  类中，这样就产生了类型异常。我们需要在读取后使用 <code>cout.fail()</code>  或 <code>cin.fail()</code>  来判断读取是否成功，如果有异常，我们需要手动处理异常，然后用 <code>cin.clear()</code>  表达异常已经处理完毕。</p>\n<div class=\"note info\">\n<p>注意，在使用 <code>while</code>  循环进行读取时，尽量把异常判断放在 <code>while</code>  循环内，如果判断到异常则退出，否则就进行下一次读取。不要把 <code>while</code>  循环放在条件判断中，否则可能会导致读取异常后依然在进行输出，因此尽量使用如下的结构。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cin<span class=\"token punctuation\">.</span><span class=\"token function\">fail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>因为 <code>stream</code>  在读取到最后或读取错误时会返回 <code>false</code> ，而其他情况下会返回 <code>stream</code>  对象本身（也可以判断为 <code>true</code> ），因此我们可以使用 <code>cin &lt;&lt; intValue &lt;&lt; doubleValue</code>  之类的语句作为判断的条件，以简化上述的循环，结构如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cin <span class=\"token operator\">&lt;&lt;</span> intValue <span class=\"token operator\">&lt;&lt;</span> doubleVALUE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></div>\n<h2 id=\"stream-的麻烦之处\"><a class=\"markdownIt-Anchor\" href=\"#stream-的麻烦之处\">#</a> Stream 的麻烦之处</h2>\n<p>Stream 存在一个问题，如果用户多次连续读取值，而其中某一次读入的值的类型不匹配的话，则会连环影响到后面的读取。这其中的根本原因是， <code>stream</code>  本身是一个附带了一个读写头的 <code>buffer</code>  字符数组，而每次读取后，读写后都会向后移动，下一次读取的位置是上一次读取的位置 + 上一次读取的长度。比如说我们需要读取一个 <code>int</code> ，再读取一个 <code>string</code> 。上一次用户输入了 <code>8.265</code> , 那么第一次就只会读入 <code>8</code> ，下一次读取从 <code>.265</code>  开始，导致 <code>string</code>  读取出错。</p>\n<p>此外， <code>cin</code>  的特点是： <code>cin</code>  越过一切前导空格和换行符，在读入有效字符后，遇到空格或换行符就停止读取，见如下程序：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tstring name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tstring city<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tcin <span class=\"token operator\">>></span> name <span class=\"token operator\">>></span> city<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"My name is \"</span> <span class=\"token operator\">&lt;&lt;</span> name <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"The city is \"</span> <span class=\"token operator\">&lt;&lt;</span> city <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果输入的第一个 <code>name</code>  是 <code>First Last</code> ， <code>city</code>  输入的是 <code>Wuhan</code> 。由于 <code>cin</code>  遇到空格就停止读取，那么 <code>name</code>  中存储的值就是 <code>First</code> ， <code>city</code>  中存储的值就是 <code>Last</code> ，而 <code>Wuhan</code>  依然在 <code>buffer</code>  中无法读取。</p>\n<p>因此，要解决标准的 <code>stream</code>  带来的麻烦，我们引入一个新的函数： <code>getline()</code></p>\n<h2 id=\"用getline函数读取标准输入\"><a class=\"markdownIt-Anchor\" href=\"#用getline函数读取标准输入\">#</a> 用 <code>getline()</code>  函数读取标准输入</h2>\n<p><code>getline()</code>  可以将输入保存在 <code>string</code>  中。 <code>getline</code>  函数的用途在于，如同他的名字，它可以一次读取一行，而 <code>cin</code>  每次读到空格或换行符就停止。 <code>getline</code>  不会忽略空格，会将其一并读入，但是 <code>getline</code>  遇到换行符就停止读取，并且换行符依然留存在 <code>stream buffer</code>  中。因此 <code>getline</code>  非常适合那种用户需要在这个字符串中保留空格的情况。</p>\n<p>前文我们说过， <code>cin</code>  会在开始读取时越过一切前导的空格和换行符，读取有效字符后，遇到空格和换行符就停止读取，并且将其留在 <code>stream buffer</code>  中，以待下一次的读取。那么如果我们将 <code>cin</code>  和 <code>getline</code>  混用时，便会出现一些问题。</p>\n<p>参考如下示例：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> dummyInt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>string dummyString<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>cin <span class=\"token operator\">>></span> dummyInt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>cin<span class=\"token punctuation\">,</span>dummyString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>cin</code>  首先读入了一个数，然后<strong>将换行符留在了 <code>buffer</code>  中</strong>，但是下一次调用 <code>getline</code>  时， <code>getline</code>  遇到换行符就停止读取。导致读入的 <code>dummyString</code>  并不是我们下一次输入的字符串，而是一个空串。这都是因为上一个字符串的换行符还没有处理干净。<br>\n最好的解决办法是将这种原始的输入输出读取，改为调用封装好的功能完善的库函数。</p>\n<h2 id=\"用getline函数读取文件\"><a class=\"markdownIt-Anchor\" href=\"#用getline函数读取文件\">#</a> 用 <code>getline()</code>  函数读取文件</h2>\n<p>参考之前 <code>cin</code>  循环从文件读取的形式，我们可以编写一个使用 <code>getline</code>  循环读取文件的格式:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ifstream <span class=\"token function\">capitals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"capitals.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>string capital<span class=\"token punctuation\">,</span>country<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token comment\">// check if the file is correctly opened</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>capitals<span class=\"token punctuation\">,</span>capital<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">getlien</span><span class=\"token punctuation\">(</span>capitals<span class=\"token punctuation\">,</span>country<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"a-string-bufferstringstream\"><a class=\"markdownIt-Anchor\" href=\"#a-string-bufferstringstream\">#</a> A string buffer: <code>stringstream</code></h2>\n<div class=\"note info\">\n<p>有时候，我们想要连接字符串和数字，譬如 <code>&quot;I ate&quot; + 3 &quot;peaches today&quot;</code> ，可是 C++ 不允许我们拼接不一样类型的值，怎么办呢？<br>\n下面我们引入一个新的 <code>stream</code>  类： <code>stringstream</code> 。通过  <code>myStringStream &lt;&lt; &quot;I ate&quot; &lt;&lt; 3 &lt;&lt; &quot;peaches today&quot;</code> , 我们可以实现字符串和其他类型值的拼接。</p>\n</div>\n<p><code>stringstream</code>  是一个类似于 <code>cin</code>  和 <code>cout</code>  的 <code>stream</code> 。和 <code>ifstream/ofstream</code>  一样，在使用 <code>stringstream</code>  前，我们需要先初始化一个 <code>stringstream</code>  类的对象，然后再对这个对象进行读入和写出。 <code>stringstream</code>  和标准 <code>iostream</code>  的差别在于，其写入和写出的值并不保存在程序外，而是作为程序的一个变量，可以通过调用 <code>myStringStream.str()</code>  随时读取。</p>\n<div class=\"note info\">\n<p>在使用 <code>stringstream</code>  之前，需要引入头文件 <code>#include &lt;sstream&gt;</code></p>\n</div>\n<h1 id=\"initialization\"><a class=\"markdownIt-Anchor\" href=\"#initialization\">#</a> Initialization</h1>\n<h2 id=\"初始化结构体\"><a class=\"markdownIt-Anchor\" href=\"#初始化结构体\">#</a> 初始化结构体</h2>\n<h3 id=\"方法一用给每个字段赋值\"><a class=\"markdownIt-Anchor\" href=\"#方法一用给每个字段赋值\">#</a> 方法一：用 <code>.</code>  给每个字段赋值</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Student s<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> s<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Frankie\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre> s<span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token string\">\"MN\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> s<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">21</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"方法二用直接赋值\"><a class=\"markdownIt-Anchor\" href=\"#方法二用直接赋值\">#</a> 方法二：用 <code>&#123;&#125;</code>  直接赋值</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Student s <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"Frankie\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"MN\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">21</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"初始化stdpair\"><a class=\"markdownIt-Anchor\" href=\"#初始化stdpair\">#</a> 初始化 <code>std::pair</code></h2>\n<h3 id=\"方法一用给每个字段赋值-2\"><a class=\"markdownIt-Anchor\" href=\"#方法一用给每个字段赋值-2\">#</a> 方法一：用 <code>.</code>  给每个字段赋值</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> numSuffix1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"st\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"方法二用直接赋值-2\"><a class=\"markdownIt-Anchor\" href=\"#方法二用直接赋值-2\">#</a> 方法二：用 <code>&#123;&#125;</code>  直接赋值</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> numSuffix2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>numSuffix2<span class=\"token punctuation\">.</span>first <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>numSuffix2<span class=\"token punctuation\">.</span>second <span class=\"token operator\">=</span> <span class=\"token string\">\"nd\"</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"方法三调用stdmake_pairfield1field2方法\"><a class=\"markdownIt-Anchor\" href=\"#方法三调用stdmake_pairfield1field2方法\">#</a> 方法三：调用 <code>std::make_pair(field1,field2)</code>  方法</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> numSuffix2 <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"rd\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"初始化stdvector\"><a class=\"markdownIt-Anchor\" href=\"#初始化stdvector\">#</a> 初始化 <code>std::vector</code></h2>\n<h3 id=\"方法一使用直接赋值\"><a class=\"markdownIt-Anchor\" href=\"#方法一使用直接赋值\">#</a> 方法一：使用 <code>&#123;&#125;</code>  直接赋值</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// a = &#123;3,5&#125;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"方法二使用vector构造函数赋值\"><a class=\"markdownIt-Anchor\" href=\"#方法二使用vector构造函数赋值\">#</a> 方法二：使用 <code>vector()构造函数</code> 赋值</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><div class=\"note info\">\n<p>这种情况下，传入的 3 和 5 是构造函数的参数，3 是元素的个数，5 是重复的元素值， <code>a=&#123;5,5,5&#125;</code></p>\n</div>\n<h2 id=\"大括号初始化通用\"><a class=\"markdownIt-Anchor\" href=\"#大括号初始化通用\">#</a> 大括号初始化 (通用)</h2>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> vec<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> numSuffix1<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"st\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Student s<span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"Frankie\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"MN\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">21</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// less common/nice for primitive types, but possible!</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">&#123;</span><span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>string f<span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"Frankie\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"structure-bindings\"><a class=\"markdownIt-Anchor\" href=\"#structure-bindings\">#</a> Structure Bindings</h2>\n<p>可以结合 <code>auto</code>  的自动类型推导来自动绑定值。<br>\n使用前：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">auto</span> p <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>“s”<span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>string a <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>使用后：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">auto</span> p <span class=\"token operator\">=</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>“s”<span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// a is string, b is int</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// auto [a, b] =</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h1 id=\"references\"><a class=\"markdownIt-Anchor\" href=\"#references\">#</a> References</h1>\n<div class=\"note info\">\n<ol>\n<li><code>=</code>  默认为赋值值，如果要传入引用，必须在声明引用时加上 <code>&amp;</code> ;</li>\n<li>修改引用时便修改了值本身，而修改复制品不修改本身；</li>\n<li>引用是变量的引用，修改引用前必须声明一个变量，无法对常量进行引用；</li>\n</ol>\n</div>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> ref <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span> <span class=\"token comment\">// the reference of value</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> copy <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span> <span class=\"token comment\">// the copy of value</span></pre></td></tr></table></figure><p>此外，在使用迭代器时，如果要修改被迭代的值本身而不是他的复制品，必须使用引用，例如：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">shift</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token punctuation\">[</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\tnum1<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\tnum2<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这段代码中， <code>auto [num1,num2]</code>  是 <code>nums</code>  中每个元素的复制品，而不是本身。如果要对本身进行修改，必须使用：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span><span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">[</span>num1<span class=\"token punctuation\">,</span>num2<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> nums<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h1 id=\"left-value-right-value\"><a class=\"markdownIt-Anchor\" href=\"#left-value-right-value\">#</a> left-value &amp; right-value</h1>\n<p>左值和右值的区别在于，左值通常来说是变量，而右值是字面量。左值可以出现在 <code>=</code>  的左边和右边，是在程序生命周期内长期有效。而右值作为字面量，无法在程序中长期存活，自然也不能出现在 <code>=</code>  的左边。</p>\n<div class=\"note info\">\n<p>在使用引用时，不允许传入右值，即不允许传入字面量。我们无法对一个常量进行引用，只能对左值 (变量) 进行引用。</p>\n</div>\n<h1 id=\"常量及常量引用\"><a class=\"markdownIt-Anchor\" href=\"#常量及常量引用\">#</a> 常量及常量引用</h1>\n<p>常量是不允许修改的量，使用 <code>const</code>  声明常量。常量的引用和复制也必须是常量，引用及复制前加 <code>const</code> 。</p>\n<h1 id=\"containers\"><a class=\"markdownIt-Anchor\" href=\"#containers\">#</a> Containers</h1>\n<h1 id=\"iterators-and-pointers\"><a class=\"markdownIt-Anchor\" href=\"#iterators-and-pointers\">#</a> Iterators and Pointers</h1>\n<h1 id=\"classes\"><a class=\"markdownIt-Anchor\" href=\"#classes\">#</a> Classes</h1>\n<h1 id=\"template-classes-and-const-correctness\"><a class=\"markdownIt-Anchor\" href=\"#template-classes-and-const-correctness\">#</a> Template Classes and Const Correctness</h1>\n<h1 id=\"template-functions\"><a class=\"markdownIt-Anchor\" href=\"#template-functions\">#</a> Template Functions</h1>\n<h1 id=\"functions-and-lambdas\"><a class=\"markdownIt-Anchor\" href=\"#functions-and-lambdas\">#</a> Functions and Lambdas</h1>\n<h1 id=\"midquarter-review\"><a class=\"markdownIt-Anchor\" href=\"#midquarter-review\">#</a> Midquarter Review</h1>\n<h1 id=\"operators\"><a class=\"markdownIt-Anchor\" href=\"#operators\">#</a> Operators</h1>\n<h1 id=\"special-member-functions\"><a class=\"markdownIt-Anchor\" href=\"#special-member-functions\">#</a> Special Member Functions</h1>\n<h1 id=\"move-semantics\"><a class=\"markdownIt-Anchor\" href=\"#move-semantics\">#</a> Move Semantics</h1>\n<h1 id=\"stdoptional-and-type-safety\"><a class=\"markdownIt-Anchor\" href=\"#stdoptional-and-type-safety\">#</a> std::optional and Type Safety</h1>\n<h1 id=\"raii-smart-pointers-and-building-c-projects\"><a class=\"markdownIt-Anchor\" href=\"#raii-smart-pointers-and-building-c-projects\">#</a> RAII, Smart Pointers, and Building C++ Projects</h1>\n<h1 id=\"c-for-data-science-and-ml\"><a class=\"markdownIt-Anchor\" href=\"#c-for-data-science-and-ml\">#</a> C++ for Data Science and ML</h1>\n",
            "tags": [
                "C++"
            ]
        }
    ]
}