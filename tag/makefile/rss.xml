<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>望春风 • Posts by &#34;makefile&#34; tag</title>
        <link>https://salvely.github.io/blog</link>
        <description>计算机&amp;数理&amp;文学爱好者，喜欢健身、下厨、听音乐和看电影</description>
        <language>zh-CN</language>
        <pubDate>Fri, 27 Oct 2023 17:45:08 +0800</pubDate>
        <lastBuildDate>Fri, 27 Oct 2023 17:45:08 +0800</lastBuildDate>
        <category>C++</category>
        <category>Arch</category>
        <category>Linux</category>
        <category>安装教程</category>
        <category>操作系统</category>
        <category>notes</category>
        <category>配置教程</category>
        <category>Debian</category>
        <category>包管理</category>
        <category>参考资料</category>
        <category>CMake</category>
        <category>Makefile</category>
        <category>lab</category>
        <item>
            <guid isPermalink="true">https://salvely.github.io/blog/2023/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/</guid>
            <title>C++编译与工程构建</title>
            <link>https://salvely.github.io/blog/2023/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/</link>
            <category>C++</category>
            <category>CMake</category>
            <category>Makefile</category>
            <pubDate>Fri, 27 Oct 2023 17:45:08 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们在课程中写的都是代码量不大的小文件，但是在实际工程开发中，情况可就不一样了。但是那么多的代码，我们不可能将它们放在同一个文件中，肯定要分成不同的源文件。但是如何分解程序？如何实现程序之间的交流，就成了一个问题。本节中我们将探讨如何将一个大的工程分成不同的源程序，并且实现这些源程序之间的交流。我们首先介绍 C++ 的编译模型，也就是 C++ 源程序是如何编译成为机器可理解的二进制代码的。然后，我们讨论如何将一个大的工程分解为多个小的源程序，并且实现他们之间的交流。最后，我们探讨 C++ 的预处理器的工作模式。&lt;/p&gt;
&lt;h1 id=&#34;C-编译模型&#34;&gt;&lt;a href=&#34;#C-编译模型&#34; class=&#34;headerlink&#34; title=&#34;C++ 编译模型&#34;&gt;&lt;/a&gt;C++ 编译模型&lt;/h1&gt;&lt;p&gt;C++ 是一种编译型的语言，即通过编译器将源代码转化为机器可以理解的二进制代码。其编译过程分为 3 个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理阶段：扩展头文件，进行宏替换等&lt;/li&gt;
&lt;li&gt;编译阶段：将预处理后的高级语言代码转化为机器可以理解的二进制代码，即目标文件。在这个阶段，编译器会检查一些语法错误，如漏掉了&lt;code&gt;;&lt;/code&gt;等&lt;/li&gt;
&lt;li&gt;链接阶段：将生成的多个目标文件合并成一个最终的可执行文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;语法错误主要集中在编译阶段进行检查，而程序的一些其他问题则多半是出现在链接阶段。例如，程序可能定义了一个函数的原型，并且对他进行了调用，但是却没有实现这个函数。又或者，定义的函数原型和实现不一样，按照函数原型进行调用以后，程序找不到函数的实现。有的人会奇怪为什么这种错误会出现在链接阶段，是因为链接器没有在这个文件中找到函数原型时，他会本能的想到是不是在需要链接的其他文件中。如果在其他文件中也没有找到的话，链接器才会告诉你出现了链接错误。&lt;/p&gt;
&lt;h1 id=&#34;模块化与分解&#34;&gt;&lt;a href=&#34;#模块化与分解&#34; class=&#34;headerlink&#34; title=&#34;模块化与分解&#34;&gt;&lt;/a&gt;模块化与分解&lt;/h1&gt;&lt;p&gt;通常来说，对于一个大的工程问题，我们无法一口气思考到所有的细节。而在这种情况下，我们倾向于将问题分解成不同的模块，然后通过不同模块间的合作和交流来解决。但是，如何确定模块划分的粒度呢？毕竟越往下分，细节就越多。而在这个时候，我们会选择使用一些抽象的接口。举个例子，我们无需设计 C++ STL，只需要调用其提供给我们的接口，便可以实现多种功能。而这就是模块划分的尽头。&lt;br&gt;对于模块化，通常来说遵循 3 个原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单化：提供一个较为简单的接口&lt;/li&gt;
&lt;li&gt;可扩展：在需要的时候，我们可以在不改变接口的条件下改变其实现方式。&lt;/li&gt;
&lt;li&gt;可复用：接口足够泛用（使用泛型，模板之类），可以保证函数可以被用在多个不同的项目中&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;C-预处理器&#34;&gt;&lt;a href=&#34;#C-预处理器&#34; class=&#34;headerlink&#34; title=&#34;C++ 预处理器&#34;&gt;&lt;/a&gt;C++ 预处理器&lt;/h1&gt;&lt;h2 id=&#34;前言-1&#34;&gt;&lt;a href=&#34;#前言-1&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在编写 C++ 程序时，我们通常把一个程序分为&lt;code&gt;file.h&lt;/code&gt;和&lt;code&gt;file.cpp&lt;/code&gt;两个部分。&lt;code&gt;file.h&lt;/code&gt;中描述的是程序提供的类及函数接口（定义），而&lt;code&gt;.cpp&lt;/code&gt;文件中描述的是其实现。此外，通常在&lt;code&gt;.h&lt;/code&gt;文件的前后，会加上如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#ifndef StrUtils_Included
#define StrUtils_Included

#include &amp;lt;string&amp;gt;
using namespace std;
string ConvertToUpperCase(string input);
string ConvertToLowerCase(string input);
string IntegerToString(int value);
string DoubleToString(double value);

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;include头文件&#34;&gt;&lt;a href=&#34;#include头文件&#34; class=&#34;headerlink&#34; title=&#34;include头文件&#34;&gt;&lt;/a&gt;&lt;code&gt;include&lt;/code&gt;头文件&lt;/h2&gt;&lt;p&gt;其作用在于将头文件的内容复制到&lt;code&gt;#include&lt;/code&gt;处。头文件分为两种，一种用&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;包起，是 C++ 标准库中的文件；而另外一种用&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;包起，是用户自定义的头文件，编译器会在当前工程文件夹下找。&lt;/p&gt;
&lt;h2 id=&#34;define定义与替换&#34;&gt;&lt;a href=&#34;#define定义与替换&#34; class=&#34;headerlink&#34; title=&#34;define定义与替换&#34;&gt;&lt;/a&gt;&lt;code&gt;define&lt;/code&gt;定义与替换&lt;/h2&gt;&lt;p&gt;宏定义的基本格式是&lt;code&gt;define val replacement&lt;/code&gt;。在进行宏替换时，做的不是值替换，而是普通的字符串的替换。即将程序中所有的&lt;code&gt;val&lt;/code&gt;都替换成&lt;code&gt;replacement&lt;/code&gt;。在进行宏替换时编译器并不理解这到底是什么东西，就是简单的左无脑替换。因此在替换时必须要注意，譬如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#define a 5 + 10
...
int b = 2 * a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在进行宏替换后，效果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;int b = 2 * 5 + 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而不是:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;int b = 2 * (5 + 10);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为它做的仅仅是简单的字符串替换。这种错误经常发生，而要避免这类错误的方法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;define&lt;/code&gt;时使用&lt;code&gt;()&lt;/code&gt;圆括号&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;const&lt;/code&gt;语句&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;include-guard&#34;&gt;&lt;a href=&#34;#include-guard&#34; class=&#34;headerlink&#34; title=&#34;include guard&#34;&gt;&lt;/a&gt;&lt;code&gt;include guard&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;预处理语句可以通过条件判断来决定是否要定义某些文件，一个简单的格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;ifndef...define...endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这套语句的基本意思是：如果已经&lt;code&gt;#include&lt;/code&gt;过上述文件，就不需要再定义一次了。C++ 工程文件之间相互&lt;code&gt;#include&lt;/code&gt;是家常便饭，这样做是为了防止由于多次互相&lt;code&gt;#include&lt;/code&gt;带来的重定义问题。上述语句只是一个较为简化的版本，更为完整的定义是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;  #if statement
  ...
  #elif another-statement
  ...
  #elif yet-another-statement
  ...
  #else
  ...
  #endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这其中的&lt;code&gt;statement&lt;/code&gt;可以是条件判断语句，也可以是&lt;code&gt;define()&lt;/code&gt;语句。做条件判断时，使用的必须是已经定义过的变量，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;  #if MY_CONSTANT &amp;gt; 137 // Legal
  #if MY_CONSTANT * 42 == MY_CONSTANT // Legal
  #if sqrt(MY_CONSTANT) &amp;lt; 4 // Illegal, cannot call function sqrt
  #if MY_CONSTANT == 3.14 // Illegal, can only use integral values
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而使用&lt;code&gt;define&lt;/code&gt;语句时，如果变量已经定义，则&lt;code&gt;define()&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;  #if defined(MY_CONSTANT) // Evaluates to true.
  #if defined(OTHER_CONSTANT) // Evaluates to false.
  #if !defined(MY_CONSTANT) // Evaluates to false.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其判断结果被应用在&lt;code&gt;if&lt;/code&gt;语句中。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;#if defined(A)
    cout &amp;lt;&amp;lt; &amp;quot;A is defined.&amp;quot; &amp;lt;&amp;lt; endl;
#elif defined(B)
    cout &amp;lt;&amp;lt; &amp;quot;B is defined.&amp;quot; &amp;lt;&amp;lt; endl;
#elif defined(C)
     cout &amp;lt;&amp;lt; &amp;quot;C is defined.&amp;quot; &amp;lt;&amp;lt; endl;
#else
    cout &amp;lt;&amp;lt; &amp;quot;None of A, B, or C is defined.&amp;quot; &amp;lt;&amp;lt; endl;
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这套语句的效果相当于将所有&lt;code&gt;include&lt;/code&gt;的内容复制粘贴到源程序中，但是注释掉重复定义的部分。它和注释不一样之处在于，这套语句可以嵌套，而注释不能。&lt;/p&gt;
&lt;h2 id=&#34;宏&#34;&gt;&lt;a href=&#34;#宏&#34; class=&#34;headerlink&#34; title=&#34;宏&#34;&gt;&lt;/a&gt;宏&lt;/h2&gt;&lt;h2 id=&#34;内联函数&#34;&gt;&lt;a href=&#34;#内联函数&#34; class=&#34;headerlink&#34; title=&#34;内联函数&#34;&gt;&lt;/a&gt;内联函数&lt;/h2&gt; ]]></description>
        </item>
    </channel>
</rss>
