<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://salvely.github.io/blog</id>
    <title>望春风 • Posts by &#34;lab&#34; tag</title>
    <link href="https://salvely.github.io/blog" />
    <updated>2024-02-05T07:50:22.000Z</updated>
    <category term="C++" />
    <category term="Arch" />
    <category term="Linux" />
    <category term="安装教程" />
    <category term="操作系统" />
    <category term="notes" />
    <category term="配置教程" />
    <category term="Debian" />
    <category term="包管理" />
    <category term="参考资料" />
    <category term="CMake" />
    <category term="Makefile" />
    <category term="lab" />
    <entry>
        <id>https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
        <title>15213 Lab 1-data lab 实验总结</title>
        <link rel="alternate" href="https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
        <content type="html">&lt;p&gt;部分的题目我参考了一下网上的内容（出处已注明），其他的均为自己实现（有的题目的实现过程可能会有些繁琐），部分 dlc 检测出来可能会报些 error，但是 btest 均能过。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有 TA 可太难了！自己实现了一天多，终于苟完了。不算完美，但也能看吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;bitXor&#34;&gt;&lt;a href=&#34;#bitXor&#34; class=&#34;headerlink&#34; title=&#34;bitXor&#34;&gt;&lt;/a&gt;bitXor&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * bitXor - x^y using only ~ and &amp;amp;
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &amp;amp;
 *   Max ops: 14
 *   Rating: 1
 */
int bitXor(int x, int y)
&amp;#123;
   /**
    * x + y = ~( ~x &amp;amp; ~y)
    */
   return ~((~(x &amp;amp; ~y)) &amp;amp; (~(y &amp;amp; ~x)));
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bitXor 要求我们使用位操作来实现&lt;code&gt;^&lt;/code&gt;运算符。根据运算定律我们知道: &lt;code&gt;a ^ b = (a &amp;amp; (~b)) | (b &amp;amp; (~a))&lt;/code&gt;。但是问题来了，我们这里不允许使用&lt;code&gt;|&lt;/code&gt;，只能用&lt;code&gt;~&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;。那么我们就必须使用这两个操作符来实现&lt;code&gt;|&lt;/code&gt;运算。&lt;br&gt;通过德摩根定律我们知道：&lt;code&gt;a | b = ~((~a) &amp;amp; (~b))&lt;/code&gt;。这不就解决问题了嘛，所以将这两个式子综合一下，最后的结果是&lt;code&gt;~((~(x &amp;amp; ~y)) &amp;amp; (~(y &amp;amp; ~x)))&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;tmin&#34;&gt;&lt;a href=&#34;#tmin&#34; class=&#34;headerlink&#34; title=&#34;tmin&#34;&gt;&lt;/a&gt;tmin&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * tmin - return minimum two&amp;#39;s complement integer
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 4
 *   Rating: 1
 */
int tmin(void)
&amp;#123;
   /**
    * the most significant bit = 1, others = 0, so (1 &amp;lt;&amp;lt; 31)
    */
   return (1 &amp;lt;&amp;lt; 31);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题要求我们返回最小的补码整数，返回类型为&lt;code&gt;int&lt;/code&gt;。首先，在二进制补码表示中，最高位的权值为-1，其他位的权值为 1。因此，最小的补码整数 tmin 的最高位为 1，其他位为 0。而题目中&lt;code&gt;int&lt;/code&gt;类型为 32 位，因此只要返回&lt;code&gt;(1 &amp;lt;&amp;lt; 31)&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&#34;isTmax&#34;&gt;&lt;a href=&#34;#isTmax&#34; class=&#34;headerlink&#34; title=&#34;isTmax&#34;&gt;&lt;/a&gt;isTmax&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * isTmax - returns 1 if x is the maximum, two&amp;#39;s complement number,
 *     and 0 otherwise
 *   Legal ops: ! ~ &amp;amp; ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
int isTmax(int x)
&amp;#123;
   /**
    * Tmax ^ Tmin = 0xffffffff, ~0xffffffff = 0x0, !0x0 = 0x1
    */
   // return !(~(x ^ (1 &amp;lt;&amp;lt; 31)));

   /**
    * ~Tmax = Tmin -&amp;gt; ~Tmin + 1 = Tmin 且 Tmin != 0
    */
   int num = ~x;
   return !(num ^ (~num + 1)) &amp;amp; !!num;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tmax 是二进制补码中最大的数，通过分析这个数的特点，我们可以完成这道题目。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该数除了最高位是 0 外，其他位均是 1。因此该数和(1&amp;lt;&amp;lt;31)（也就是 tmin）的亦或（或者和）为&lt;code&gt;0xffffffff&lt;/code&gt;。&lt;code&gt;0xffffffff&lt;/code&gt;按位取反得到&lt;code&gt;0x0&lt;/code&gt;，而&lt;code&gt;0x0&lt;/code&gt;按位取反得到&lt;code&gt;0x1&lt;/code&gt;。但是其他的数并没有这个特性。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;return !(~(x ^ (1 &amp;lt;&amp;lt; 31)));
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;该数取反后得到 tmin，tmin 的一个特点是 tmin 和 -tmin 的表示相同。因此两者亦或得到 0。还有一个树也有这样的特性，也就是 0。因此我们需要排除 0 的可能性。我们使用&lt;code&gt;&amp;amp;&lt;/code&gt;操作符来实现两种特性的叠加。我本没有想到该方法，是从这篇&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=&#34;&gt;知乎帖子&lt;/span&gt;学习到的。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;int num = ~x;
return !(num ^ (~num + 1)) &amp;amp; !!num;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是题目不允许在该题中使用移位运算符，因此只能使用方法二。&lt;/p&gt;
&lt;h2 id=&#34;allOddBits&#34;&gt;&lt;a href=&#34;#allOddBits&#34; class=&#34;headerlink&#34; title=&#34;allOddBits&#34;&gt;&lt;/a&gt;allOddBits&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 *   where bits are numbered from 0 (least significant) to 31 (most significant)
 *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 12
 *   Rating: 2
 */
int allOddBits(int x)
&amp;#123;
   /**
    * tear the number into 4 parts, get rid of the other digits except 0xaa
    * if the results are all the same, then compare it with 0xaa, if there are the same, xor returns 0
    * otherwise not all odd bits in word set is set to 1
    */
   int first = (x &amp;gt;&amp;gt; 24) &amp;amp; 0xaa;
   int second = (x &amp;gt;&amp;gt; 16) &amp;amp; 0xaa;
   int third = (x &amp;gt;&amp;gt; 8) &amp;amp; 0xaa;
   int fourth = x &amp;amp; 0xaa;
   return !((first &amp;amp; second &amp;amp; third &amp;amp; fourth) ^ 0xaa);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于单个字节的奇数位，我们可以使用&lt;code&gt;0xaa&lt;/code&gt;作为 mask。&lt;br&gt;本题目中我将位打成 4 个部分，每个部分与 mask 相与。如果每个奇数位都是 1 的话，四个部分的比较结果应该相同，都等于&lt;code&gt;0xaa&lt;/code&gt;，该值与&lt;code&gt;0xaa&lt;/code&gt;异或得到&lt;code&gt;0x0&lt;/code&gt;，取&lt;code&gt;!&lt;/code&gt;后得到&lt;code&gt;0x1&lt;/code&gt;。否则该值不为&lt;code&gt;0xaa&lt;/code&gt;，同&lt;code&gt;0xaa&lt;/code&gt;亦或得到其他非零值，取&lt;code&gt;!&lt;/code&gt;后得到&lt;code&gt;0x0&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;negate&#34;&gt;&lt;a href=&#34;#negate&#34; class=&#34;headerlink&#34; title=&#34;negate&#34;&gt;&lt;/a&gt;negate&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * negate - return -x
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 5
 *   Rating: 2
 */
int negate(int x)
&amp;#123;
   return (~x + 1);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该题目中我们需要求解某个数的相反数。在课堂中我们学过，一个数和它相反数的和为 0。那么如何获得其相反数呢？以&lt;code&gt;x&lt;/code&gt;为例，我们知道&lt;code&gt;x + ~x = ~0&lt;/code&gt;，也就是全 f，然后&lt;code&gt;~0 + 1 = 0&lt;/code&gt;。因此，&lt;code&gt;-x&lt;/code&gt;的补码表示即为&lt;code&gt;~x + 1&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;isAsciiDigit&#34;&gt;&lt;a href=&#34;#isAsciiDigit&#34; class=&#34;headerlink&#34; title=&#34;isAsciiDigit&#34;&gt;&lt;/a&gt;isAsciiDigit&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * isAsciiDigit - return 1 if 0x30 &amp;lt;= x &amp;lt;= 0x39 (ASCII codes for characters &amp;#39;0&amp;#39; to &amp;#39;9&amp;#39;)
 *   Example: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 15
 *   Rating: 3
 */
int isAsciiDigit(int x)
&amp;#123;
   /**
    * least = (x &amp;amp; 0xf) - 0xa
    * if least &amp;gt; 0 (with 0 in most significant bit) then least = 0
    * else least = 1
    */
   int least = ((((x &amp;amp; 0xf) + (~0xa + 1)) &amp;gt;&amp;gt; 31) &amp;amp; 0x1);
   int second = !((x &amp;gt;&amp;gt; 4) ^ 0x3);
   return least &amp;amp; second;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我使用的方法是将该数拆分为最低位和其他位来比较。我们将最低位与&lt;code&gt;0xa&lt;/code&gt;相减，如果求得的结果为负数，符号位即为 1，代表该值在 0-9 之间。接下来判断其他位是否为&lt;code&gt;0x3&lt;/code&gt;，如果是，则和&lt;code&gt;0x3&lt;/code&gt;异或结果为 0，通过逻辑&lt;code&gt;!&lt;/code&gt;返回 1。&lt;/p&gt;
&lt;h2 id=&#34;conditional&#34;&gt;&lt;a href=&#34;#conditional&#34; class=&#34;headerlink&#34; title=&#34;conditional&#34;&gt;&lt;/a&gt;conditional&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * conditional - same as x ? y : z
 *   Example: conditional(2,4,5) = 4
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 16
 *   Rating: 3
 */
int conditional(int x, int y, int z)
&amp;#123;
   /**
    * judge if x != 0, if true, !!x = 1, return y, otherwise !!x = 0, return z
    */

   // cond gets all f when !!x == 1
   int cond = ((!!x) &amp;lt;&amp;lt; 31) &amp;gt;&amp;gt; 31;
   return (cond &amp;amp; y) | (~cond &amp;amp; z);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们先获取&lt;code&gt;x&lt;/code&gt;的值，如果&lt;code&gt;x != 0&lt;/code&gt;，则&lt;code&gt;!!x = 0x1&lt;/code&gt;，否则为&lt;code&gt;0x0&lt;/code&gt;。扩展该值，当该值为&lt;code&gt;0x1&lt;/code&gt;时与&lt;code&gt;y&lt;/code&gt;相与得到 y。当该值为&lt;code&gt;0x0&lt;/code&gt;，取反后与 z 相与得到 z。因为这两个值只取其一，当一边不为 0 时另一边必然为 0，因此两边用&lt;code&gt;|&lt;/code&gt;连接。&lt;/p&gt;
&lt;h2 id=&#34;isLessOrEqual&#34;&gt;&lt;a href=&#34;#isLessOrEqual&#34; class=&#34;headerlink&#34; title=&#34;isLessOrEqual&#34;&gt;&lt;/a&gt;isLessOrEqual&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本题要求使用最多 24 个运算符，但是这里我使用的过多了，应该会有更好的办法。期待有人指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * isLessOrEqual - if x &amp;lt;= y  then return 1, else return 0
 *   Example: isLessOrEqual(4,5) = 1.
 *   Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 24
 *   Rating: 3
 */
int isLessOrEqual(int x, int y)
&amp;#123;
   // first compare their sign bit
   int sign_x = (x &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   int sign_y = (y &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   // return true if sign = 1(&amp;gt;0)
   int sign_diff = sign_x + (~sign_y + 1);
   int sign_bit = (sign_diff &amp;gt;&amp;gt; 31) &amp;amp; 0x1;

   // then compare the magnitude
   int mask = (~0) + (0x1 &amp;lt;&amp;lt; 31);
   int mag_x = x &amp;amp; mask;
   int mag_y = y &amp;amp; mask;
   int mag_diff = mag_x + (~mag_y + 1);
   int mag_sign = !(mag_x ^ mag_y) | ((mag_diff &amp;gt;&amp;gt; 31) &amp;amp; 0x1);

   /**
    * 2 conditions return true:
    * 1. sign of x = 1 and sign of y = 0
    * 2. sign of x and y equals, and magnitude of x &amp;lt;= y
    */
   return (((!sign_bit) &amp;amp; sign_diff) | ((!sign_diff) &amp;amp; mag_sign));
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里要分几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x 为负数，y 为正数，直接返回&lt;code&gt;0x1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;x 和 y 同符号，比较数值部分。x &amp;lt;&amp;#x3D; y 时，返回&lt;code&gt;0x1&lt;/code&gt;；x &amp;gt; y 时，返回&lt;code&gt;0x0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;x 为正数，y 为负数，返回&lt;code&gt;0x0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中&lt;code&gt;sign_diff&lt;/code&gt;为两数符号位之差，此处分三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x 为负数，符号位为 1；y 为正数，符号位为 0。那么两者符号位相减等于&lt;code&gt;0x1&lt;/code&gt;，该值的符号位为 0。（这是我们要返回&lt;code&gt;0x1&lt;/code&gt;的结果）&lt;/li&gt;
&lt;li&gt;x 为正数，符号位为 0；y 为负数，符号位为 1。那么两者符号位相减等于&lt;code&gt;0xffffffff&lt;/code&gt;(-1)，该值的符号位为 1。（我们不要这个结果）&lt;/li&gt;
&lt;li&gt;x 和 y 的符号位相同，两者相减为&lt;code&gt;0x0&lt;/code&gt;，该值的符号位为 0。（这里我们要看情况，看&lt;code&gt;x&lt;/code&gt;是否和&lt;code&gt;y&lt;/code&gt;相等）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码中&lt;code&gt;sign_diff&lt;/code&gt;为两符号位之差，&lt;code&gt;sign_bit&lt;/code&gt;为该做差结果的最高位。当 x 和 y 的符号位不相同时，当&lt;code&gt;sign_diff&lt;/code&gt;为&lt;code&gt;0x1&lt;/code&gt;且&lt;code&gt;sign_bit&lt;/code&gt;为&lt;code&gt;0x0&lt;/code&gt;是，我们返回&lt;code&gt;0x1&lt;/code&gt;。这也是运算结果&lt;code&gt;|&lt;/code&gt;左半边的由来。&lt;/p&gt;
&lt;p&gt;代码中&lt;code&gt;mag_diff&lt;/code&gt;为两者数值部分之差，&lt;code&gt;mag_sign&lt;/code&gt;为该差值的符号位。当&lt;code&gt;x &amp;lt; y&lt;/code&gt;时，&lt;code&gt;mag_diff&lt;/code&gt;为&lt;code&gt;0xffffffff&lt;/code&gt;。当&lt;code&gt;x == y&lt;/code&gt;时，&lt;code&gt;!(mag_x ^ mag_y)&lt;/code&gt;为&lt;code&gt;0x1&lt;/code&gt;。因此&lt;code&gt;mag_sign = !(mag_x ^ mag_y) | ((mag_diff &amp;gt;&amp;gt; 31) &amp;amp; 0x1)&lt;/code&gt;。在判断数值之差部分时，我们需要保证两数符号位之差为&lt;code&gt;0x0&lt;/code&gt;，而不是其他（如 x 正 y 负）。因此运算结果右半边的值为&lt;code&gt;(!sign_diff) &amp;amp; mag_sign&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;综上，最后的结果是&lt;code&gt;((!sign_bit) &amp;amp; sign_diff) | ((!sign_diff) &amp;amp; mag_sign)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;logicalNeg&#34;&gt;&lt;a href=&#34;#logicalNeg&#34; class=&#34;headerlink&#34; title=&#34;logicalNeg&#34;&gt;&lt;/a&gt;logicalNeg&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * logicalNeg - implement the ! operator, using all of
 *              the legal operators except !
 *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1
 *   Legal ops: ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *   Max ops: 12
 *   Rating: 4
 */
int logicalNeg(int x)
&amp;#123;
   /**
    * if x == 0, x ^ 0x0 = 0
    */
   return ((x | (x + ~0 + (~(1 &amp;lt;&amp;lt; 31) + 1))) &amp;gt;&amp;gt; 31) + 1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这道题的难点在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 0 映射到 0x1&lt;/li&gt;
&lt;li&gt;将非 0 值映射到 0x0&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在一开始实现时，我的思路是对于 0，可以和&lt;code&gt;0x0&lt;/code&gt;异或，判断为 0。但是对于非 0 的数，和&lt;code&gt;0x0&lt;/code&gt;异或后还是他自己，我们也不知道 1 落在其中哪个位上，一个个位去找也不现实。那么就需要思考其他的办法。从&lt;code&gt;0x0&lt;/code&gt;这个数和其他数的特点下手。这里我参考了&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==&#34;&gt;这篇博客&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其给出的思路是：&lt;br&gt;-x 为 x 按位取反再+1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个数为全 0，和相反数相&lt;code&gt;|&lt;/code&gt;后结果全部是 0，加 1 后得到&lt;code&gt;0x1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则结果最高位必然含有 1。向右移动 31 位获得&lt;code&gt;~0&lt;/code&gt;，再加 1 得到&lt;code&gt;0x0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题可改为，如何判断一个数全为 0 。注意到，-x 相当于按位取反再加一，如果 x 为 非 0 数，那么 x|(-x) 后必定为 -1 。利用这个性质，即可判断是否为 0 。&lt;/p&gt;
&lt;h2 id=&#34;howManyBits&#34;&gt;&lt;a href=&#34;#howManyBits&#34; class=&#34;headerlink&#34; title=&#34;howManyBits&#34;&gt;&lt;/a&gt;howManyBits&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/* howManyBits - return the minimum number of bits required to represent x in
 *             two&amp;#39;s complement
 *  Examples: howManyBits(12) = 5
 *            howManyBits(298) = 10
 *            howManyBits(-5) = 4
 *            howManyBits(0)  = 1
 *            howManyBits(-1) = 1
 *            howManyBits(0x80000000) = 32
 *  Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt;
 *  Max ops: 90
 *  Rating: 4
 */
int howManyBits(int x)
&amp;#123;
   /**
    * divide and conquer
    * for positive number, the number of bits = the last position of 1 + 1
    * for negative number, the number of bits = the last position of 1
    * inverse negative number and deal with it as the same as positive number
    * 1. judge the sign bit of x, if x is negative, inverse it
    * 2. judge the high 16 bits, if true(high 16 bits != 0x0), result + 16
    * 3. judge the high 8 bits, if true, result + 8
    * 4. judge the high 4 bits, if true, result + 4
    * 5. judge the high 2 bits, if true, result + 2
    * 6. judge the high 1 bits, if true, result + 1
    * 7. judge the last 1 bit, if true, result + !!x
    * 8. the final sum must + 1
    * 9. return the result
    */
   // neg x if it&amp;#39;s negative
   int sign = ((x &amp;amp; (1 &amp;lt;&amp;lt; 31)) &amp;gt;&amp;gt; 31);
   x = (sign &amp;amp; ~x) | (~sign &amp;amp; x);

   int b16, b8, b4, b2, b1, b0;

   // int mask_16 = (1 &amp;lt;&amp;lt; 15) &amp;gt;&amp;gt; 15;
   b16 = !!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4;
   x = x &amp;gt;&amp;gt; b16;

   // int mask_8 = 0xff;
   b8 = !!(x &amp;gt;&amp;gt; 8) &amp;lt;&amp;lt; 3;
   x = x &amp;gt;&amp;gt; b8;

   // int mask_4 = 0xf;
   b4 = !!(x &amp;gt;&amp;gt; 4) &amp;lt;&amp;lt; 2;
   x = x &amp;gt;&amp;gt; b4;

   // int mask_2 = 0x3;
   b2 = !!(x &amp;gt;&amp;gt; 2) &amp;lt;&amp;lt; 1;
   x = x &amp;gt;&amp;gt; b2;

   // int mask_1 = 0x1;
   b1 = !!(x &amp;gt;&amp;gt; 1);
   x = x &amp;gt;&amp;gt; b1;

   //! judge if the last bit == 1
   b0 = !!x;

   return b16 + b8 + b4 + b2 + b1 + b0 + 1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个题目中，我们主要采用分而治之的方法。分治方法的几道例题可以参考 CMU 15-213 课程的&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MvYWNhZGVtaWMvY2xhc3MvMTUyMTMtZjIzL3d3dy9yZWNpdGF0aW9ucy9yZWMwMV9zb2x1dGlvbnMucGRm&#34;&gt;Recitation Slides&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;首先，我们可以看到，如果该数是一个正数，则其最高位必然是 0，该数的位数 &amp;#x3D; 最高一个 1 的位置 + 1；&lt;br&gt;如果该数是一个负数，该数的位数 &amp;#x3D; 最高一个 1 的位置。&lt;br&gt;我们不想那么麻烦，把正负数分开讨论，因此我们把负数翻转过来。&lt;/p&gt;
&lt;p&gt;在这道题中我们采用的方法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断高 16 位是否有 1（把数向右移动 16 位后，结果不为 0，&lt;code&gt;!!(x &amp;gt;&amp;gt; 16)&lt;/code&gt;）。&lt;code&gt;b16 = !!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4&lt;/code&gt;。如果是的话，把数值向右移动 16 位&lt;code&gt;(x&amp;gt;&amp;gt;b16)&lt;/code&gt;。把&lt;code&gt;b16&lt;/code&gt;添加到结果中去。这里一个妙用在于如果&lt;code&gt;!!(x &amp;gt;&amp;gt; 16）= 0x1&lt;/code&gt;，&lt;code&gt;!!(x &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 4&lt;/code&gt;可以直接起到获得数字 16 的方法，无需增加其他的运算。&lt;/li&gt;
&lt;li&gt;判断高 8 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断高 4 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断高 2 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断高 1 位是否有 1，操作同上&lt;/li&gt;
&lt;li&gt;判断该位是否有 1&lt;/li&gt;
&lt;li&gt;结果 + 1（位数 &amp;#x3D; 最高一个 1 的位置 + 1）&lt;/li&gt;
&lt;li&gt;最后把所有判断结果加起来（每次判断的结果都是一个累加的位数，加在一起就是最后的总位数）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;浮点数复习&#34;&gt;&lt;a href=&#34;#浮点数复习&#34; class=&#34;headerlink&#34; title=&#34;浮点数复习&#34;&gt;&lt;/a&gt;浮点数复习&lt;/h2&gt;&lt;p&gt;在完成浮点数部分的题目之前，我们需要复习一下浮点数的和其表示方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单精度浮点数：1 位符号位 + 8 位阶码(exp) + 11 位尾数(frac)&lt;/li&gt;
&lt;li&gt;双精度浮点数：1 位符号位 + 11 位阶码(exp) + 52 位尾数(frac)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中阶码使用移码表示。$bias &amp;#x3D; 2^{k-1}-1$&lt;/p&gt;
&lt;p&gt;浮点数分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规格化数：阶码不全为 1 也不全为 0，尾数前有隐含的 1，指数$E&amp;#x3D;exp - bias$，分布在非规格化数外侧&lt;/li&gt;
&lt;li&gt;非规格化数：阶码全为 0，尾数前隐含 0，指数$E&amp;#x3D;1 - bias$，主要分布在靠近 0 侧&lt;/li&gt;
&lt;li&gt;特殊值：阶码全为 1，若尾数全为 0，则为&lt;code&gt;inf&lt;/code&gt;，否则为&lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;floatScale2&#34;&gt;&lt;a href=&#34;#floatScale2&#34; class=&#34;headerlink&#34; title=&#34;floatScale2&#34;&gt;&lt;/a&gt;floatScale2&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;// float
/*
 * floatScale2 - Return bit-level equivalent of expression 2*f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int&amp;#39;s, but
 *   they are to be interpreted as the bit-level representation of
 *   single-precision floating point values.
 *   When argument is NaN, return argument
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;amp;&amp;amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned floatScale2(unsigned uf)
&amp;#123;
   // first get the sign, exp and mag bit of the number
   unsigned sign = (uf &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   unsigned e = (uf &amp;gt;&amp;gt; 23) &amp;amp; ((1 &amp;lt;&amp;lt; 8) - 1);
   unsigned f = (uf &amp;amp; ((1 &amp;lt;&amp;lt; 23) - 1));

   if (e == 0)
   &amp;#123;
      // denormalized number
      // E = 1 - bias
      // frac = f

      //! how to multiply a denormalized number? frac * 2!
      f = f * 2;
   &amp;#125;
   else if (e == 0xff)
   &amp;#123;
      // special number
      // if frac = 0, then value = inf
      if (f == 0)
      &amp;#123;
         // frac = 1 / 0;
         return uf;
      &amp;#125;
      else
      &amp;#123;
         // if frac != 0, value = NaN
         return uf;
      &amp;#125;
   &amp;#125;
   else
   &amp;#123;
      // normalized number
      // E = e - bias
      // value = 1 + f

      e += 1;
      if (e == ~0)
      &amp;#123;
         return uf;
      &amp;#125;
   &amp;#125;

   return (sign &amp;lt;&amp;lt; 31) | (e &amp;lt;&amp;lt; 23) | f;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题目要求是计算一个 unsigned 形式表示的浮点数 &lt;code&gt;* 2&lt;/code&gt; 后的表示。在完成这题之前，我们首先把浮点数的几个部分提取出来，分几个情况讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非规格化数：指数不变，尾数乘 2。&lt;strong&gt;问题来了，这到底是为什么？因为当exp全为0时，exp &amp;#x3D; 0, E &amp;#x3D; 1 - bias, frac &amp;#x3D; 0.f。乘以2就相当于把f左移一位，最高位会进到exp的位置去。如果f最高位是0，左移一位不影响exp（全0）。如果f最高位是1，左移一位后该数变为规格化数，exp变为1，E依然等于 1 - bias。实现了非规格化数到规格化数的平滑过渡（非常重要！）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;规格化数：首先将指数 + 1，然后判断是否为特殊值，若是则返回&lt;code&gt;uf&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;特殊值：&lt;code&gt;e = 0&lt;/code&gt;，直接返回&lt;code&gt;uf&lt;/code&gt;（根据题目意思）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将符号位，指数和尾数三个部分拼凑起来，直接返回（本题中无需进行任何计算）。&lt;/p&gt;
&lt;h2 id=&#34;floatFloat2Int&#34;&gt;&lt;a href=&#34;#floatFloat2Int&#34; class=&#34;headerlink&#34; title=&#34;floatFloat2Int&#34;&gt;&lt;/a&gt;floatFloat2Int&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本题中不允许使用&lt;code&gt;double&lt;/code&gt;类型，我擅自用了，这里应该是不严谨的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * floatFloat2Int - Return bit-level equivalent of expression (int) f
 *   for floating point argument f.
 *   Argument is passed as unsigned int, but
 *   it is to be interpreted as the bit-level representation of a
 *   single-precision floating point value.
 *   Anything out of range (including NaN and infinity) should return
 *   0x80000000u.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;amp;&amp;amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
int floatFloat2Int(unsigned uf)
&amp;#123;
   // first get the sign, exp and mag bit of the number
   unsigned sign = (uf &amp;gt;&amp;gt; 31) &amp;amp; 0x1;
   unsigned e = (uf &amp;gt;&amp;gt; 23) &amp;amp; ((1 &amp;lt;&amp;lt; 8) - 1);
   float f = (uf &amp;amp; ((1 &amp;lt;&amp;lt; 23) - 1)) / (1 &amp;lt;&amp;lt; 23);

   // then get the exact sign, E and value of the number
   int s = 0;
   if (sign == 0)
      s = 1;
   else
      s = -1;

   int E = 0;
   float frac = 0;
   int bias = 127;
   if (e == 0)
   &amp;#123;
      // denormalized number
      // E = 1 - bias
      E = 1 - bias;
      // frac = f
      frac = f;
   &amp;#125;
   else if (e == 0xff)
   &amp;#123;
      //! COMPARE WITH 0XFF INSTEAD OF ~0
      // special number
      // if frac = 0, then value = inf
      if (f == 0)
      &amp;#123;
         // frac = 1 / 0;
         return 0x80000000u;
      &amp;#125;
      else
      &amp;#123;
         // if frac != 0, value = NaN
         return 0x80000000u;
      &amp;#125;
   &amp;#125;
   else
   &amp;#123;
      // normalized number
      // E = e - bias
      E = e - bias;
      // value = 1 + f
      frac = 1 + f;
   &amp;#125;
   if (E &amp;lt; 0)
   &amp;#123;
      return 0;
   &amp;#125;
   else if (E &amp;gt; 31)
   &amp;#123;
      //! REMEMBER THE SITUATION THAT E &amp;gt; 31
      return 0x80000000u;
   &amp;#125;

   return s * frac * (1 &amp;lt;&amp;lt; E);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题需要返回浮点数转化后的 int 类型数值。需要我们对浮点数的结构有所了解，并且其转化为 int 后需要切割掉小数部分，此外，我们还需要判断指数过大的情况（溢出）。&lt;/p&gt;
&lt;p&gt;本题中我们采用的步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提取出浮点数三个部分，计算符号位的值&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;e == 0&lt;/code&gt;时，为特殊值的情况，&lt;code&gt;E = 1 - bias&lt;/code&gt;，&lt;code&gt;frac = f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;e == 0xff&lt;/code&gt;时（注意不是&lt;code&gt;~0/0xffffffff&lt;/code&gt;,容易写错！），返回&lt;code&gt;0x80000000u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以上两种情况都不是，则该数为规格化数，&lt;code&gt;E = e - bias; frac = 1 + f;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，我们需要进行&lt;strong&gt;特殊情况的分类讨论&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;E &amp;lt; 0, 则最后生成的结果（无论规格化还是非规格化）肯定是个小数，打头的是 0 那种，要切割为&lt;code&gt;int&lt;/code&gt;类型，小数部分就被切割掉了&lt;/li&gt;
&lt;li&gt;E &amp;gt; 31, 超过了指数可以表示的范围（算是溢出了？），返回&lt;code&gt;0x80000000u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正常情况下返回&lt;code&gt;s * frac * (1 &amp;lt;&amp;lt; E)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;floatPower2&#34;&gt;&lt;a href=&#34;#floatPower2&#34; class=&#34;headerlink&#34; title=&#34;floatPower2&#34;&gt;&lt;/a&gt;floatPower2&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c&#34;&gt;/*
 * floatPower2 - Return bit-level equivalent of the expression 2.0^x
 *   (2.0 raised to the power x) for any 32-bit integer x.
 *
 *   The unsigned value that is returned should have the identical bit
 *   representation as the single-precision floating-point number 2.0^x.
 *   If the result is too small to be represented as a denorm, return
 *   0. If too large, return +INF.
 *
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;amp;&amp;amp;. Also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned floatPower2(int x)
&amp;#123;
   //! REMEMEBER THAT FLOATING POINT ITSELF IS IN THE FORMAT (-1)^S * M * 2.0^E
   // fit x into E
   x = x + 127;
   //! MIND THE SITUATION THAT X IS TOO LARGE OR TOO SMALL
   if (x &amp;gt;= 0xff)
      x = 0xff;
   else if (x &amp;lt;= 0)
      x = 0;
   unsigned result = (x &amp;lt;&amp;lt; 23);
   return result;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为浮点数表示法本身就是以 2 为底，所以本实验就相当于如何把 x 转化为那个 8 位的阶码。因为&lt;code&gt;阶码 = 指数 + bias&lt;/code&gt;，这里&lt;code&gt;bias = 127&lt;/code&gt;，因此这里&lt;code&gt;E = x + 127&lt;/code&gt;。然后和上一题一样，我们需要判断一下 x 的范围是否在&lt;code&gt;0xff&lt;/code&gt;和&lt;code&gt;0&lt;/code&gt;之间。最后将 x 移动到阶码的位置返回(&lt;code&gt;return x &amp;lt;&amp;lt; 23&lt;/code&gt;)即可。&lt;/p&gt;
&lt;h2 id=&#34;参考实现&#34;&gt;&lt;a href=&#34;#参考实现&#34; class=&#34;headerlink&#34; title=&#34;参考实现&#34;&gt;&lt;/a&gt;参考实现&lt;/h2&gt;&lt;p&gt;在完成 data lab 过程中，我参考了部分如下几个博客的实现:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=&#34;&gt;CSAPP 实验一：DataLab 详细讲解与满分代码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NDk4Nzc0NzU=&#34;&gt;lab1 CSAPP：datalab&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTc0ODExMTI=&#34;&gt;CSAPP lab1: datalab&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==&#34;&gt;深入理解计算机系统之位操作实验&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="lab" />
        <updated>2024-02-05T07:50:22.000Z</updated>
    </entry>
</feed>
